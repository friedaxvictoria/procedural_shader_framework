{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfa8 Procedural Shader Development Documentation","text":"<p>Welcome to the Shader Snippets Documentation Site \u2014 a collaborative knowledge base for procedural shaders used in multiple engines including Unreal, Unity, and Godot.</p>"},{"location":"#what-are-shaders","title":"\ud83e\udde0 What Are Shaders?","text":"<p>Shaders are small programs that run on the GPU to control how objects are drawn on the screen \u2014 controlling color, shape, lighting, animation, and more. Procedural shaders use mathematical functions to generate visuals dynamically without relying on textures or models.</p> <p>\ud83c\udfa8 Explore All Shaders Implemented</p> <p>Want to see all procedural shaders adapted for this framework?</p> <p>\ud83e\udde0 Get full access to:</p> <ul> <li>Shader logic and breakdowns  </li> <li>Code previews with syntax highlighting  </li> <li>Demos, GIFs, and video walkthroughs</li> </ul> <p>\ud83d\udc49 Browse Shader Gallery \u2192</p>"},{"location":"#what-are-game-engines","title":"\ud83d\udd79\ufe0f What Are Game Engines?","text":"<p>Game engines like Unity, Unreal Engine, and Godot provide tools and runtimes for rendering 2D/3D scenes. Each engine supports its own shader system:</p> <ul> <li>Unreal: Uses Material Editor with optional HLSL for advanced effects</li> <li>Unity: Supports Shader Graph and HLSL via ShaderLab</li> <li>Godot: Uses a GLSL-inspired shading language and integrates with GDScript for control</li> </ul>"},{"location":"#how-are-shaders-rendered-in-engines","title":"\ud83d\udd04 How Are Shaders Rendered in Engines?","text":"<p>Engines convert your shader logic into renderable materials that can be applied to objects in the scene. Each engine may use:</p> <ul> <li>Visual Node Graphs (like Shader Graph in Unity or Material Editor in Unreal)</li> <li>Code-based shaders (HLSL, GLSL, or Godot Shading Language)</li> <li>Runtime scripting to animate or parameterize shader behavior</li> </ul> <p>This documentation bridges this gap, taking reusable shader logic and adapting it to each platform\u2019s workflow. This documentation helps shader developers and engine integrators:</p> <ul> <li>Understand how each shader works (algorithm, parameters, results).</li> <li>Learn how to use these shaders in different game engines.</li> <li>Explore visual demos and integration walkthroughs.</li> </ul> <p>\ud83e\udde9 Engine Integration Learn how to use shaders across different engines:</p> Engine Features Integration Guide \ud83d\ude80 Godot GDScript Control \u2022 ShaderMaterial \u2022 Scene Integration Setup Guide \u2192 \ud83c\udfac Unreal Engine Material Editor \u2022 HLSL Support Setup Guide \u2192 \ud83e\udde9 Unity Shader Graph \u2022 HLSL Support \u2022 Animation Timeline Setup Guide \u2192"},{"location":"#what-each-engine-section-includes","title":"\ud83d\udd27 What Each Engine Section Includes:","text":"<ul> <li>\u2705 Step-by-step setup guides with screenshots</li> <li>\u2705 Shader-specific implementation examples</li> <li>\u2705 Runtime parameter control methods</li> </ul>"},{"location":"#media-gallery","title":"\ud83d\udcf9 Media Gallery","text":"\ud83d\udc2c Swimming Dolphin \ud83c\udf05 Sunrise Lighting <p>Animations provided by Shader Team</p>"},{"location":"engines/engine_template/","title":"\ud83c\udfae [Shader Name] Shader \u2013 [Engine Name] Integration","text":"<ul> <li>Engine: [Engine Name]</li> <li>Shader Source: [shader source from docs/shaders/.....)</li> <li>Integration Type: Shader Graph (Visual Node....]</li> <li>Integrated By: [Team Member Name]</li> </ul>"},{"location":"engines/engine_template/#setup-overview","title":"\u2699\ufe0f Setup Overview","text":"<p>This shader simulates a looping flight animation using sinusoidal math. To integrate it in [Engine Name]:</p> <ol> <li>Use Shader Graph with Time and Math nodes.</li> <li>Create a Material using this shader.</li> <li>Apply it to a quad, mesh, or post-process object.</li> </ol>"},{"location":"engines/engine_template/#shader-graph-overview","title":"\ud83e\udde9 Shader Graph Overview","text":""},{"location":"engines/engine_template/#main-concepts","title":"Main Concepts:","text":"<ul> <li>Use <code>_Time.y</code> or custom time variable <code>T</code> (looping)</li> <li>Apply sine and cosine math for motion</li> <li>Optional: vertex displacement or UV distortion</li> </ul>"},{"location":"engines/engine_template/#nodes-to-use","title":"Nodes to Use:","text":"<ul> <li>Time</li> <li>Multiply / Add / Sine / Cosine</li> <li>Vector Math</li> <li>(Optional) Custom Function node for tiePos()</li> </ul>"},{"location":"engines/engine_template/#visual-setup","title":"\ud83d\uddbc\ufe0f Visual Setup","text":""},{"location":"engines/engine_template/#to-add-photo-and-video-look-into-the-shader_template-file-under-docsshader-directory","title":"(to add photo and video, look into the shader_template file under docs/shader/ directory....)","text":""},{"location":"engines/godot/","title":"Overal Structure","text":"Godot Engine Framework Structure by Jeewan Dhamala &amp; Mona Elbatran <p>Godot represents a light, open-source game development framework characterized by its integrated shader compiler and node-based architecture optimized for real-time graphics rendering in both 2D and 3D contexts. Distinguished from commercial alternatives such as Unity, Godot employs a purely code-based approach to shader development, eschewing visual scripting interfaces in favor of direct shader language implementation through its proprietary GDSL syntax.</p> <ul> <li>Integration Methods:<ul> <li>Visual Scripting: Not supported for shader development</li> <li>Standard Scripting: Godot Shader Language (GDSL)</li> </ul> </li> <li>Supported Render Pipelines: Default Scripting: GDScript with node lifecycle pipeline (_init(), _enter_tree(),              _ready(),_process(), etc.)</li> <li>Supported Engine Versions: Comprehensive testing conducted on Godot 4.2.1 </li> <li>Implemented Shader Categories:<ul> <li>CanvasItem Shaders (2D post-processing and UI effects)</li> <li>Spatial Shaders (3D material systems and surface rendering)</li> </ul> </li> </ul>"},{"location":"engines/godot/#file-structure","title":"File Structure","text":"<p>This framework structure showcases a Godot Engine setup for a rendering-focused application using GDScript  and GLSL shaders. Below is an overview of how the project is structured, including scripts, shaders,  and their interactions.</p> <pre><code>godot/\n\u251c\u2500\u2500 \ud83d\udcc1 .vscode/\n\u251c\u2500\u2500 \ud83d\udcc1 addons/\n\u251c\u2500\u2500 \ud83d\udcc1 includes/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 global_variables/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 global_variables.gdshaderinc\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 helper_functions/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 helper_functions.gdshaderinc\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 sdf_updated.gdshaderinc\n\u251c\u2500\u2500 \ud83d\udcc1 scripts/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 sdf_updated.gd\n\u251c\u2500\u2500 \u2699\ufe0f .editorconfig\n\u251c\u2500\u2500 \ud83d\udccb .gitattributes\n\u251c\u2500\u2500 \ud83d\udeab .gitignore\n\u251c\u2500\u2500 \ud83d\uddbc\ufe0f icon.svg\n\u251c\u2500\u2500 \ud83d\udcc4 icon.svg.import\n\u251c\u2500\u2500 \ud83c\udfae project.godot\n\u251c\u2500\u2500 \ud83d\udcd6 README.md\n\u251c\u2500\u2500 \ud83c\udfa8 sdf_updated.gdshader\n\u251c\u2500\u2500 \ud83c\udf33 sdf_updated.tres\n\u2514\u2500\u2500 \ud83c\udfac sdf_updated.tscn\n</code></pre>"},{"location":"engines/godot/#getting-started","title":"Getting Started","text":"<ol> <li>Clone or download the project files Click Here for Link</li> <li>Open the project in Godot Engine</li> <li>Run the main scene (<code>sdf_updated.tscn</code>) to see the SDF rendering in action</li> <li>Modify the SDF Manager script (<code>sdf_updated.gd</code>) to add custom shapes and effects</li> <li>Experiment with shader parameters, through inspector, to achieve desired visual results</li> </ol>"},{"location":"engines/godot/#framework-workflow","title":"Framework Workflow","text":"<ol> <li>User Interaction: The user modifies the scene by adding or removing SDFs via scripts in the directory <code>scripts/sdf_updated.gd</code>, attached to nodes in <code>sdf_updated.tscn</code>.</li> <li>Data Passing: The GDScript updates shader uniforms (e.g., SDF positions, sizes) through the global variables system.</li> <li>Shader Processing:<ul> <li>The main fragment shader (<code>sdf_updated.gdshader</code>) includes the main rendering file (<code>sdf_updated.gdshaderinc</code>).</li> <li>Helper functions from <code>includes/helper_functions/</code> support the main rendering logic.</li> <li>Global variables from <code>includes/global_variables/</code> provide shared data access.</li> <li>The IntegrationFlexible method combines raymarching, lighting, and noise to produce the final image.</li> </ul> </li> <li>Rendering: The shader outputs the final pixel colors, rendering the dynamic SDF scene in the <code>sdf_updated.tscn</code> scene.</li> </ol> <p>\ud83d\udc49 View how it works\u2192</p>"},{"location":"engines/godot/#overal-structure-in-detail","title":"Overal Structure in Detail","text":""},{"location":"engines/godot/#1-global-variables","title":"1. Global Variables","text":"<p>Global variables are managed in the <code>includes/global_variables/</code> folder to store all shared variables used across the shaders, ensuring consistency and ease of access.</p> <ul> <li>Location: <code>includes/global_variables/</code> folder</li> <li>Purpose: Defines global constants and uniforms used throughout the shader pipeline.</li> </ul> <p>Examples: - uniform vec2 resolution: Screen resolution for rendering. - uniform float time: Animation time for dynamic effects. - uniform vec3 camera_pos: Camera position for raymarching. - SDF-specific parameters (e.g., positions, sizes, or types of SDFs).</p> <p>Usage: Included in the main fragment shader and other shader files to access shared variables.</p> <p>\ud83d\udc49 View how it works\u2192</p>"},{"location":"engines/godot/#2-helper-functions-for-rendering","title":"2. Helper Functions for Rendering","text":"<p>Helper functions are stored in the <code>includes/helper_functions/</code> folder to support the main rendering logic. These are called within the main shader include files to perform specific tasks.</p> <ul> <li>Location: <code>includes/helper_functions/</code> folder</li> <li>Purpose: Contains utility functions for rendering, such as vector transformations, color manipulations, or mathematical utilities.</li> </ul> <p>Examples: - Normalizing vectors for lighting calculations. - Converting coordinates for raymarching. - Utility functions for blending or interpolating values.</p> <p>\ud83d\udc49 View how it works\u2192</p>"},{"location":"engines/godot/#3-gdscript-file-for-dynamic-sdf-management","title":"3. GDScript File for Dynamic SDF Management","text":"<p>A GDScript file is attached to a Node2D to allow users to dynamically add or remove Signed Distance Fields (SDFs) on the screen. This script provides an interface for manipulating SDFs, which are then passed to the shader for rendering.</p> <ul> <li>Location: <code>scripts/</code> folder</li> <li>Purpose: Manages the creation, modification, and removal of SDFs. Users can interact with this script to customize the scene dynamically.</li> </ul> <p>Key Functionality: - Add SDFs (e.g., torus, dolphin) to the scene. - Remove SDFs based on user input. - Update shader parameters with SDF data for rendering.</p> <p>\ud83d\udc49 View how it works\u2192</p>"},{"location":"engines/godot/#4-main-gdshader-include-files","title":"4. Main GDShader Include Files","text":"<p>The project uses the main shader include file <code>sdf_updated.gdshaderinc</code> that contains core rendering logic, such as lighting, raymarching, and noise functions. This file is included in the main fragment shader to provide the complete rendering pipeline.</p> <p>File: - <code>includes/sdf_updated.gdshaderinc</code>: Contains the complete rendering pipeline including lighting calculations, raymarching algorithms, and noise functions for procedural effects.</p> <p>Purpose: This file contains the modularized shader logic, making it reusable and easier to maintain across different scenes.</p> <p>\ud83d\udc49 View how it works\u2192</p> <p>Usage: Referenced by the main <code>sdf_updated.gdshaderinc</code> file as needed.</p>"},{"location":"engines/godot/#5-main-fragment-shader","title":"5. Main Fragment Shader","text":"<p>The main fragment shader orchestrates the rendering pipeline by calling the IntegrationFlexible method defined in the <code>sdf_updated.gdshaderinc</code> file.</p> <ul> <li>File: <code>sdf_updated.gdshader</code></li> <li>Scene: <code>sdf_updated.tscn</code></li> <li>Resource: <code>sdf_updated.tres</code></li> <li>Purpose: Combines all shader logic to produce the final pixel colors.</li> </ul> <p>Key Functionality: - Includes global variables for shared data. - Includes the main <code>sdf_updated.gdshaderinc</code> file. - Calls the IntegrationFlexible method, which integrates raymarching, lighting, and noise effects to render the scene.</p> <p>Structure: <pre><code>shader_type canvas_item;\n\n#include \"includes/sdf_updated.gdshaderinc\"\n\nvoid fragment() {\n    vec3 color = IntegrationFlexible(FRAGCOORD, resolution, time, camera_pos);\n    COLOR = vec4(color, 1.0);\n}\n</code></pre> \ud83d\udc49 View how it works\u2192</p>"},{"location":"engines/godot/#key-features","title":"Key Features","text":"<ul> <li>Dynamic SDF Manipulation: Real-time addition and removal of geometric primitives</li> <li>Modular Shader Architecture: Organized shader code for maintainability and reusability</li> <li>Flexible Rendering Pipeline: Supports various lighting models and procedural effects</li> <li>Performance Optimized: Efficient raymarching implementation for real-time rendering</li> <li>User-Friendly Interface: GDScript integration for easy scene modification</li> </ul>"},{"location":"engines/godot/#requirements","title":"Requirements","text":"<ul> <li>Godot Engine 4.x</li> <li>Graphics card with shader support</li> <li>Basic understanding of GDScript and GLSL shaders</li> </ul>"},{"location":"engines/unity/","title":"Overview","text":"Overview by Frieda Hentschel <p>Unity is a versatile real-time engine known for its ShaderGraph system, cross-platform support, and ease of integration for custom shaders.</p> <ul> <li>Integration Methods: <ul> <li>Visual Scripting: ShaderGraph</li> <li>Standard Scripting: ShaderLab </li> </ul> </li> <li>Supported Render Pipelines: URP (Universal Render Pipeline), others may work but were not tested </li> <li>Supported Unity Versions: All functions were tested on Unity 2022.3.50 and Unity 6000.0.4 </li> <li>Supported Shader Types:<ul> <li>Unlit Shader</li> <li>Lit Shader/Standard Surface Shader</li> <li>Fullscreen Shader</li> </ul> </li> </ul>"},{"location":"engines/unity/#integrate-the-framework","title":"Integrate the Framework","text":"<p>To easily include the integration of the framework into any Unity project, it is available as a UPM. The following gives a step by step guide on how to set up a project with it:</p> <ol> <li> <p>Create a URP project (Universal Render Pipeline) in Unity</p> </li> <li> <p>Navigate to Window/Package Manager</p> <p> </p> </li> <li> <p>Add a new package using Add package from git URL. Use the following url in the popup-window: https://github.com/friedaxvictoria/ProceduralShaderFrameworkPackage.git.</p> <p> </p> </li> <li> <p>Locate the package in the project. Include the prefab ShaderUniformControl that can be found at ProceduralShaderFrameworkPackage/Runtime/uniforms into the scene. This is essential for the required uniforms to be set. Read more about their purpose at Uniforms and C#.</p> <p> </p> </li> <li> <p>Create a custom shader with ShaderGraph or ShaderLab.</p> Visual ScriptingStandard Scripting <p>Create a ShaderGraph via a right-click in the project Create/Shader Graph/URP/....  Decide what kind of shader is required. </p> <p> </p> <p>Create a ShaderLab file via a right-click in the project Create/Shader/....  Decide what kind of shader is required. The Standard Surface Shader is roughly the equvalent to the Lit Shader in ShaderGraph. Fullscreen Shaders have to be handled in the shader code.</p> <p> </p> </li> <li> <p>Create a complementary material via a right-click in the project Create/Material</p> <p> </p> <p>Unity's ShaderGraph supports <code>half floating point</code> and <code>floating point</code> as its precision. This framework only supports the later. Thus, ensure that in the Graph's inspector under Graph Settings/Precision Single is chosen. This is typically the default.</p> </li> <li> <p>Apply the shader to a Unity material by dragging it onto the material.</p> </li> <li> <p>Apply the material to an object of choice or set it up as a full screen material.</p> <ul> <li> <p>Object Material: Drag the Material into the Material-section of the object in the inspector.</p> <p> </p> </li> <li> <p>Fullscreen Material: </p> <ul> <li>Locate the project's renderer at Assets/Settings/URP-High Fidelity-Renderer</li> <li>Add a Full Screen Pass Renderer Feature via the Add Renderer Feature in the inspector</li> <li>Drag the material of choice to the Pass Material section</li> </ul> <p> </p> </li> </ul> </li> <li> <p>Integrate the Uniforms and start composing a custom shader.</p> </li> </ol>"},{"location":"engines/unity/#visual-scripting","title":"Visual Scripting","text":"<p>The functions have been integrated as Sub Graphs that are callable as nodes in a ShaderGraph. All nodes are located under PSF short for Procedural Shader Framework once the UPM has been included. Detailed paths for the individual nodes are noted after the description of each of the functions. </p> <p>To simplify some initial setups, nodes come with default parameters. For each description of an input parameter, the node's default value for said parameter is noted. If no default value is explicitly mentioned, it can be assumed to be zero for the respective amount of dimensions. </p> <p>Be aware that the visual previews of the nodes might not be expressive. E.g. if correctly used, the visual preview for an SDF node will always be uniformly black or white.</p>"},{"location":"engines/unity/#standard-scipting","title":"Standard Scipting","text":"<p>Due to the requirement of noting the precision in ShaderGraph, all functions that were implemented as nodes for Visual Scripting are appended with an _float. </p> <p>Note that all other helper functions (e.g. Helper Functions) can still be called in ShaderLab and do not have the appendix.</p> <p>!Utku Input</p> <p>Find the Tutorials to discover in-depth explanations on how to construct custom procedural shaders in Unity and to better understand the relations between functions.</p>"},{"location":"engines/unreal/","title":"\ud83c\udfae Unreal Engine Shader Integrations","text":"<p>Unreal implementations are built using the Material Editor, with node-based logic and optional HLSL custom expressions.</p> <p>Unreal Engine is a high-fidelity engine used in AAA games and cinematic visuals. It supports complex materials via the Material Editor and HLSL expressions.</p>"},{"location":"engines/unreal/#engine-overview","title":"\ud83e\udde0 Engine Overview","text":"<ul> <li>Rendering Pipeline: Forward+ / Deferred / Lumen  </li> <li>Shader Language: HLSL (via Material Expressions)  </li> <li>Integration Method: Material Editor + Custom Nodes  </li> <li>Ideal For: Photorealism, cinematic FX, AAA games  </li> <li>Real-Time Preview: \u2705 Yes  </li> <li>Visual Editing: \u2705 Highly advanced material graph  </li> </ul> <p>Unreal\u2019s powerful editor is ideal for performance-heavy and cinematic procedural shaders.</p> <p>\ud83c\udfa8 Explore All Shaders in This Engine</p> <p>Want to see all procedural shaders adapted for this engine?</p> <p>\ud83e\udde0 Get full access to: - Shader logic and breakdowns - Code previews with syntax highlighting - Demos, GIFs, and video walkthroughs</p> <p>\ud83d\udc49 Browse Shader Gallery \u2192</p>"},{"location":"engines/unreal/#integration-list","title":"\ud83d\udd27 Integration List","text":"Shader Name Integration Type Link More coming soon \u2014 \u2014"},{"location":"engines/unreal/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>Use Material Function assets for modularity.</li> <li>Supports Post-Process Materials.</li> <li>Good for performance-tuned projects.</li> </ul>"},{"location":"engines/unreal/#material-graph-logic","title":"\ud83e\udde0 Material Graph Logic","text":"<ul> <li>Time input (from Blueprint or <code>Time</code> node)</li> <li>Use <code>Sine</code>, <code>Cosine</code>, <code>Add</code>, <code>Multiply</code> nodes</li> <li>Material Function to encapsulate <code>tiePos()</code> logic</li> </ul>"},{"location":"engines/godot/gdScript/","title":"GD Script","text":"SDF Script Guide: Adding and Removing Objects by Jeewan"},{"location":"engines/godot/gdScript/#overview","title":"Overview","text":"<p>This script (<code>addons/scripts/sdf_updated.gd</code>) is a Godot 4 script that manages Signed Distance Field (SDF) objects for real-time 3D rendering using shaders. It extends <code>Node2D</code> and provides a system for creating, configuring, and animating various 3D shapes in a shader-based rendering pipeline.</p>"},{"location":"engines/godot/gdScript/#script-structure-breakdown","title":"Script Structure Breakdown","text":""},{"location":"engines/godot/gdScript/#1-export-variables-inspector-configuration","title":"1. Export Variables (Inspector Configuration)","text":"<pre><code>@export var shader_material_target: CanvasItem\n@export var MAX_OBJECTS: int = 15\n@export var lightPosition: Vector3 = Vector3(0.0, 4.0, 7.0)\n@export var cameraPosition: Vector3 = Vector3(0.0, 13.0 , 13.0)\n# ... and many more camera/rendering settings\n</code></pre> <p>Purpose: These variables appear in the Godot Inspector and allow artists/designers to configure the rendering without touching code.</p>"},{"location":"engines/godot/gdScript/#2-enums-configuration-options","title":"2. Enums (Configuration Options)","text":"<pre><code>enum CameraMode1 { MOUSE_CONTROL, AUTO_ORBIT, STATIC_CAMERA, BACKANDFORTH, SHAKE }\nenum TerrainMode { NONE, WATER, DESERT }\nenum ColorMode { STATIC, CYCLE_COLOR, WAVE_COLOR }\nenum AnimationMode { NO_ANIMATION, PULSE_ANIMATION }\n</code></pre> <p>Purpose: Define different modes for camera control, terrain rendering, coloring, and animation.</p>"},{"location":"engines/godot/gdScript/#3-shaderobject-class","title":"3. ShaderObject Class","text":"<pre><code>class ShaderObject:\n    var type: int           # Shape type (0=sphere, 1=cube, 2=torus, etc.)\n    var position: Vector3   # 3D position\n    var size: Vector3       # Dimensions\n    var radius: float       # Radius for rounded shapes\n    var color: Vector3      # RGB color\n    var noise_type: int     # Type of noise effect\n    # ... additional properties for lighting and animation\n</code></pre> <p>Purpose: Represents a single 3D object with all its properties that will be rendered by the shader.</p>"},{"location":"engines/godot/gdScript/#how-to-addremove-sdfs-step-by-step-guide","title":"How to Add/Remove SDFs - Step by Step Guide","text":""},{"location":"engines/godot/gdScript/#understanding-sdf-types","title":"Understanding SDF Types","text":"<p>The script supports these SDF types (identified by the <code>type</code> parameter):</p> Type Shape Description 0 Sphere Basic sphere shape 1 Cube Box/cube shape 2 Torus Donut shape 3 Dolphin Complex animated dolphin model 4 Hex Prism Hexagonal prism 5 Octahedron 8-sided polyhedron 6 Ellipsoid Stretched sphere"},{"location":"engines/godot/gdScript/#step-1-locate-the-sdf-array","title":"Step 1: Locate the SDF Array","text":"<p>Find the <code>shader_objects</code> array in the <code>_ready()</code> function:</p> <pre><code>func _ready():\n    shader_objects = [\n        # This is where you add/remove objects\n        ShaderObject.new().set_values(2, Vector3(0.0,0.0, 0.0), Vector3(1.0,5.0,1.5), 0.2, Vector3(1.0, 0.2, 0.2),2),\n    ]\n</code></pre>"},{"location":"engines/godot/gdScript/#step-2-adding-new-sdfs","title":"Step 2: Adding New SDFs","text":"<p>To add a new SDF, create a new <code>ShaderObject</code> line using this format:</p> <pre><code>ShaderObject.new().set_values(type, position, size, radius, color, noise_type, specular_color, specular_strength, shininess, speed, direction, time_offset)\n</code></pre>"},{"location":"engines/godot/gdScript/#parameters-required","title":"Parameters (Required):","text":"<ul> <li>type: Shape type (0-6, see table above)</li> <li>position: Vector3(x, y, z) - 3D position</li> <li>size: Vector3(width, height, depth) - dimensions</li> <li>radius: float - radius/rounding amount</li> <li>color: Vector3(r, g, b) - RGB color (0.0-1.0 range)</li> <li>noise_type: int - noise effect type</li> <li>specular_color: Vector3 - specular highlight color (default: Vector3.ONE)</li> <li>specular_strength: float - specular intensity (default: 0.5)</li> <li>shininess: float - surface shininess (default: 32.0)</li> <li>speed: float - animation speed (default: 1.0)</li> <li>direction: Vector3 - movement direction (default: Vector3(1,0,0))</li> <li>time_offset: float - animation timing offset (default: 0.0)</li> </ul>"},{"location":"engines/godot/gdScript/#step-3-practical-examples","title":"Step 3: Practical Examples","text":""},{"location":"engines/godot/gdScript/#example-1-adding-a-simple-sphere","title":"Example 1: Adding a Simple Sphere","text":"<pre><code>shader_objects = [\n    # Add a blue sphere at origin\n    ShaderObject.new().set_values(0, Vector3(0, 3.0, 0), Vector3.ZERO, 1.0, Vector3(0.2, 0.2, 1.0), 0),\n    # Existing objects...\n]\n</code></pre>"},{"location":"engines/godot/gdScript/#example-2-adding-multiple-cubes","title":"Example 2: Adding Multiple Cubes","text":"<pre><code>shader_objects = [\n    # Green cubes on left and right\n    ShaderObject.new().set_values(1, Vector3(1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2), 0),\n    ShaderObject.new().set_values(1, Vector3(-1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2), 0),\n    # Existing objects...\n]\n</code></pre>"},{"location":"engines/godot/gdScript/#example-3-adding-an-animated-dolphin","title":"Example 3: Adding an Animated Dolphin","text":"<pre><code>shader_objects = [\n    # Animated dolphin with custom movement\n    ShaderObject.new().set_values(3, Vector3(0, 2.5, 0), Vector3(8.0, 8.0, 8.0), 5.0, Vector3(0.5, 0.7, 1.0), 0, Vector3.ONE, 0.8, 16.0, 2.0, Vector3(1, 0, 0.2), 0.0),\n    # Existing objects...\n]\n</code></pre>"},{"location":"engines/godot/gdScript/#example-4-complete-scene-setup","title":"Example 4: Complete Scene Setup","text":"<pre><code>shader_objects = [\n    # Central torus (red)\n    ShaderObject.new().set_values(2, Vector3(0.0, 0.0, 0.0), Vector3(1.0, 5.0, 1.5), 0.2, Vector3(1.0, 0.2, 0.2), 2),\n\n    # Floating spheres (blue)\n    ShaderObject.new().set_values(0, Vector3(3.0, 2.0, 0), Vector3.ZERO, 0.8, Vector3(0.2, 0.2, 1.0), 0),\n    ShaderObject.new().set_values(0, Vector3(-3.0, 2.0, 0), Vector3.ZERO, 0.8, Vector3(0.2, 0.2, 1.0), 0),\n\n    # Ground cubes (green)\n    ShaderObject.new().set_values(1, Vector3(2.0, -1.0, 2.0), Vector3(0.5, 0.5, 0.5), 0.1, Vector3(0.2, 1.0, 0.2), 0),\n    ShaderObject.new().set_values(1, Vector3(-2.0, -1.0, 2.0), Vector3(0.5, 0.5, 0.5), 0.1, Vector3(0.2, 1.0, 0.2), 0),\n]\n</code></pre>"},{"location":"engines/godot/gdScript/#step-4-removing-sdfs","title":"Step 4: Removing SDFs","text":"<p>To remove an SDF, simply: 1. Comment out the line by adding <code>#</code> at the beginning: <pre><code># ShaderObject.new().set_values(0, Vector3(0, 3.0, 0), Vector3.ZERO, 1.0, Vector3(0.2, 0.2, 1.0), 0),\n</code></pre></p> <ol> <li> <p>Delete the entire line completely</p> </li> <li> <p>Replace with a different object by changing the parameters</p> </li> </ol>"},{"location":"engines/godot/gdScript/#step-5-important-limitations","title":"Step 5: Important Limitations","text":"<ul> <li>Maximum Objects: Limited to 15 objects (defined by <code>MAX_OBJECTS</code>)</li> <li>Performance: More objects = lower performance</li> <li>Shader Compatibility: The shader must support the SDF types you're using</li> </ul>"},{"location":"engines/godot/gdScript/#step-6-testing-your-changes","title":"Step 6: Testing Your Changes","text":"<ol> <li>Save the script</li> <li>Run the scene</li> <li>Check the console for debug output:    <pre><code>Object count: 3\nTypes: [2, 0, 1]\nPositions: [(0, 0, 0), (3, 2, 0), (-3, 2, 0)]\n</code></pre></li> </ol>"},{"location":"engines/godot/gdScript/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"engines/godot/gdScript/#objects-not-appearing","title":"Objects Not Appearing","text":"<ol> <li>Check the type number - ensure it matches a supported SDF type</li> <li>Verify position - object might be outside the camera view</li> <li>Check MAX_OBJECTS limit - you might have too many objects</li> </ol>"},{"location":"engines/godot/gdScript/#color-issues","title":"Color Issues","text":"<ol> <li>RGB values should be between 0.0 and 1.0</li> <li>Black objects might have Vector3(0, 0, 0) color</li> <li>Check lighting - adjust lightPosition if objects appear too dark</li> </ol>"},{"location":"engines/godot/gdScript/#summary","title":"Summary","text":"<p>This script provides a powerful system for creating 3D scenes using SDF rendering. The key to adding/removing objects is understanding the <code>ShaderObject.set_values()</code> function and modifying the <code>shader_objects</code> array in the <code>_ready()</code> function. Start with simple shapes and gradually add complexity as needed.</p>"},{"location":"engines/godot/gdShaderInclude/","title":"GD Shader Include","text":"SDF Shader Include File Documentation by Jeewan"},{"location":"engines/godot/gdShaderInclude/#introduction","title":"Introduction","text":"<p>This documentation covers the comprehensive 3D rendering pipeline implemented in the sdf_updated.gdshaderinc file for Godot. The system integrates signed distance field (SDF) objects, water effects, and desert terrain using advanced ray marching techniques through a single, unified method.</p>"},{"location":"engines/godot/gdShaderInclude/#include-files-overview","title":"Include Files Overview","text":""},{"location":"engines/godot/gdShaderInclude/#what-is-an-include-file","title":"What is an Include File?","text":"<p>An include file (<code>.gdshaderinc</code>) in Godot is a modular shader component that contains reusable shader code. It serves as a library of functions, constants, and utilities that can be included in multiple shader files using the <code>#include</code> directive.</p>"},{"location":"engines/godot/gdShaderInclude/#purpose-of-include-files","title":"Purpose of Include Files","text":"<ul> <li>Code Reusability: Write once, use in multiple shaders</li> <li>Modularity: Organize complex shader logic into manageable components  </li> <li>Maintainability: Update shared functionality in one place</li> <li>Performance: Compiled once and shared across shaders</li> <li>Organization: Keep main shader files clean and focused</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#file-structure","title":"File Structure","text":"<p>The <code>sdf_updated.gdshaderinc</code> file includes:</p>"},{"location":"engines/godot/gdShaderInclude/#core-dependencies","title":"Core Dependencies","text":"<pre><code>#include \"res://addons/includes/helper_functions/helper_func.gdshaderinc\"\n#include \"res://addons/includes/global_variables/global_variables.gdshaderinc\"\n</code></pre> <ul> <li>Imports essential helper functions and global variables</li> <li>Provides access to camera controls, animation systems, and uniform parameters</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#integrationflexible-method-main-entry-point","title":"IntegrationFlexible Method - Main Entry Point","text":"<p>The <code>sdf_updated.gdshaderinc</code> file is designed around one primary method: <code>IntegrationFlexible</code>. This method serves as the complete 3D rendering system and contains the implementation of all other functionality within itself, including:</p> <ul> <li>Ray marching algorithms for SDF objects</li> <li>Water surface generation and rendering</li> <li>Desert terrain creation and lighting</li> <li>Camera animation systems with multiple modes</li> <li>Scene composition and surface selection</li> <li>Lighting calculations for all surface types</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#key-design-principle","title":"Key Design Principle:","text":"<p>All rendering functionality is self-contained within the <code>IntegrationFlexible</code> method. We don't need to call separate methods for ray marching, water effects, or desert rendering, everything is integrated into this single, comprehensive function.</p>"},{"location":"engines/godot/gdShaderInclude/#integrationflexible-method","title":"IntegrationFlexible Method","text":""},{"location":"engines/godot/gdShaderInclude/#overview","title":"Overview","text":"<p>The <code>IntegrationFlexible</code> method is the central integration point for rendering a 3D scene in a fragment shader. It combines procedural terrain systems (water and desert) with SDF-based objects using ray marching.</p>"},{"location":"engines/godot/gdShaderInclude/#method-signature","title":"Method Signature","text":"<pre><code>void IntegrationFlexible(vec2 INuv, out vec4 frgColor3)\n</code></pre> <p>Parameters:</p> <ul> <li><code>INuv</code>: Normalized UV coordinates (0 to 1) from the fragment shader</li> <li><code>frgColor3</code>: Final RGBA color output for the fragment</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#core-functionality","title":"Core Functionality","text":"<p>The method handles:</p> <ol> <li>Camera Setup: Various animation modes (mouse control, orbiting, static)</li> <li>Ray Marching: Find closest surface (SDF object, water, or desert)</li> <li>Terrain Rendering: Specialized ray marching for water and desert</li> <li>Lighting: Phong lighting for SDF objects and desert, custom water effects</li> <li>Scene Composition: Select and render closest surface with fallbacks</li> </ol>"},{"location":"engines/godot/gdShaderInclude/#camera-control-architecture","title":"Camera Control Architecture","text":""},{"location":"engines/godot/gdShaderInclude/#camera-setup-and-ray-generation","title":"Camera Setup and Ray Generation","text":"<p>The method begins by configuring the camera system with support for multiple animation modes:</p> <pre><code>vec4 frgColor = vec4(0.0);\nvec2 uv;\ncomputeUV_float(INuv, uv);\n\n// Animation system with dual camera matrices\nmat3 animationMatrix1;\nmat3 animationMatrix2;\nmat3 baseMatrix = mat3(1.0); // Identity matrix\nfloat distance;\nvec3 rayOrigin;\n</code></pre> <p>Initialization:</p> <ul> <li><code>frgColor</code>: Initialized to transparent black, updated with final pixel color</li> <li><code>uv</code>: Computed from <code>INuv</code> using <code>computeUV_float</code> (internal method)</li> <li>Camera matrices: Two 3x3 matrices for complex camera transformations</li> <li><code>distance</code>: Distance from camera to look-at position</li> <li><code>rayOrigin</code>: Camera's position in world space</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#camera-animation-modes","title":"Camera Animation Modes","text":"<p>The method supports multiple camera modes for dynamic scene exploration:</p> <pre><code>if (camera_mode1 == MOUSE_CONTROL) {\n    move_via_mouse_float(animationMatrix1);\n    distance = length(camera_position - look_at_position);\n} else if (camera_mode1 == AUTO_ORBIT) {\n    orbitY_float(orbit_axis, orbit_speed, animationMatrix1);\n    distance = length(camera_position - look_at_position);\n} else if (camera_mode1 == STATIC_CAMERA) {\n    animationMatrix1 = mat3(1.0);\n    distance = length(camera_position - look_at_position);\n}\n// ... additional modes\n</code></pre> <p>Available Camera Modes:</p> <ul> <li>MOUSE_CONTROL: User-controlled rotation via <code>move_via_mouse_float()</code></li> <li>AUTO_ORBIT: Automatic rotation around Y-axis via <code>orbitY_float()</code></li> <li>STATIC_CAMERA: Fixed camera position</li> <li>BACKANDFORTH: Oscillating movement via <code>backAndForth_scale_float()</code></li> <li>SHAKE: Camera shake effect via <code>shake_matrix_float()</code></li> </ul>"},{"location":"engines/godot/gdShaderInclude/#ray-direction-calculation","title":"Ray Direction Calculation","text":"<pre><code>mat3 finalCameraMatrix;\nvec3 target = look_at_position;\ngetCameraMatrix_float(animationMatrix1, animationMatrix2, distance, target, finalCameraMatrix, rayOrigin);\n\nvec3 rd = normalize(finalCameraMatrix * vec3(uv, -1.5));\nvec3 ro = rayOrigin;\n</code></pre> <p>The <code>getCameraMatrix_float()</code> method combines both animation matrices to produce the final camera transformation and ray origin.</p>"},{"location":"engines/godot/gdShaderInclude/#ray-marching-implementation","title":"Ray Marching Implementation","text":""},{"location":"engines/godot/gdShaderInclude/#core-ray-marching-function","title":"Core Ray Marching Function","text":"<p>The <code>raymarch()</code> method traces rays to find the closest SDF object:</p> <pre><code>float raymarch(vec3 ro, vec3 rd, out vec3 hitPos, out int gHitID) {\n    gHitID = -1;\n    hitPos = vec3(0.0);\n    float t = 0.0;\n\n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = evaluateScene(p, gHitID);\n\n        // Apply noise based on object type\n        if (gHitID &gt;= 0) {\n            int noise_type = obj_noise[gHitID];\n            // ... noise application logic\n        }\n\n        if (d &lt; 0.001) {\n            hitPos = p;\n            return t;\n        }\n\n        if (t &gt; 50.0) break;\n        t += d;\n    }\n\n    return -1.0;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#scene-evaluation","title":"Scene Evaluation","text":"<p>The <code>evaluateScene()</code> method finds the closest object:</p> <pre><code>float evaluateScene(vec3 p, out int gHitID) {\n    float d = 100000.0;\n    int bestID = -1;\n\n    for (int i = 0; i &lt; inputCount; ++i) {\n        float di = evalSDF(obj_type[i], obj_position[i], obj_size[i], obj_radius[i], p, i);\n        if (di &lt; d) {\n            d = di;\n            bestID = i;\n        }\n    }\n\n    gHitID = bestID;\n    return d;\n}\n</code></pre> <p>The <code>evalSDF()</code> method handles different object types (spheres, boxes, dolphins, etc.) with animation support.</p>"},{"location":"engines/godot/gdShaderInclude/#lighting-system","title":"Lighting System","text":""},{"location":"engines/godot/gdShaderInclude/#phong-lighting","title":"Phong Lighting","text":"<p>The <code>applyPhongLighting_float()</code> method is used to compute lighting on standard SDF objects using the Phong reflection model. It simulates diffuse, ambient, and specular light components to create realistic lighting for smooth and hard-surface materials.</p> <pre><code>void applyPhongLighting_float(vec3 hitPos, int hitID, vec3 cameraPosition, vec3 normal, vec3 baseColor, vec3 specularColor, float specularStrength, float shininess, out vec3 lightingColor)\n{\n    vec3 viewDir, lightDir, lightColor, ambientColor;\n    lightingContext(hitPos, cameraPosition, viewDir, lightDir, lightColor, ambientColor);\n\n    normal = normalize(normal);\n    float diff = max(dot(normal, lightDir), 0.15);\n\n    vec3 R = reflect(-lightDir, normal);\n    float spec = pow(max(dot(R, viewDir), 0.0), shininess);\n\n    vec3 colour = baseColor;\n    vec3 diffuse = diff * colour * lightColor;\n    vec3 specular = spec * specularColor * specularStrength;\n\n    vec3 enhancedAmbient = ambientColor * baseColor * 0.4;\n    lightingColor = enhancedAmbient + diffuse + specular;\n}\n</code></pre> <p>Lighting Breakdown:</p> <ul> <li>Ambient: Multiplies the base color by ambient light</li> <li>Diffuse: Based on dot product between light direction and surface normal</li> <li>Specular: Computed using the reflection vector and view direction</li> <li>Final Color: Sum of ambient, diffuse, and specular components</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#desert-phong-lighting","title":"Desert Phong Lighting","text":"<p>The <code>applyDesertPhongLighting_float()</code> function is a specialized lighting method for rendering desert terrain with more organic and natural characteristics.</p> <pre><code>void applyDesertPhongLighting_float(vec3 hitPos, int hitID, vec3 cameraPosition, vec3 normal, vec3 baseColor, vec3 specularColor, float specularStrength, float shininess, out vec3 lightingColor){\n    vec3 viewDir, lightDir, lightColor, ambientColor;\n    desertLightingContext(hitPos, cameraPosition, viewDir, lightDir, lightColor, ambientColor);\n    normal = normalize(normal);\n    float diff = max(dot(normal, lightDir), 0.3);\n    float subsurface = pow(max(0.0, dot(-lightDir, viewDir)), 2.0) * 0.1;\n    vec3 R = reflect(-lightDir, normal);\n    float spec = pow(max(dot(R, viewDir), 0.0), shininess);\n    vec3 colour = baseColor;\n    vec3 diffuse = diff * colour * lightColor;\n    vec3 specular = spec * specularColor * specularStrength;\n    vec3 enhancedAmbient = ambientColor * baseColor * 0.4;\n    vec3 subsurfaceContrib = subsurface * colour * lightColor * 0.5;\n    lightingColor = enhancedAmbient + diffuse + specular + subsurfaceContrib;\n}\n</code></pre> <p>Differences from Standard Phong Lighting:</p> <ul> <li>Subsurface Scattering: Adds a soft backlighting effect simulating light passing through sand grains</li> <li>Adjusted Diffuse Strength: Slightly higher base diffuse contribution (0.3 instead of 0.15)</li> <li>Softer Specular Highlights: Uses lower specularStrength and shininess to simulate rough, matte surfaces</li> <li>Enhanced Ambient Contribution: Maintains richer base color in shaded areas</li> <li>Lighting Context: Uses a separate desertLightingContext() to better simulate outdoor sunlight</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#terrain-integration","title":"Terrain Integration","text":""},{"location":"engines/godot/gdShaderInclude/#water-effect-system","title":"Water Effect System","text":""},{"location":"engines/godot/gdShaderInclude/#water-ray-marching","title":"Water Ray Marching","text":"<p>The <code>traceWater()</code> method performs ray marching for water surfaces:</p> <pre><code>vec2 traceWater(vec3 rayOrigin, vec3 rayDir, float globalTimeWrapped,\n                inout vec3 controlPoint, inout float waveStrength) {\n    vec2 hit = vec2(0.1);\n\n    for (int i = 0; i &lt; 128; i++) {\n        vec2 d = evaluateDistanceField(rayOrigin + rayDir * hit.x, 1.0, \n                                      globalTimeWrapped, controlPoint, waveStrength);\n        if (d.x &lt; 0.0001 || hit.x &gt; 43.0) break;\n        hit.x += d.x;\n        hit.y = d.y;\n    }\n\n    return hit;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#wave-generation","title":"Wave Generation","text":"<p>The <code>computeWave()</code> method creates dynamic water surfaces:</p> <pre><code>float computeWave(vec3 pos, int iterationCount, float writeOut, float globalTimeWrapped,\n                  inout vec3 controlPoint, inout float waveStrength) {\n    vec3 warped = pos - vec3(0.0, 0.0, globalTimeWrapped * 3.0);\n    float accum = 0.0;\n    float amplitude = 3.0;\n\n    for (int i = 0; i &lt; iterationCount; i++) {\n        accum += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * amplitude;\n        amplitude *= 0.51;\n        warped.xy = rotation * warped.xy;\n        warped *= 1.75;\n    }\n\n    return height_calculation;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#water-rendering","title":"Water Rendering","text":"<p>The <code>ApplyWaterEffectIntegrated()</code> method renders water with:</p> <ul> <li>Surface normal calculation using finite differences</li> <li>Fresnel reflection effects</li> <li>Specular highlights</li> <li>Color blending between deep/shallow water</li> <li>Foam effects based on wave strength</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#desert-effect-system","title":"Desert Effect System","text":""},{"location":"engines/godot/gdShaderInclude/#desert-ray-marching","title":"Desert Ray Marching","text":"<p>The <code>traceDesert()</code> method handles desert terrain:</p> <pre><code>vec2 traceDesert(vec3 rayOrigin, vec3 rayDir) {\n    vec2 hit = vec2(0.1);\n\n    for (int i = 0; i &lt; 128; i++) {\n        vec2 d = getDesert(rayOrigin + rayDir * hit.x);\n        if (d.x &lt; 0.0001 || hit.x &gt; 43.0) break;\n        hit.x += d.x;\n        hit.y = d.y;\n    }\n\n    return hit;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#desert-height-calculation","title":"Desert Height Calculation","text":"<p>The <code>surfFunc()</code> method creates layered desert terrain:</p> <pre><code>float surfFunc(in vec3 p) {\n    p /= 2.5;\n    float layer1 = n2D(p.xz * layer1Freq) * layer1Amp - 0.5;\n    float layer2 = n2D(p.xz * later2Freq) * later2Amp;\n    float layer3 = n2D(p.xz * layer3Freq) * layer3Amp;\n\n    return layer1 * 0.7 + layer2 * 0.25 + layer3 * 0.05;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#desert-rendering","title":"Desert Rendering","text":"<p>Desert surfaces are rendered using:</p> <ul> <li><code>getDesertNormal()</code>: Normal calculation with bump mapping</li> <li><code>getDesertColor()</code>: Color mixing based on ripple patterns</li> <li><code>applyDesertPhongLighting_float()</code>: Phong lighting with subsurface scattering</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#rendering-output","title":"Rendering Output","text":""},{"location":"engines/godot/gdShaderInclude/#scene-composition","title":"Scene Composition","text":"<p>The method determines the closest surface by comparing distances:</p> <pre><code>float closestT = 1000.0;\nint closestSurface = 0; // 0 = background, 1 = sdf, 2 = water, 3 = desert\n\nif (sdfHitSuccess &amp;&amp; t &lt; closestT) {\n    closestT = t;\n    closestSurface = 1;\n}\n\nif (waterHitSuccess &amp;&amp; waterT &lt; closestT) {\n    closestT = waterT;\n    closestSurface = 2;\n}\n\nif (desertHitSuccess &amp;&amp; desertT &lt; closestT) {\n    closestT = desertT;\n    closestSurface = 3;\n}\n</code></pre>"},{"location":"engines/godot/gdShaderInclude/#final-rendering","title":"Final Rendering","text":"<p>Based on the closest surface:</p> <ul> <li>SDF Objects: Rendered using <code>applyPhongLighting_float()</code> with material properties</li> <li>Water: Rendered with <code>ApplyWaterEffectIntegrated()</code> for realistic water effects</li> <li>Desert: Rendered with desert-specific lighting and texturing</li> <li>Background: Fallback to background color or secondary terrain</li> </ul>"},{"location":"engines/godot/gdShaderInclude/#usage-examples","title":"Usage Examples","text":""},{"location":"engines/godot/gdShaderInclude/#basic-integration","title":"Basic Integration","text":"<p><pre><code>// In your fragment shader\nvoid fragment() {\n    vec4 finalColor;\n    IntegrationFlexible(UV, finalColor);  // Complete 3D scene rendering in one method call\n    ALBEDO = finalColor.rgb;\n}\n</code></pre> The <code>IntegrationFlexible</code> method computes the final color value for each screen-space fragment by performing ray marching calculations. The resulting RGBA color data is then assigned to the fragment's albedo channel, effectively rendering the 3D scene onto the 2D surface.</p>"},{"location":"engines/godot/gdShaderInclude/#technical-notes","title":"Technical Notes","text":"<ul> <li>All methods called within <code>IntegrationFlexible</code> are self-contained within the same <code>.gdshaderinc</code> file</li> <li>The system supports up to 100 ray marching iterations for SDF objects</li> <li>Water and desert use up to 128 iterations for higher precision</li> <li>Maximum ray distance is 50.0 units for SDF objects, 43.0 for terrains</li> <li>Hit threshold is 0.001 for SDF objects, 0.0001 for terrains</li> </ul> <p>This comprehensive system provides a flexible, high-performance solution for rendering complex 3D scenes with mixed geometry types in Godot shaders.</p>"},{"location":"engines/godot/globalVariables/","title":"Global Variables","text":"Global Variables in Godot Shaders by Jeewan"},{"location":"engines/godot/globalVariables/#overview","title":"Overview","text":"<p>In Godot, global variables in shader files (<code>global_variables.gdshaderinc</code>) are used to define constants and uniforms that are shared across multiple shader functions or files. These variables provide a centralized way to manage configuration data, such as object properties, camera settings, and rendering parameters, ensuring consistency and modularity in shader code.</p>"},{"location":"engines/godot/globalVariables/#constants","title":"Constants","text":"<p>Defined with <code>const</code>, these are immutable values (e.g., <code>MAX_OBJECTS</code>, <code>TYPE_SPHERE</code>) used to set limits or define fixed settings like object types or camera modes. They are compiled into the shader and cannot be changed at runtime.</p>"},{"location":"engines/godot/globalVariables/#uniforms","title":"Uniforms","text":"<p>Defined with <code>uniform</code>, these are variables set externally by the Godot engine or scripts (e.g., <code>lightPosition</code>, <code>obj_position</code>). They allow dynamic configuration of the shader, such as updating object positions or camera parameters per frame.</p>"},{"location":"engines/godot/globalVariables/#usage-in-godot","title":"Usage in Godot","text":"<p>The <code>global_variables.gdshaderinc</code> file is included in other shader files (e.g., <code>helper_function.gdshaderinc</code>) using <code>#include</code>, making its variables accessible throughout the shader pipeline. Uniforms are typically set via a ShaderMaterial in Godot's scene tree, while constants are fixed at compile time. This setup supports flexible rendering, such as ray marching, by providing data for objects, lighting, and camera control.</p> <p>These variables are critical for the IntegrationFlexible method, enabling it to render SDF objects, water, and desert terrains with dynamic camera animations and lighting effects.</p> <pre><code>const int MAX_OBJECTS = 25;\n\nuniform vec3 lightPosition;\n\nuniform vec3 specularColorFloat[MAX_OBJECTS];\nuniform float specularStrengthFloat[MAX_OBJECTS];\nuniform float shininessFloat[MAX_OBJECTS];\n\nuniform vec2 screen_resolution;\nuniform int inputCount;\nuniform int obj_noise[MAX_OBJECTS];\nuniform int is_animated[MAX_OBJECTS];\n\nuniform int camera_mode1;\nuniform int camera_mode2;\nuniform int terrain_mode;\nuniform int color_mode;\nuniform int animation_mode;\n\nconst float F_NO_OF_SEGMENTS=11.0;\nconst int NO_OF_SEGMENTS=11;\n\nconst int TYPE_SPHERE = 0;\nconst int TYPE_ROUNDED_BOX = 1;\nconst int TYPE_TORUS = 2;\nconst int TYPE_DOLPHIN = 3;\nconst int TYPE_HEX_PRISM=4;\nconst int TYPE_OCTAHEDRON=5;\nconst int TYPE_ELLIPSOID=6;\n\nuniform int obj_type[MAX_OBJECTS];\nuniform vec3 obj_position[MAX_OBJECTS];\nuniform vec3 obj_size[MAX_OBJECTS];\nuniform float obj_radius[MAX_OBJECTS];\nuniform vec3 obj_color[MAX_OBJECTS];\n\nuniform float obj_speed[MAX_OBJECTS];\nuniform vec3 obj_direction[MAX_OBJECTS];\nuniform float obj_time_offset[MAX_OBJECTS];\nuniform float Tme;\n\nuniform vec3 camera_position;\nuniform vec3 look_at_position;\nuniform vec4 _mousePoint;\nuniform vec4 _ScreenParams;\n\nuniform sampler2D MainTex;\nuniform vec2 _Resolution;\nuniform vec2 iResolution;\nuniform vec2 _Mouse;\n\nconst int MOUSE_CONTROL = 0;\nconst int AUTO_ORBIT = 1;\nconst int STATIC_CAMERA = 2;\nconst int BACKANDFORTH=3;\nconst int SHAKE=4;\n\nuniform float movement_speed;\nuniform float shake_intensity;\nuniform float shake_speed;\nuniform vec3 orbit_axis;\nuniform float orbit_speed;\nuniform float cycle_speed;\nuniform float wave_speed;\n\nconst int NONE = 0;\nconst int WATER = 1;\nconst int DESERT = 2;\n\nconst int STATIC=0;\nconst int CYCLE_COLOR=1;\nconst int WAVE_COLOR=2;\n\nconst int NO_ANIMATION=0;\nconst int PULSE_ANIMATION=1;\n</code></pre>"},{"location":"engines/godot/globalVariables/#explanation-of-usage","title":"Explanation of Usage","text":""},{"location":"engines/godot/globalVariables/#object-management","title":"Object Management","text":"<ul> <li><code>MAX_OBJECTS</code>, <code>obj_type</code>, <code>obj_position</code>, <code>obj_size</code>, <code>obj_radius</code>, <code>obj_color</code>, <code>obj_speed</code>, <code>obj_direction</code>, <code>obj_time_offset</code>, and <code>is_animated</code> define properties for up to 25 SDF objects (e.g., spheres, dolphins)</li> <li>These are used in <code>evaluateScene</code> and <code>evalSDF</code> to compute distances and render objects</li> </ul>"},{"location":"engines/godot/globalVariables/#lighting","title":"Lighting","text":"<ul> <li><code>lightPosition</code>, <code>specularColorFloat</code>, <code>specularStrengthFloat</code>, and <code>shininessFloat</code> provide parameters for Phong lighting</li> <li>Used in <code>lightingContext</code> and <code>applyPhongLighting_float</code></li> </ul>"},{"location":"engines/godot/globalVariables/#camera-control","title":"Camera Control","text":"<ul> <li><code>camera_position</code>, <code>look_at_position</code>, <code>_mousePoint</code>, <code>_ScreenParams</code>, <code>camera_mode1</code>, <code>camera_mode2</code>, <code>movement_speed</code>, <code>shake_intensity</code>, <code>shake_speed</code>, <code>orbit_axis</code>, and <code>orbit_speed</code> configure camera behavior</li> <li>Used in <code>getCameraMatrix_float</code> and animation functions like <code>move_via_mouse_float</code></li> </ul>"},{"location":"engines/godot/globalVariables/#terrain-and-effects","title":"Terrain and Effects","text":"<ul> <li><code>terrain_mode</code>, <code>color_mode</code>, <code>cycle_speed</code>, <code>wave_speed</code>, and terrain constants (<code>WATER</code>, <code>DESERT</code>) control water and desert rendering</li> <li>Used in <code>traceWater</code> and <code>traceDesert</code></li> </ul>"},{"location":"engines/godot/globalVariables/#general-rendering","title":"General Rendering","text":"<ul> <li><code>screen_resolution</code>, <code>_Resolution</code>, <code>iResolution</code>, and <code>MainTex</code> support UV transformations and texture sampling</li> <li><code>Tme</code> drives time-based animations</li> </ul>"},{"location":"engines/godot/globalVariables/#constants_1","title":"Constants","text":"<ul> <li><code>TYPE_*</code>, <code>MOUSE_CONTROL</code>, <code>STATIC</code>, etc., define enumerated values for object types, camera modes, and animation modes</li> <li>Ensure consistent logic across functions</li> </ul>"},{"location":"engines/godot/globalVariables/#integration","title":"Integration","text":"<p>These variables are set via Godot's ShaderMaterial properties or scripts, enabling dynamic updates (e.g., object positions, time) while constants ensure fixed configurations (e.g., maximum object count). They integrate seamlessly with the IntegrationFlexible method to render a complex, animated 3D scene using ray marching.</p>"},{"location":"engines/godot/helperFunction/","title":"Helper Functions","text":"Helper Functions Analysis for Ray Marching and Scene Integration by Jeewan <p>This document provides a detailed analysis of the helper functions defined in the <code>helper_function.gdshaderinc</code>  file, which are crucial for supporting the IntegrationFlexible method in a Godot shader. These functions handle  tasks such as camera setup, animation, lighting, UV coordinate transformation, and object color/effect modifications.</p> <p>The helper functions are included from  <code>addons/includes/helper_functions/helper_function.gdshaderinc</code>  and rely on global variables defined in  <code>addons/includes/global_variables/global_variables.gdshaderinc</code>.</p> <p>Each function is explained with its purpose, inputs/outputs, process, and code implementation, covering the role of each function in the ray marching and scene rendering pipeline.</p>"},{"location":"engines/godot/helperFunction/#lighting-functions","title":"Lighting Functions","text":""},{"location":"engines/godot/helperFunction/#1-lightingcontext","title":"1. lightingContext","text":"<p>Purpose: Computes standard lighting context for hit points in the scene, providing vectors and colors for Phong lighting calculations.</p> <p>Input/Output:</p> <ul> <li>Input: <code>hitPos</code> (vec3), <code>cameraPos</code> (vec3)</li> <li>Output: <code>viewDir</code>, <code>lightDir</code>, <code>lightColor</code>, <code>ambientColor</code></li> </ul> <p>Process: Calculates view and light directions, sets white light color and dim ambient lighting (0.1).</p> <pre><code>void lightingContext(vec3 hitPos, vec3 cameraPos, out vec3 viewDir, out vec3 lightDir, out vec3 lightColor, out vec3 ambientColor) {\n    viewDir = normalize(cameraPos - hitPos); // Use the actual camera position\n    lightDir = normalize(lightPosition - hitPos);\n    lightColor = vec3(1.0, 1.0, 1.0);\n    ambientColor = vec3(0.1, 0.1, 0.1);\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#2-desertlightingcontext","title":"2. desertLightingContext","text":"<p>Purpose: Specialized lighting context for desert surfaces with warm, natural appearance.</p> <p>Input/Output:</p> <ul> <li>Input: <code>hitPos</code> (vec3), <code>cameraPos</code> (vec3)</li> <li>Output: <code>viewDir</code>, <code>lightDir</code>, <code>lightColor</code>, <code>ambientColor</code></li> </ul> <p>Process: Similar to lightingContext but with warm light tint and blue-sky ambient for desert environments.</p> <pre><code>void desertLightingContext(vec3 hitPos, vec3 cameraPos, out vec3 viewDir, out vec3 lightDir, out vec3 lightColor, out vec3 ambientColor) {\n    viewDir = normalize(cameraPos - hitPos);\n    lightDir = normalize(lightPosition - hitPos);\n    lightColor = vec3(1.1, 1.05, 0.95);\n    ambientColor = vec3(0.6, 0.7, 0.8);\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#camera-and-coordinate-functions","title":"Camera and Coordinate Functions","text":""},{"location":"engines/godot/helperFunction/#3-computeuv_float","title":"3. computeUV_float","text":"<p>Purpose: Converts Godot's normalized UV coordinates to screen-space coordinates for ray marching with aspect ratio correction and Y-axis flipping.</p> <p>Input/Output:</p> <ul> <li>Input: <code>INuv</code> (vec2) - normalized UV coordinates</li> <li>Output: <code>uv</code> (vec2) - transformed NDC coordinates</li> </ul> <p>Process: Converts to pixel coordinates, normalizes to [-1,1], flips Y-axis, applies aspect ratio correction.</p> <pre><code>void computeUV_float(vec2 INuv, out vec2 uv) {\n    vec2 fragCoord = INuv * screen_resolution;\n    uv = fragCoord / screen_resolution.xy * 2. - 1.;\n    uv.y = -uv.y; // Flip Y axis\n    uv.x *= screen_resolution.x / screen_resolution.y;\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#4-compute_rotation_matrix","title":"4. compute_rotation_matrix","text":"<p>Purpose: Creates 3x3 rotation matrix using Rodrigues' rotation formula for object/camera rotation around specified axis.</p> <p>Input/Output:</p> <ul> <li>Input: <code>axis</code> (vec3), <code>angle</code> (float)</li> <li>Output: Returns mat3 rotation matrix</li> </ul> <p>Process: Uses trigonometric values and axis components to build column-major rotation matrix.</p> <pre><code>mat3 compute_rotation_matrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float one_minus_c = 1.0 - c;\n\n    vec3 col0 = vec3(\n        c + axis.x * axis.x * one_minus_c,\n        axis.y * axis.x * one_minus_c + axis.z * s,\n        axis.z * axis.x * one_minus_c - axis.y * s\n    );\n\n    vec3 col1 = vec3(\n        axis.x * axis.y * one_minus_c - axis.z * s,\n        c + axis.y * axis.y * one_minus_c,\n        axis.z * axis.y * one_minus_c + axis.x * s\n    );\n\n    vec3 col2 = vec3(\n        axis.x * axis.z * one_minus_c + axis.y * s,\n        axis.y * axis.z * one_minus_c - axis.x * s,\n        c + axis.z * axis.z * one_minus_c\n    );\n\n    return mat3(col0, col1, col2); // Column-major\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#5-compute_camera_basis","title":"5. compute_camera_basis","text":"<p>Purpose: Computes camera orientation matrix (right, up, -forward) given camera position and target.</p> <p>Input/Output:</p> <ul> <li>Input: <code>look_at_pos</code> (vec3), <code>eye</code> (vec3), <code>mat</code> (mat3)</li> <li>Output: Returns mat3 camera orientation matrix</li> </ul> <p>Process: Calculates forward, right, and up vectors using cross products to create orthonormal basis.</p> <p><pre><code>mat3 compute_camera_basis(vec3 look_at_pos, vec3 eye, mat3 mat) {\n    vec3 f = normalize(look_at_pos - eye);            // Forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // Right\n    vec3 u = cross(r, f);                              // Up\n    return mat3(r, u, -f); // Column-major matrix for camera orientation\n}\n</code></pre> Note: It is being used inside get_camera_matrix() to update camera related transformations.</p>"},{"location":"engines/godot/helperFunction/#6-getcameramatrix_float","title":"6. getCameraMatrix_float","text":"<p>Purpose: Combines animation matrices and computes final camera orientation and position for ray marching.</p> <p>Input/Output:</p> <ul> <li>Input: <code>matrix1</code> (mat3), <code>matrix2</code> (mat3), <code>distance</code> (float), <code>lookAtPos</code> (vec3)</li> <li>Output: <code>camMatrix</code> (mat3), <code>rayOrigin</code> (vec3)</li> </ul> <p>Process: Multiplies matrices, positions camera at distance, computes orientation using camera basis.</p> <p><pre><code>void getCameraMatrix_float(mat3 matrix1, mat3 matrix2, float distance, vec3 lookAtPos, out mat3 camMatrix, out vec3 rayOrigin) {\n    mat3 combinedMat = matrix1 * matrix2;\n    rayOrigin = (vec3(0.0, 0.0, distance) * combinedMat);\n    camMatrix = compute_camera_basis(lookAtPos, rayOrigin, combinedMat);\n}\n</code></pre> Note: This function need to be always called after each camera related animation.</p>"},{"location":"engines/godot/helperFunction/#camera-animation-functions","title":"Camera Animation Functions","text":""},{"location":"engines/godot/helperFunction/#7-move_via_mouse_float","title":"7. move_via_mouse_float","text":"<p>Purpose: Mouse-controlled camera rotation for interactive scene exploration.</p> <p>Input/Output:</p> <ul> <li>Input: None (uses global mouse and screen parameters)</li> <li>Output: <code>mat</code> (mat3) - rotation matrix</li> </ul> <p>Process: Maps mouse coordinates to yaw/pitch angles, combines Y and X rotations.</p> <pre><code>void move_via_mouse_float(out mat3 mat) {\n    vec2 mouse = _mousePoint.xy / _ScreenParams.xy;\n\n    float angle_y = mix(-PI, PI, mouse.x);\n    float angle_x = -PI * mouse.y;\n\n    mat3 rot_y = compute_rotation_matrix(vec3(0.0, 1.0, 0.0), angle_y);\n    mat3 rot_x = compute_rotation_matrix(vec3(1.0, 0.0, 0.0), angle_x);\n\n    mat = rot_y * rot_x;\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#8-orbity_float","title":"8. orbitY_float","text":"<p>Purpose: Automatic camera orbiting around specified axis at given speed.</p> <p>Input/Output:</p> <ul> <li>Input: <code>axis</code> (vec3), <code>speed</code> (float)</li> <li>Output: <code>mat</code> (mat3) - rotation matrix</li> </ul> <p>Process: Uses time and speed to create continuous rotation around normalized axis.</p> <pre><code>void orbitY_float(vec3 axis, float speed, out mat3 mat) {\n    float angle = Tme * speed;\n    mat = compute_rotation_matrix(normalize(axis), angle);\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#9-backandforth_scale_float","title":"9. backAndForth_scale_float","text":"<p>Purpose: Oscillating scale effect for zoom animation, creating back-and-forth zooming.</p> <p>Input/Output:</p> <ul> <li>Input: <code>speed</code> (float)</li> <li>Output: <code>animationMatrix</code> (mat3) - scaling matrix</li> </ul> <p>Process: Uses sine function to scale between 0.5 and 2.0, creating pulsing effect.</p> <pre><code>void backAndForth_scale_float(float speed, out mat3 animationMatrix) {\n    float t = Tme * speed;\n    float scale = abs(sin(t)) * 1.5 + 0.5; // Scale between 0.5 and 2.0\n    animationMatrix = mat3(\n        vec3(scale, 0.0, 0.0),\n        vec3(0.0, scale, 0.0),\n        vec3(0.0, 0.0, scale)\n    );\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#10-backandforth_translate_float","title":"10. backAndForth_translate_float","text":"<p>Purpose: Oscillating translation along Z-axis for back-and-forth movement.</p> <p>Input/Output:</p> <ul> <li>Input: <code>speed</code> (float)</li> <li>Output: <code>offset</code> (vec3) - translation vector</li> </ul> <p>Process: Creates \u00b13 unit oscillation along Z-axis using sine function.</p> <pre><code>void backAndForth_translate_float(float speed, out vec3 offset) {\n    float t = Tme * speed;\n    offset = vec3(0.0, 0.0, sin(t) * 3.0); // Move \u00b13 units along Z\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#11-shake_matrix_float","title":"11. shake_matrix_float","text":"<p>Purpose: Camera shake effect with random position offsets, simulating jittery motion.</p> <p>Input/Output:</p> <ul> <li>Input: <code>intensity</code> (float), <code>speed</code> (float)</li> <li>Output: <code>shakeMatrix</code> (mat3), <code>positionOffset</code> (vec3)</li> </ul> <p>Process: Uses hash function to generate random XYZ offsets, identity matrix for no rotation.</p> <pre><code>void shake_matrix_float(float intensity, float speed, out mat3 shakeMatrix, out vec3 positionOffset) {\n    float t = Tme * speed;\n    float px = hash11(t + 1.1) - 0.5;\n    float py = hash11(t + 2.3) - 0.5;\n    float pz = hash11(t + 3.7) - 0.5;\n    shakeMatrix = mat3(1.0); // Identity matrix\n    positionOffset = vec3(px, py, pz) * intensity;\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#12-hash11","title":"12. hash11","text":"<p>Purpose: Pseudo-random float generator for noise effects like camera shake.</p> <p>Input/Output:</p> <ul> <li>Input: <code>p</code> (float) - seed value</li> <li>Output: Returns float in [0,1] range</li> </ul> <p>Process: Uses sine-based hash with large multiplier and fractional part.</p> <pre><code>float hash11(float p) {\n    return fract(sin(p * 17.23) * 43758.5453);\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#color-and-animation-effects","title":"Color and Animation Effects","text":""},{"location":"engines/godot/helperFunction/#13-cyclecolor_float","title":"13. cycleColor_float","text":"<p>Purpose: Hue-shifting color animation, creating cycling color effects over time.</p> <p>Input/Output:</p> <ul> <li>Input: <code>speed</code> (float), <code>color</code> (vec3) - inout parameter</li> <li>Output: Modified color with cycling hue</li> </ul> <p>Process: Converts time to hue, applies HSV-to-RGB conversion, multiplies with base color.</p> <pre><code>void cycleColor_float(float speed, inout vec3 color) {\n    float t = Tme * speed;\n    float hue = fract(t);\n    vec3 hsv = vec3(hue, 1.0, 1.0);\n    vec3 rgb = clamp(abs(fract(hsv.x + vec3(0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0, 0.0, 1.0);\n    vec3 cycleRGB = hsv.z * mix(vec3(1.0), rgb, hsv.y);\n    color = color * cycleRGB;\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#14-changingcolorsin_float","title":"14. changingColorSin_float","text":"<p>Purpose: Sinusoidal color modulation, creating wave-like color change effects.</p> <p>Input/Output:</p> <ul> <li>Input: <code>speed</code> (float), <code>color</code> (vec3) - inout parameter</li> <li>Output: Modified color with wave effect</li> </ul> <p>Process: Transforms color using asin, applies time-dependent sine oscillation.</p> <pre><code>void changingColorSin_float(float speed, inout vec3 color) {\n    vec3 rootColor = asin(2.0 * color - 1.0);\n    color = 0.5 + 0.5 * sin(Tme * speed * rootColor);\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#15-pulseobject_float","title":"15. pulseObject_float","text":"<p>Purpose: Pulsing scale animation for objects, simulating breathing or throbbing effects.</p> <p>Input/Output:</p> <ul> <li>Input: <code>seedSize</code> (vec3), <code>seedRadius</code> (float), <code>freq</code> (float), <code>amp</code> (float), <code>mode</code> (int)</li> <li>Output: <code>size</code> (vec3), <code>radius</code> (float)</li> </ul> <p>Process: Applies time mode modification, uses sine function for scaling with frequency and amplitude.</p> <pre><code>void pulseObject_float(vec3 seedSize, float seedRadius, float freq, float amp, int mode, out vec3 size, out float radius) {\n    float t = applyTimeMode(Tme, mode);\n    float scale = 1.0 + sin(t * freq) * amp;\n    size = seedSize * scale;\n    radius = seedRadius * scale;\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#16-applytimemode","title":"16. applyTimeMode","text":"<p>Purpose: Modifies time values for different animation modes (linear, sine, absolute sine).</p> <p>Input/Output:</p> <ul> <li>Input: <code>t</code> (float), <code>mode</code> (int)</li> <li>Output: Returns modified time value</li> </ul> <p>Process: Mode 0: linear, Mode 1: sine oscillation, Mode 2: absolute sine (pulsing).</p> <pre><code>float applyTimeMode(float t, int mode) {\n    if (mode == 1)\n        return sin(t);\n    else if (mode == 2)\n        return abs(sin(t));\n    return t; // mode 0 or default - linear time\n}\n</code></pre>"},{"location":"engines/godot/helperFunction/#summary","title":"Summary","text":"<p>These helper functions provide comprehensive support for ray marching pipelines, enabling flexible camera animations, lighting calculations, UV transformations, and dynamic object effects. Each function is designed to be modular and reusable, contributing to the shader's ability to render complex, animated scenes with ray marching. From computing camera matrices to animating colors and objects, these functions form the backbone of the rendering pipeline, ensuring robust and visually appealing output.</p>"},{"location":"engines/godot/mainFragmentShader/","title":"Main Fragment Shader","text":"SMain Fragment Shader Analysis by Jeewan <p>This document provides an analysis of the main fragment shader, which serves as the entry point for rendering a 3D scene using ray marching in Godot. The shader integrates the IntegrationFlexible method from <code>sdf_updated.gdshaderinc</code> to compute the final color for each pixel. Below, we describe the shader's purpose, structure, and usage of global variables, focusing on its role in the rendering pipeline.</p>"},{"location":"engines/godot/mainFragmentShader/#overview-of-the-fragment-shader","title":"Overview of the Fragment Shader","text":"<p>In Godot, a fragment shader (defined with <code>shader_type canvas_item</code> for 2D rendering) processes each pixel of a 2D canvas item (<code>shader_type spatial</code> for 3D rendering of 3D canvas) to determine its final color. This shader is responsible for calling the IntegrationFlexible method, which performs ray marching to render a 3D scene with signed distance field (SDF) objects, water, and desert terrains. The shader leverages global variables and helper functions from included files to manage scene data and rendering parameters.</p> <ul> <li>Purpose: To render a 3D scene by computing the color of each pixel based on UV coordinates, using ray marching and terrain integration.</li> <li>Usage in Godot: Applied via a ShaderMaterial to a canvas item (e.g., a ColorRect or Sprite2D) in the Godot scene tree. The shader receives UV coordinates (UV) and uses global variables (e.g., <code>lightPosition</code>, <code>camera_position</code>) to configure the scene.</li> <li>Dependencies: Includes <code>sdf_updated.gdshaderinc</code>, which contains the <code>IntegrationFlexible</code> method, and indirectly relies on <code>global_variables.gdshaderinc</code> and <code>helper_function.gdshaderinc</code> for shared variables and functions.</li> </ul>"},{"location":"engines/godot/mainFragmentShader/#shader-code","title":"Shader Code","text":"<pre><code>shader_type canvas_item;\n\n#include \"res://addons/includes/sdf_updated.gdshaderinc\"\n\nvoid fragment() {\n    vec4 color;\n    IntegrationFlexible(UV, color);\n    COLOR = color;\n}\n</code></pre>"},{"location":"engines/godot/mainFragmentShader/#detailed-analysis","title":"Detailed Analysis","text":""},{"location":"engines/godot/mainFragmentShader/#shader-type","title":"Shader Type","text":"<p>Canvas Item: The <code>shader_type canvas_item</code> directive indicates this is a 2D shader in Godot, operating on a canvas item's texture coordinates. It processes each pixel in screen space, receiving UV coordinates (0.0 to 1.0) from the engine.</p>"},{"location":"engines/godot/mainFragmentShader/#fragment-function","title":"Fragment Function","text":"<p>The <code>fragment()</code> function is the main entry point, executed for each pixel of the canvas item.</p>"},{"location":"engines/godot/mainFragmentShader/#purpose","title":"Purpose","text":"<p>Computes the final color (<code>COLOR</code>) for each pixel by calling <code>IntegrationFlexible</code>, which handles ray marching, terrain rendering, and lighting.</p>"},{"location":"engines/godot/mainFragmentShader/#inputoutput","title":"Input/Output","text":"<p>Input: - <code>UV</code> (vec2): Built-in Godot variable providing normalized texture coordinates (0.0 to 1.0) for the current pixel.</p> <p>Output: - <code>COLOR</code> (vec4): Built-in Godot variable set to the final RGBA color of the pixel. - <code>color</code> (vec4): Local variable to store the output of IntegrationFlexible.</p>"},{"location":"engines/godot/mainFragmentShader/#process","title":"Process","text":"<ol> <li>Declares a <code>vec4 color</code> variable to hold the computed color.</li> <li>Calls <code>IntegrationFlexible(UV, color)</code> to perform ray marching and scene rendering:</li> <li><code>IntegrationFlexible</code> transforms UV into a ray direction, marches through the scene to detect hits with SDF objects, water, or desert terrains, and applies lighting (e.g., Phong for objects, custom effects for water).</li> <li>It uses global variables (e.g., <code>camera_position</code>, <code>lightPosition</code>, <code>obj_type</code>) from <code>global_variables.gdshaderinc</code> to configure the scene.</li> <li>Assigns the resulting color to <code>COLOR</code>, which Godot uses to render the pixel.</li> </ol>"},{"location":"engines/godot/shaderFlow/","title":"Shader Flow Pipeline","text":"\ud83e\udde0 Shader Flow in Godot: A Setup Guide for SDF-Based Rendering by Jeewan Dhamala &amp; Mona Elbatran <p>\ud83d\ude80 Objective: Procedural Scene Generation with Signed Distance Functions</p> <p>This guide provides a structured approach to building interactive raymarching-based scenes using Signed Distance Functions (SDFs) in the Godot Engine.</p> <p>Outcome: A fully interactive procedural scene utilizing custom fragment shaders, lighting, and camera controls.</p> <p>\ud83c\udfae Quick Start: Running the Existing Scene</p> <p>If we've cloned the project and want to see the final result immediately:</p> <pre><code>1. Open the Project in Godot\n    - Launch Godot Engine\n    - Select \"Import\" and navigate to the cloned project folder\n    - Open the project\n\n2. Run the Main Scene\n    - Select the main scene (sdf_updated.tscn)\n    - click the \"Play\" button\n\n3. Explore the Interactive Features\n    - In the inspector, experiment with real-time parameter adjustments\n    - Observe the SDF-based procedural rendering in action\n</code></pre> <p>The cloned project contains a complete, functional SDF rendering setup that we can immediately run and explore.</p>"},{"location":"engines/godot/shaderFlow/#step-1-scene-initialization-and-shader-integration","title":"\ud83d\udccb Step 1: Scene Initialization and Shader Integration","text":"<p>\ud83c\udfaf Goal: Establish Core Scene Hierarchy and Link Shader Resources</p> <p>Procedure:</p> <ol> <li> <p>Create a <code>Node2D</code> Root Node    Begin by adding a <code>Node2D</code> to serve as the base of our scene hierarchy.</p> </li> <li> <p>Attach the Script <code>sdf_updated.gd</code> to <code>Node2D</code>    This script facilitates real-time updates and management of SDF objects.</p> <ul> <li>\ud83d\udcc1 Script Path: <code>res://addons/scripts/sdf_updated.gd</code> </li> </ul> </li> <li> <p>Add a  <code>ColorRect</code> Node as a Child of <code>Node2D</code>    This node will be the visual canvas onto which the shader will render.</p> <p> </p> <p>And after adding the child node, go to the Node2D and under the <code>Shader Material Target</code>, select the <code>ColorRect</code> node.  </p> </li> <li> <p>Prepare the ShaderMaterial Resource </p> <ul> <li>Create a new <code>ShaderMaterial</code> under root directory.  </li> <li>Assign the fragment shader file:     \ud83d\udcc1 Shader Path: <code>res/sdf_updated.gdshader</code> </li> </ul> </li> <li> <p>Assign the ShaderMaterial to the <code>ColorRect</code> Node    This links the shader logic with the visible rendering surface.</p> <p> </p> </li> <li> <p>Save and Execute the Scene    Run the project to verify that the initial shader output is displayed.</p> </li> </ol>"},{"location":"engines/godot/shaderFlow/#step-2-incorporating-sdf-based-primitives","title":"\ud83c\udfa8 Step 2: Incorporating SDF-Based Primitives","text":"<p>\u2728 Supported SDF Primitives</p> <p>The system currently supports seven distinct SDF shapes:</p> <ul> <li>Sphere</li> <li>Cube</li> <li>Torus</li> <li>Dolphin (Animated)</li> <li>Hexagonal Prism</li> <li>Octahedron</li> <li>Ellipsoid</li> </ul>"},{"location":"engines/godot/shaderFlow/#configurable-parameters","title":"\ud83d\udd27 Configurable Parameters","text":"<p>Each SDF object accepts the following customizable parameters:</p> Parameter Type Description / Options <code>Type</code> <code>int</code> <code>0</code>=Sphere, <code>1</code>=Cube, <code>2</code>=Torus, <code>3</code>=Dolphin, <code>4</code>=HexPrism, <code>5</code>=Octahedron, <code>6</code>=Ellipsoid <code>Position</code> <code>Vector3</code> World-space coordinates <code>Size</code> <code>Vector3</code> Scale factors for each axis <code>Radius</code> <code>float</code> Defines object roundness <code>Color</code> <code>Vector3</code> RGB vector for base color <code>Noise Type</code> <code>int</code> <code>0</code>=None, <code>1</code>=Pseudo3D, <code>2</code>=FBM, <code>3</code>=N31 <code>Specular Color</code> <code>Vector3</code> Color for light reflections <code>Specular Strength</code> <code>float</code> Intensity of specular highlights <code>Shininess</code> <code>float</code> Surface reflectiveness <p>\ud83d\udc2c Special Case: Animated Dolphin</p> <p>The Dolphin primitive supports additional animation parameters:</p> <ul> <li><code>Noise</code>: None</li> <li><code>Speed</code>: Controls swimming velocity</li> <li><code>Direction</code>: A <code>Vector3</code> indicating motion vector</li> <li><code>Time Offset</code>: Adjusts animation phase for individual dolphins</li> </ul>"},{"location":"engines/godot/shaderFlow/#script-integration-example","title":"\ud83d\udcbe Script Integration Example","text":"<p>Within the <code>_ready()</code> function of <code>sdf_updated.gd</code>, populate the scene by instantiating and configuring <code>ShaderObject</code> instances:</p> <pre><code>func _ready():\n    shader_objects = [\n        # Sphere\n        ShaderObject.new().set_values(0, Vector3(0, 0.0, 0), Vector3.ZERO, 1.0, Vector3(0.2, 0.2, 1.0), 0),\n\n        # Cubes\n        ShaderObject.new().set_values(1, Vector3(1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2), 0),\n        ShaderObject.new().set_values(1, Vector3(-1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2), 0),\n\n        # Torus\n        ShaderObject.new().set_values(2, Vector3(-2.0, 0.0, 0), Vector3(1.0, 5.0, 1.5), 0.2, Vector3(1.0, 0.2, 0.2), 2),\n        ShaderObject.new().set_values(2, Vector3(2.0, 0.0, 0), Vector3(1.0, 5.0, 1.5), 0.2, Vector3(1.0, 0.2, 0.2), 2),\n\n        # Dolphin (commented out by default)\n        # ShaderObject.new().set_values(3, Vector3(0, -2.0, 0), Vector3(5.0, 5.0, 5.0), 3.0, Vector3(0.5, 0.7, 1.0), 0, Vector3.ONE, 0.8, 16.0, 2.0, Vector3(1, 0, 0.2), 0.0),\n\n        # HexPrism\n        ShaderObject.new().set_values(4, Vector3(0.0, 0.0, 0.0), Vector3(1, 1, 1), 0.3, Vector3(0.2, 1.0, 0.2), 0),\n\n        # Octahedron\n        ShaderObject.new().set_values(5, Vector3(1.9, 0.0, 0.0), Vector3(1, 1, 1), 1.0, Vector3(0.2, 1.0, 0.2), 0),\n\n        # Ellipsoid\n        ShaderObject.new().set_values(6, Vector3(-1.9, 0.0, 0.0), Vector3(1, 1, 1), 0.3, Vector3(0.2, 1.0, 0.2), 0),\n    ]\n</code></pre>"},{"location":"engines/godot/shaderFlow/#step-3-lighting-environment","title":"\ud83d\udca1 Step 3: Lighting &amp; Environment","text":"<p>\ud83c\udfaf Goal: Enhance Visual Fidelity Using Environmental Contexts</p> <p>In this step, we will integrate dynamic lighting and background environments to enrich the SDF-rendered scene. Lighting influences shading and reflections, while terrain presets introduce contextual depth.</p>"},{"location":"engines/godot/shaderFlow/#inspector-controls","title":"Inspector Controls","text":""},{"location":"engines/godot/shaderFlow/#lighting","title":"\ud83c\udf1e Lighting","text":"<ul> <li>Light Position \u2013 Point light source position for Phong lighting</li> </ul>"},{"location":"engines/godot/shaderFlow/#terrain","title":"\ud83c\udf0d Terrain","text":"<ul> <li>None \u2013 No landscapes, only SDFs</li> <li>Desert \u2013 Arid landscape with warm tones  </li> <li>Water \u2013 Ocean surface with reflections</li> </ul>"},{"location":"engines/godot/shaderFlow/#step-4-camera-controls","title":"\ud83c\udfae Step 4: Camera Controls","text":"<p>\ud83c\udfaf Goal: Enable Interactive and Cinematic Viewing</p> <p>In this step, we will configure camera behaviors that allow users to interactively explore the procedural scene or enable automated motion for presentation. These controls enhance spatial understanding and visual engagement through options like orbiting, shaking, and static framing.</p> <p>Available Modes:</p> Mode Description Parameters \ud83d\uddb1\ufe0f Mouse Control Interactive camera with mouse input Click and drag to orbit \ud83c\udf00 Auto Orbit Automatic camera rotation Orbit Speed \u2013 Controls how fast the camera revolves around the target.  Orbit Axis \u2013 Determines the axis of rotation (e.g., Y-axis for horizontal orbit). \ud83d\udcf7 Static Camera Fixed camera position \u2013 \u2194\ufe0f Back-and-Forth Horizontal panning motion Movement Speed \u2013 Sets how quickly the camera moves side to side. \ud83d\udca5 Shake Subtle camera jitter for dynamic effect Shake Speed \u2013 Frequency of the shake motion.  Shake Intensity \u2013 Amplitude or strength of the shaking effect."},{"location":"engines/godot/shaderFlow/#step-5-color-animation-modes","title":"\ud83c\udfa8 Step 5: Color Animation Modes","text":"<p>\ud83c\udfaf Goal: Add Dynamic Color Behavior to Visual Elements</p> <p>In this step, we introduce animated color modes that enhance the visual expressiveness of objects. These modes simulate static coloring, cyclic transitions, or wave-like color movement across the surface.</p> <p>Available Modes:</p> Mode Description Parameters \ud83c\udfa8 Static Applies a constant, unchanging color to the object \u2013 \ud83c\udf08 Cycle Color Continuously cycles through color hues over time Cycle Speed \u2013 Controls how fast the color transitions occur. \ud83c\udf0a Wave Color Propagates color changes as a wave across the object Wave Speed \u2013 Sets the rate at which the wave moves through the object."},{"location":"engines/godot/shaderFlow/#step-6-object-animation-modes","title":"\ud83d\udd04 Step 6: Object Animation Modes","text":"<p>\ud83c\udfaf Goal: Add Temporal Animation for Expressive Object Behavior</p> <p>This step introduces pulsing animations that affect the overall visual rhythm of the object. It adds a temporal, breathing-like motion useful for highlighting objects or adding ambient motion to static shapes.</p> <p>Available Modes:</p> Mode Description \ud83d\uded1 No Animation Keeps the object static with no animation applied \ud83d\udcab Pulse Animation Applies a rhythmic pulsing effect to the object by modulating its brightness or scale over time"},{"location":"engines/unity/globalVariables/","title":"Global Variables","text":"Global Variables by Frieda Hentschel <p>The global variables are an essential part of the integration in Unity. They are defined in a separate file and included in all hlsl-files that require them. They can easily distinguished by their signature underscore _variableName.</p> <p>The global variables define the maximum amount of SDFs that can be added to a single shader to be 20. Read more about this setup in the SDF General Information. </p> <p>Additionally, the hit-index for the water surface is defined to be the first available index after the SDF indices. More environments can be added by incrementing the water's index for each added environment and increasing the material array's size by the amount of added environments. Read more about the importance of the hit-indices in Lighting General Information.</p>"},{"location":"engines/unity/globalVariables/#the-code","title":"The Code","text":"<pre><code>#define MAX_OBJECTS 20\n//water index is the first value possible after the object indices\n#define WATER_INDEX 20\n\n//uniforms\nextern float2 _mousePoint;\nextern float3 _rayOrigin;\nextern float _raymarchStoppingCriterium;\n\n//sdf arrays\nint _sdfType[MAX_OBJECTS];\nfloat3 _sdfPosition[MAX_OBJECTS];\nfloat3 _sdfSize[MAX_OBJECTS];\nfloat _sdfRadius[MAX_OBJECTS];\nfloat3x3 _sdfRotation[MAX_OBJECTS];\nfloat _sdfNoise[MAX_OBJECTS];\n\n//material array --&gt; number of sdfs + 1 for water shader\nfloat3 _objectBaseColor[MAX_OBJECTS+1];\nfloat3 _objectSpecularColor[MAX_OBJECTS+1];\nfloat _objectSpecularStrength[MAX_OBJECTS+1];\nfloat _objectShininess[MAX_OBJECTS+1];\n\n//dolphin specific arrays\nfloat _timeOffsetDolphin[MAX_OBJECTS];\nfloat _speedDolphin[MAX_OBJECTS];\n</code></pre>"},{"location":"engines/unity/helperFunctions/","title":"Helper Functions","text":"Helper Functions by Frieda Hentschel <p>This sections gives an overview of the universal helper functions used across Unity's integration. Within the ShaderGraph implementation they are not exposed and solely used to implement the custom nodes. However, if the standard scripting with ShaderLab is used, they can be accessed and used for custom computations.</p>"},{"location":"engines/unity/helperFunctions/#the-code-camera-matrix","title":"The Code - Camera Matrix","text":"<pre><code>float3x3 computeCameraMatrix(float3 lookAtPosition, float3 eye, float3x3 mat)\n{\n    float3 forward = normalize(lookAtPosition - eye);\n    float3 right = normalize(cross(forward, mul(float3(0, 1, 0), mat))); \n    float3 up = cross(right, forward);\n    return float3x3(right, up, -forward); \n}\n</code></pre>"},{"location":"engines/unity/helperFunctions/#the-parameters-camera-matrix","title":"The Parameters - Camera Matrix","text":""},{"location":"engines/unity/helperFunctions/#inputs","title":"Inputs:","text":"Name Type Description <code>lookAtPosition</code> float3 Focal point of the camera <code>eye</code> float3 Position of the camera - It is generally recommended to use the global variable _rayOrigin for this computations <code>mat</code> float3x3 Transformation matrix"},{"location":"engines/unity/helperFunctions/#outputs","title":"Outputs:","text":"Type Description float3x3 Camera matrix"},{"location":"engines/unity/helperFunctions/#the-code-rotation-matrix","title":"The Code - Rotation Matrix","text":"<pre><code>float3x3 computeRotationMatrix(float3 axis, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    float minusC = 1 - c;\n\n    return float3x3(c + axis.x * axis.x * minusC, axis.x * axis.y * minusC - axis.z * s, axis.x * axis.z * minusC + axis.y * s,\n    axis.y * axis.x * minusC + axis.z * s, c + axis.y * axis.y * minusC, axis.y * axis.z * minusC - axis.x * s,\n    axis.z * axis.x * minusC - axis.y * s, axis.z * axis.y * minusC + axis.x * s, c + axis.z * axis.z * minusC);\n}\n</code></pre>"},{"location":"engines/unity/helperFunctions/#the-parameters-rotation-matrix","title":"The Parameters - Rotation Matrix","text":""},{"location":"engines/unity/helperFunctions/#inputs_1","title":"Inputs:","text":"Name Type Description <code>axis</code> float3 Axis around which to rotate <code>angle</code> float3 Angle at which to rotate"},{"location":"engines/unity/helperFunctions/#outputs_1","title":"Outputs:","text":"Type Description float3x3 Rotation matrix"},{"location":"engines/unity/helperFunctions/#access","title":"Access","text":"<p>If standard scripting is used, the helper functions can be included and used with: </p> <p><code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/helper_functions.hlsl\"</code></p>"},{"location":"engines/unity/uniformsAndCs/","title":"Uniforms and C#","text":"Uniforms and C# by Frieda Hentschel <p>Uniforms in Unity are set via a custom C# file. It is essential to add them to the shader as they are responsible for:</p> <ul> <li>Setting the ray origin/camera position: As the ray origin is defined as a Global Variable, it has to be initialised. Unity ShaderGraph does not take initialisations outside of hlsl-functions into account. Therefore, to initialise it, the ray origin is defined via a uniform. This potentially leads to shaders which do not show the desired output. See Bug: Empty Shader to learn more about this.</li> <li>Setting the global variable _raymarchStoppingCriterium for the reason mentioned above. This variable defines the stopping criterium after which the raymarching of the Water Shader or the SDF Raymarching is terminated. </li> <li>Providing the mouse position to the Mouse-Based Camera Rotation. This is necessary since Unity's hlsl support has no built-in mouse variable.</li> <li>Enabling translations through the scene using WASDQE.  </li> </ul> <p>The C# file is connected to the prefab ShaderUniformControl. Read about how to include the prefab in a scene in Overview.</p>"},{"location":"engines/unity/uniformsAndCs/#the-code","title":"The Code","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class set_shader_uniforms : MonoBehaviour\n{\n    private Vector2 lastMousePos;\n    private Vector2 accumulatedMouseDelta = new Vector2(Screen.width * 0.5f, Screen.height * 0.5f);\n    private bool isDragging = false;\n\n    [Header(\"Ray Origin Movement\")]\n    public bool allowMovement = false;\n    public float movementSpeed = 10f;\n    public Vector3 rayOrigin = new Vector3(0, 0, 10);\n\n    void Start()\n    {\n        Shader.SetGlobalVector(\"_rayOrigin\", rayOrigin);\n        Shader.SetGlobalFloat(\"_raymarchStoppingCriterium\", 50);\n\n        Shader.SetGlobalVector(\"_mousePoint\", accumulatedMouseDelta);\n        Shader.SetGlobalVector(\"_Mouse\", accumulatedMouseDelta);\n    }\n\n    void Update()\n    {\n        if (!allowMovement)\n        {\n            return;\n        }\n\n        // --- Mouse drag rotation ---\n        if (Input.GetMouseButtonDown(0))\n        {\n            lastMousePos = Input.mousePosition;\n            isDragging = true;\n        }\n        else if (Input.GetMouseButtonUp(0))\n        {\n            isDragging = false;\n        }\n\n        if (isDragging)\n        {\n            Vector2 currentMousePos = Input.mousePosition;\n            Vector2 delta = currentMousePos - lastMousePos;\n            lastMousePos = currentMousePos;\n\n            // Accumulate and normalize\n            accumulatedMouseDelta += delta;\n\n\n            Shader.SetGlobalVector(\"_mousePoint\", accumulatedMouseDelta);\n            Shader.SetGlobalVector(\"_Mouse\", accumulatedMouseDelta);\n        }\n\n        Vector3 direction = Vector3.zero;\n\n        if (Input.GetKey(KeyCode.S)) direction += Vector3.forward;\n        if (Input.GetKey(KeyCode.W)) direction += Vector3.back;\n        if (Input.GetKey(KeyCode.A)) direction += Vector3.left;\n        if (Input.GetKey(KeyCode.D)) direction += Vector3.right;\n        if (Input.GetKey(KeyCode.E)) direction += Vector3.up;\n        if (Input.GetKey(KeyCode.Q)) direction += Vector3.down;\n\n        if (direction != Vector3.zero)\n        {\n            if (Input.GetKey(KeyCode.LeftShift))\n            {\n                direction *= 2;\n            }\n            rayOrigin += direction * movementSpeed * Time.deltaTime;\n        }\n\n        Shader.SetGlobalVector(\"_rayOrigin\", rayOrigin);\n    }\n}\n</code></pre>"},{"location":"engines/unity/uniformsAndCs/#experience","title":"Experience","text":"<p>Within the inspector of the ShaderUniformControl:</p> <ul> <li>Enable Allow Movement<ul> <li>Translations via WASDQE</li> <li>W: Forward Movement</li> <li>A: Left Movement</li> <li>S: Backward Movement</li> <li>D: Right Movement</li> <li>Q: Downward Movement</li> <li>E: Upward Movement</li> </ul> </li> <li>Press Shift for speed-up.</li> <li>Alter Movement Speed to adjusted the general speed of the movement. </li> <li> <p>Adjust Ray Origin to change the camera position. Be aware that this only leads to lasting changes if neither the Allow Movement is used, nor is there a camera animation integrated within the shader.</p> <p> </p> </li> </ul>"},{"location":"engines/unity/uniformsAndCs/#bug-empty-shader","title":"Bug: Empty Shader","text":"<p>If a custom shader has been composed and compiled for the first time but the only a blank material is visible in Scene-mode, it could be due to the lack of initialisation of essential parameters using uniform variables. All nodes using _rayOrigin and _raymarchStoppingCriterium are affected. On the other hand, functions that use neither, such as the Sunrise, are typically correctly rendered. </p> <p>To resolve this issue, simply run the scene once. By running the scene, the C# file connected to the prefab in the scene will be executed and the uniform variables will be set. The uniforms will remain even after the Game-mode has been exited.</p>"},{"location":"engines/unity/animations/colorAnimation/","title":"Cycle Color","text":"Cycle Color by Frieda Hentschel <p>This function applies a color animation to an arbitrary input color. It cycles through colors based on a sinus computation.</p>"},{"location":"engines/unity/animations/colorAnimation/#the-code","title":"The Code","text":"<pre><code>void changingColorSin_float(float3 seedColor, float speed, out float3 color)\n{\n    float3 rootColor = asin(2 * seedColor - 1);\n    color = 0.5 + 0.5 * sin(_Time.y * speed * rootColor);\n}\n</code></pre> <p>The computation of the root color is required to ensure that the seed color is within the cycle of colors. It is computed by solving for x when _Time.y = 0:</p> <p><code>seedColor = 0.5 + 0.5 * sin(_Time.y * speed * x)</code></p>"},{"location":"engines/unity/animations/colorAnimation/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/animations/colorAnimation/#inputs","title":"Inputs:","text":"Name Type Description <code>seedColor</code> float3 Initial color of the object <code>speed</code> float Speed with which the color is changed  ShaderGraph default value: 1"},{"location":"engines/unity/animations/colorAnimation/#outputs","title":"Outputs:","text":"Name Type Description <code>color</code> float3 Current color of the object <p>To create organic and interesting effects, the function can also be applied to position parameters. See the tutorial on the Safety Buoy for this.</p>"},{"location":"engines/unity/animations/colorAnimation/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Animation/Cycle Color Sin</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 color_temp;\nchangingColorSin_float(float3(0.8, 0.1, 0.1), 0.5, color_temp);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis. It is inspired by this shadertoy shader.</p>"},{"location":"engines/unity/animations/generalInformation/","title":"General Information","text":"Animations in Unity by Frieda Hentschel <p>The animation functions are used to periodically alter parameters of an object. They can be applied to SDFs or Lighting Functions by connecting their output with the input of an object.</p> <p>Animations are designed to alter parameters such as: - Position - Axis - Angle - Color - Size - Radius</p>"},{"location":"engines/unity/animations/generalInformation/#how-to-combine-animations","title":"How to Combine Animations","text":"<p>Animations of the same dimension can simply be combined by connecting the functions in series.      </p>"},{"location":"engines/unity/animations/orbitObject/","title":"Orbit Object Around Point","text":"Orbit Object Around Point by Frieda Hentschel <p>This function rotates an object around a point. During the rotation, the object orients itself to face the central point of its orbit.</p>"},{"location":"engines/unity/animations/orbitObject/#the-code","title":"The Code","text":"<pre><code>void orbitObjectAroundPoint_float(float3 seedPosition, float3 center, float3 axis, float radius, float speed, float angleOffset, out float3 position, out float angle)\n{\n    axis = normalize(axis);\n    angle = _Time.y * speed + angleOffset * PI / 180;\n\n    float3 radiusAxis = (float3(1, 1, 1) - axis) * radius;\n    float3 positionTemp = seedPosition + radiusAxis - center;\n\n    position = center + cos(angle) * positionTemp + sin(angle) * cross(axis, positionTemp) + (1 - cos(angle)) * dot(axis, positionTemp) * axis;\n    //convert to degrees as input to the sdfs is in degrees\n    angle = angle * 180 / PI;\n}\n</code></pre>"},{"location":"engines/unity/animations/orbitObject/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/animations/orbitObject/#inputs","title":"Inputs:","text":"Name Type Description <code>seedPosition</code> float3 Initial position of the object <code>centre</code> float3 Central position around which the object obits <code>axis</code> float3 Axis around which the object rotates  ShaderGraph default value: float3(0,1,0) <code>radius</code> float Distance at which the object rotates around the centre point <code>speed</code> float Speed with which the rotation is applied  ShaderGraph default value: 1 <code>angleOffset</code> float =ptional offset to the rotation defined in degrees. This allows objects to use the same rotation at different starting positions. <p>By setting the radius to 0, a self-rotation of the object can be achieved.</p>"},{"location":"engines/unity/animations/orbitObject/#outputs","title":"Outputs:","text":"Name Type Description <code>position</code> float3 Current position of the object <code>angle</code> float Angle defining the self-rotation of the object <p>The outputs can directly be plugged into the inputs of SDF functions (e.g. Sphere) or lighting functions (e.g. Point Light). As lighting functions are not susceptible to changes of the angle, it only requires the position as input.</p>"},{"location":"engines/unity/animations/orbitObject/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Animation/Orbit Object Around Point</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 newPosition;\nfloat orbitAngle;\norbitObjectAroundPoint_float(float3(0, 0, 0), float3(1, 1, 1), float3(0, 1, 0), 2.0, 1.5, 45.0, newPosition, orbitAngle);\n</code></pre> <p>Find the original shader code here. Changes and simplifications where made to combine the Orbit Animation and Self-Rotate Animation. The option of different time modes was removed for simplicity reasons.</p>"},{"location":"engines/unity/animations/shakeObject/","title":"Shake Object","text":"Shake Object by Frieda Hentschel <p>This function creates a linear shaking animation on objects by changing its position.</p>"},{"location":"engines/unity/animations/shakeObject/#the-code","title":"The Code","text":"<pre><code>void shakeObject_float(float3 seedPosition, float intensity, float speed, out float3 position)\n{\n    float time = _Time.y * speed;\n\n    float x = frac(sin((time + 1.1) * 17.23) * 43758.5453) - 0.5;\n    float y = frac(sin((time + 2.3) * 17.23) * 43758.5453) - 0.5;\n    float z = frac(sin((time + 3.7) * 17.23) * 43758.5453) - 0.5;\n\n    float3 jitter = float3(x, y, z) * intensity;\n\n    position = seedPosition + jitter;\n}\n</code></pre>"},{"location":"engines/unity/animations/shakeObject/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/animations/shakeObject/#inputs","title":"Inputs:","text":"Name Type Description <code>seedPosition</code> float3 Initial position of the object <code>intensity</code> float Intensity of the shaking  ShaderGraph default value: 1 <code>speed</code> float Speed with which the position change is applied  ShaderGraph default value: 1 <p>Play around by adding Tweening to intensity and speed to create a more intricate animation.</p>"},{"location":"engines/unity/animations/shakeObject/#outputs","title":"Outputs:","text":"Name Type Description <code>position</code> float3 Current position of the object which can directly be plugged into the inputs of an SDF function (e.g. Sphere) or lighting functions (e.g. Point Light)."},{"location":"engines/unity/animations/shakeObject/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Animation/Shake Object</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 position_temp;\nshakeObject_float(float3(0, 0, 0), 0.4, 1, position_temp);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/animations/tweening/","title":"Tweening","text":"Tweening Shader Library by Utku Alkan <p>This header provides a library for easing (tweening) functions to interpolate values smoothly over time. The library supports 31 tweening types commonly used in animation curves (e.g., ease-in, ease-out, bounce, back, etc.).</p>"},{"location":"engines/unity/animations/tweening/#the-code","title":"The Code","text":"Tweening-Related Helper Functions <pre><code>float BounceEaseOut(float p)\n{\n    if (p &lt; 4.0 / 11.0)\n        return (121.0 * p * p) / 16.0;\n    else if (p &lt; 8.0 / 11.0)\n        return (363.0 / 40.0 * p * p) - (99.0 / 10.0 * p) + 17.0 / 5.0;\n    else if (p &lt; 9.0 / 10.0)\n        return (4356.0 / 361.0 * p * p) - (35442.0 / 1805.0 * p) + 16061.0 / 1805.0;\n    else\n        return (54.0 / 5.0 * p * p) - (513.0 / 25.0 * p) + 268.0 / 25.0;\n}\n\nfloat BounceEaseIn(float p)\n{\n    return 1.0 - BounceEaseOut(1.0 - p);\n}\n\nfloat BounceEaseInOut(float p)\n{\n    if (p &lt; 0.5)\n        return 0.5 * BounceEaseIn(p * 2.0);\n    else\n        return 0.5 * BounceEaseOut(p * 2.0 - 1.0) + 0.5;\n}\n\nfloat applyTweenFunction(float t, int tweenType)\n{\n    if (tweenType == TWEEN_LINEAR)\n        return t;\n    else if (tweenType == TWEEN_QUADRATIC_IN)\n        return t * t;\n    else if (tweenType == TWEEN_QUADRATIC_OUT)\n        return -(t * (t - 2.0));\n    else if (tweenType == TWEEN_QUADRATIC_INOUT)\n        return t &lt; 0.5 ? 2.0 * t * t : (-2.0 * t * t) + (4.0 * t) - 1.0;\n    else if (tweenType == TWEEN_CUBIC_IN)\n        return t * t * t;\n    else if (tweenType == TWEEN_CUBIC_OUT)\n    {\n        float f = t - 1.0;\n        return f * f * f + 1.0;\n    }\n    else if (tweenType == TWEEN_CUBIC_INOUT)\n    {\n        if (t &lt; 0.5)\n            return 4.0 * t * t * t;\n        float f = 2.0 * t - 2.0;\n        return 0.5 * f * f * f + 1.0;\n    }\n    else if (tweenType == TWEEN_QUARTIC_IN)\n        return t * t * t * t;\n    else if (tweenType == TWEEN_QUARTIC_OUT)\n    {\n        float f = t - 1.0;\n        return 1.0 - f * f * f * (1.0 - t);\n    }\n    else if (tweenType == TWEEN_QUARTIC_INOUT)\n    {\n        if (t &lt; 0.5)\n            return 8.0 * t * t * t * t;\n        float f = t - 1.0;\n        return -8.0 * f * f * f * f + 1.0;\n    }\n    else if (tweenType == TWEEN_QUINTIC_IN)\n        return t * t * t * t * t;\n    else if (tweenType == TWEEN_QUINTIC_OUT)\n    {\n        float f = t - 1.0;\n        return f * f * f * f * f + 1.0;\n    }\n    else if (tweenType == TWEEN_QUINTIC_INOUT)\n    {\n        if (t &lt; 0.5)\n            return 16.0 * t * t * t * t * t;\n        float f = 2.0 * t - 2.0;\n        return 0.5 * f * f * f * f * f + 1.0;\n    }\n    else if (tweenType == TWEEN_SINE_IN)\n        return sin((t - 1.0) * (3.14159265 * 0.5)) + 1.0;\n    else if (tweenType == TWEEN_SINE_OUT)\n        return sin(t * (3.14159265 * 0.5));\n    else if (tweenType == TWEEN_SINE_INOUT)\n        return 0.5 * (1.0 - cos(t * 3.14159265));\n    else if (tweenType == TWEEN_CIRCULAR_IN)\n        return 1.0 - sqrt(1.0 - t * t);\n    else if (tweenType == TWEEN_CIRCULAR_OUT)\n        return sqrt((2.0 - t) * t);\n    else if (tweenType == TWEEN_CIRCULAR_INOUT)\n    {\n        if (t &lt; 0.5)\n            return 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t));\n        return 0.5 * (sqrt(-((2.0 * t - 3.0) * (2.0 * t - 1.0))) + 1.0);\n    }\n    else if (tweenType == TWEEN_EXPONENTIAL_IN)\n        return (t == 0.0) ? 0.0 : pow(2.0, 10.0 * (t - 1.0));\n    else if (tweenType == TWEEN_EXPONENTIAL_OUT)\n        return (t == 1.0) ? 1.0 : 1.0 - pow(2.0, -10.0 * t);\n    else if (tweenType == TWEEN_EXPONENTIAL_INOUT)\n    {\n        if (t == 0.0 || t == 1.0)\n            return t;\n        if (t &lt; 0.5)\n            return 0.5 * pow(2.0, 20.0 * t - 10.0);\n        return -0.5 * pow(2.0, -20.0 * t + 10.0) + 1.0;\n    }\n    else if (tweenType == TWEEN_ELASTIC_IN)\n        return sin(13.0 * 3.14159265 * 0.5 * t) * pow(2.0, 10.0 * (t - 1.0));\n    else if (tweenType == TWEEN_ELASTIC_OUT)\n        return sin(-13.0 * 3.14159265 * 0.5 * (t + 1.0)) * pow(2.0, -10.0 * t) + 1.0;\n    else if (tweenType == TWEEN_ELASTIC_INOUT)\n    {\n        if (t &lt; 0.5)\n            return 0.5 * sin(13.0 * 3.14159265 * (2.0 * t) * 0.5) * pow(2.0, 10.0 * (2.0 * t - 1.0));\n        return 0.5 * (sin(-13.0 * 3.14159265 * 0.5 * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 2.0);\n    }\n    else if (tweenType == TWEEN_BACK_IN)\n        return t * t * t - t * sin(t * 3.14159265);\n    else if (tweenType == TWEEN_BACK_OUT)\n    {\n        float f = 1.0 - t;\n        return 1.0 - (f * f * f - f * sin(f * 3.14159265));\n    }\n    else if (tweenType == TWEEN_BACK_INOUT)\n    {\n        if (t &lt; 0.5)\n        {\n            float f = 2.0 * t;\n            return 0.5 * (f * f * f - f * sin(f * 3.14159265));\n        }\n        else\n        {\n            float f = 1.0 - (2.0 * t - 1.0);\n            return 0.5 * (1.0 - (f * f * f - f * sin(f * 3.14159265))) + 0.5;\n        }\n    }\n    else if (tweenType == TWEEN_BOUNCE_IN)\n        return BounceEaseIn(t);\n    else if (tweenType == TWEEN_BOUNCE_OUT)\n        return BounceEaseOut(t);\n    else if (tweenType == TWEEN_BOUNCE_INOUT)\n        return BounceEaseInOut(t);\n\n    return t; // fallback\n}\n\nfloat getTweenProgress(float startTime, float duration, bool pingpong)\n{\n    float t = (_Time.y - startTime) / duration;\n\n    if (t &lt; 0)\n        return 0;\n\n    if (pingpong == true)\n    {\n        // Double duration for full ping-pong cycle\n        float cycleTime = fmod(t, 2.0); // 0\u20132\n        return cycleTime &lt; 1.0 ? cycleTime : 2.0 - cycleTime; // Ping (0\u20131), Pong (1\u20130)\n    }\n    else\n    {\n        return frac(t); // Loops from 0 to 1\n    }\n}\n</code></pre> <pre><code>void tween3D_float(float3 start, float3 end, float duration, int tweenType, float startTime, bool pingpong, out float3 value)\n{\n    float t = getTweenProgress(startTime, duration, pingpong);\n\n    float eased = applyTweenFunction(t, tweenType);\n    value = lerp(start, end, eased);\n}\n\nvoid tween1D_float(float start, float end, float duration, int tweenType, float startTime, bool pingpong, out float value)\n{\n    float t = getTweenProgress(startTime, duration, pingpong);\n\n    float eased = applyTweenFunction(t, tweenType);\n    value = lerp(start, end, eased);\n}\n</code></pre>"},{"location":"engines/unity/animations/tweening/#parameters","title":"Parameters","text":""},{"location":"engines/unity/animations/tweening/#inputs","title":"Inputs","text":"Name Type Description <code>start</code> float3/float Starting value <code>end</code> float3/float Target value   ShaderGraph default value: float3(1,1,1)/1 <code>duration</code> float Duration of the tween in seconds  ShaderGraph default value: 5 <code>tweenType</code> enum/int Easing type (see Tween Types below) <code>startTime</code> float Time at which the tween should start (in seconds) <code>pingpong</code> bool If true, animates back and forth (0\u21921\u21920...), else loops from 0\u21921 repeatedly  ShaderGraph default value: true"},{"location":"engines/unity/animations/tweening/#output","title":"Output","text":"Name Type Description <code>value</code> float3/float Interpolated value at current time <p>The output can be used for an arbitrary input parameter. It is the most suitable for animating an SDF's parameters such as Position, Color, Scale, ...</p>"},{"location":"engines/unity/animations/tweening/#tween-types","title":"Tween Types","text":"<p>Use one of the following constants as <code>tweenType</code> in the functions above:</p> Constant Name Value <code>TWEEN_LINEAR</code> 0 <code>TWEEN_QUADRATIC_IN</code> 1 <code>TWEEN_QUADRATIC_OUT</code> 2 <code>TWEEN_QUADRATIC_INOUT</code> 3 <code>TWEEN_CUBIC_IN</code> 4 <code>TWEEN_CUBIC_OUT</code> 5 <code>TWEEN_CUBIC_INOUT</code> 6 <code>TWEEN_QUARTIC_IN</code> 7 <code>TWEEN_QUARTIC_OUT</code> 8 <code>TWEEN_QUARTIC_INOUT</code> 9 <code>TWEEN_QUINTIC_IN</code> 10 <code>TWEEN_QUINTIC_OUT</code> 11 <code>TWEEN_QUINTIC_INOUT</code> 12 <code>TWEEN_SINE_IN</code> 13 <code>TWEEN_SINE_OUT</code> 14 <code>TWEEN_SINE_INOUT</code> 15 <code>TWEEN_CIRCULAR_IN</code> 16 <code>TWEEN_CIRCULAR_OUT</code> 17 <code>TWEEN_CIRCULAR_INOUT</code> 18 <code>TWEEN_EXPONENTIAL_IN</code> 19 <code>TWEEN_EXPONENTIAL_OUT</code> 20 <code>TWEEN_EXPONENTIAL_INOUT</code> 21 <code>TWEEN_ELASTIC_IN</code> 22 <code>TWEEN_ELASTIC_OUT</code> 23 <code>TWEEN_ELASTIC_INOUT</code> 24 <code>TWEEN_BACK_IN</code> 25 <code>TWEEN_BACK_OUT</code> 26 <code>TWEEN_BACK_INOUT</code> 27 <code>TWEEN_BOUNCE_IN</code> 28 <code>TWEEN_BOUNCE_OUT</code> 29 <code>TWEEN_BOUNCE_INOUT</code> 30 <p>To check the easings of the tween types here.</p>"},{"location":"engines/unity/animations/tweening/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node for 1D Tweening at <code>PSF/Animation/1D Tweening</code></p> <p> </p> <p>Find the node for 3D Tweening at <code>PSF/Animation/3D Tweening</code></p> <p> </p> <p>The tween type can be provided by the tween value as a <code>float</code>.</p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/tween_functions.hlsl\"</code></p> <p>Example Usage</p> <p>This function call eases 3D position from (0, 0, 3) to (5, 5, 3) over 5 seconds using a bounce in-out easing, with ping-pong enabled to reverse the motion back and forth, starting at time 0. The position is stored in float3 position.</p> <pre><code>float3 position;\ntween3D_float(float3(0,0,3), float3(5,5,3), 5.0, TWEEN_BOUNCE_INOUT, 0.0, true, position);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis. It combines an expands the shader library's Translate and Pulse-Scale Animations.</p>"},{"location":"engines/unity/basics/combineColor/","title":"Combine Color","text":"Combine Color by Frieda Hentschel <p>This function can be used to combine the output of different raymarching-based functions. It is used after all the lighting functions have been applied to the raymarching. </p> <p>This function has been added for completion's sake but is not recommended. It can only combine hit objects but it cannot maintain lighting effects that affect the environment such as the Sunrise or the Point Light. For the prefered method to combine results, refer to Minimum. </p> <p>However, it may be used for experimental shaders that compare the effect of different lighting functions.</p>"},{"location":"engines/unity/basics/combineColor/#the-code","title":"The Code","text":"<pre><code>void combinedColor_float(float4 hitPosition1, float3 color1, float4 hitPosition2, float3 color2, out float3 color)\n{\n    if (hitPosition1.w &gt; _raymarchStoppingCriterium &amp;&amp; hitPosition2.w &gt; _raymarchStoppingCriterium)\n        color = float3(0, 0, 0);\n    else if (hitPosition1.w &lt; hitPosition2.w)\n        color = color1;\n    else\n        color = color2;\n}\n</code></pre> <p>The edgecase, that for a fragment both inputs did not yield a hit, is checked for first. In such a case, the color is set to black. Thus, removing any effects lighting might have on those fragments.</p>"},{"location":"engines/unity/basics/combineColor/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/basics/combineColor/#inputs","title":"Inputs:","text":"Name Type Description <code>hitPosition1</code> float4 Hit position of the first input where the first three dimensions define the point in space and the w-component contains the raymarching parameter at which the hit occured <code>color1</code> float3 Color of the first input <code>hitPosition2</code> float4 Hit position of the second input where the first three dimensions define the point in space and the w-component contains the raymarching parameter at which the hit occured <code>color2</code> float3 Color of the second input"},{"location":"engines/unity/basics/combineColor/#outputs","title":"Outputs:","text":"<p>| <code>color</code>        | float3   | Combined color of both inputs based on which hit is closer to the camera|</p>"},{"location":"engines/unity/basics/combineColor/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Basics/Combine Color</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/basics_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 resultColor;\ncombinedColor_float(hitPosition1, color1, hitPosition2, color2, resultColor)\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/basics/fragCoords/","title":"Fragment Coordinates","text":"Fragment Coordinates by Frieda Hentschel <p>This function computes fragment coordinates ranging from 0 to 1 based on input coordinates. As this function is responsible for computing the coordinates at which a fragement is computed, it is the basis for all others. It should always be included in a shader.</p>"},{"location":"engines/unity/basics/fragCoords/#the-code","title":"The Code","text":"<pre><code>void computeFragmentCoordinates_float(float2 inputCoordinates, float scaleUp, float scaleRight, out float2 fragmentCoordinates)\n{\n    fragmentCoordinates = inputCoordinates.xy * 2 - 1;\n    if (scaleRight&gt;scaleUp)\n        fragmentCoordinates.x *= scaleRight / scaleUp;\n    else\n        fragmentCoordinates.y *= scaleUp / scaleRight;\n}\n</code></pre>"},{"location":"engines/unity/basics/fragCoords/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/basics/fragCoords/#inputs","title":"Inputs:","text":"Name Type Description <code>inputCoordinates</code> float2 Input coordinates - usually uv-input of the object the shader is applied to <code>scaleUp</code> float Vertical scale of the object  ShaderGraph default value: 1 <code>scaleRight</code> float Horizontal scale of the object  ShaderGraph default value: 1"},{"location":"engines/unity/basics/fragCoords/#outputs","title":"Outputs:","text":"Name Type Description <code>fragmentCoordinates</code> float2 Coordinates mapped to 0 to 1 which are a required input to SDF Raymarching, Water Surface, and certain lighting functions"},{"location":"engines/unity/basics/fragCoords/#notes-on-non-uniformly-shaped-objects","title":"Notes on Non-Uniformly Shaped Objects","text":"<p>If a square-shaped object is used to apply the shader to, both the scaleUp and the scaleRight can be disregarded in the ShaderGraph oder simply be set to 1 for the Standard Scripting. However, if rectangles (e.g. fullscreen shaders) or cuboids are utilised, the scaling parameters are necessary to ensure that no distortion occurs. This is done by applying the ratio of the scales to the coordinates.</p> <p>The required scaling-values depend on the object's extent as well as Unity's camera:</p> <ul> <li>For a rectangle choose the vertical scale as scaleUp and the horizontal scale as scaleRight.</li> <li>For a cuboid choose the scaling-values as above taking Unity's camera into account. If the camera looks along the z-axis and the y-axis defines the upwards vector, choose the y-scale as scaleUp and the x-scale as scaleRight.</li> </ul> <p>If a cuboid is used that is differently scaled in each dimension, the procedural results can only be non-distorted for a combination of two axis.</p> <p>!ADD IMAGE</p>"},{"location":"engines/unity/basics/fragCoords/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Basics/Fragment Coordinates</code></p> <p>To easily get access to the scale:</p> <ul> <li> <p>For objects: Add Unity's Object Node, connect the scale-parameter to Unity's Splitter Node, and choose the required dimensions to connect to the custom node's inputs. </p> <p> </p> </li> <li> <p>For fullscreen shaders: Add Unity's Screen Node to access the width and height of the screen </p> <p> </p> </li> </ul> <p>Due to internal workings of the node, the input-coordinates-input is not required. Within the SubGraph a Branch On Input Connection node is used to determine whether any input coordinates were connected to their respective input. If this is not the case, the uv-coordinates are used as a default input. </p> <p> </p> <p>For an alternative effect, the input-coordinates can also be customised. The Screen Position Node can be used if zooming in should not effect the scale of the material.</p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/basics_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float2 uv;\ncomputeFragmentCoordinates_float(IN.uv, 10, 12, uv);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/basics/minimum/","title":"Minimum","text":"Minimum by Frieda Hentschel <p>This function outputs the hit-position, normal, and hit-index out of two sets of inputs based on which hit-position is closer to the camera. It is used before all the lighting functions are applied. </p> <p>Therefore, it can be used to combine outputs of raymarching functions. The subsequent lighting functions are then applied to the output of this function. Other than Combine Color, the Sunrise and Point Light functions have effects.</p>"},{"location":"engines/unity/basics/minimum/#the-code","title":"The Code","text":"<pre><code>void getMinimum_float(float4 hitPosition1, float3 normal1, int hitIndex1, float4 hitPosition2, float3 normal2, int hitIndex2, out float4 hitPosition, out float3 normal, out int hitIndex)\n{\n    if (hitPosition1.w &lt; hitPosition2.w &amp;&amp; hitPosition1.w &lt; _raymarchStoppingCriterium)\n    {\n        hitPosition = hitPosition1;\n        normal = normal1;\n        hitIndex = hitIndex1;\n    }\n    else\n    {\n        hitPosition = hitPosition2;\n        normal = normal2;\n        hitIndex = hitIndex2;\n    }\n}\n</code></pre>"},{"location":"engines/unity/basics/minimum/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/basics/minimum/#inputs","title":"Inputs:","text":"Name Type Description <code>hitPosition1</code> float4 Hit-position of the first input where the first three dimensions define the point in space and the w-component contains the raymarching parameter at which the hit occured <code>normal1</code> float3 Normal of the first input <code>hitIndex1</code> int Hit-index of the first input <code>hitPosition2</code> float4 Hit-position of the second input where the first three dimensions define the point in space and the w-component contains the raymarching parameter at which the hit occured <code>normal3</code> float3 Normal of the second input <code>hitIndex2</code> int Hit-index of the second input"},{"location":"engines/unity/basics/minimum/#outputs","title":"Outputs:","text":"Name Type Description <code>hitPosition</code> float4 Hit-position that is the closest to the camera out of the two sets of inputs <code>normal</code> float3 Normal corresponding to the closest hit-position <code>hitIndex</code> int Hit-index corresponding to the closest hit-position <p>The outputs can be used for further computations using lighting functions (e.g. Sunrise).</p>"},{"location":"engines/unity/basics/minimum/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Basics/Minimum</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/basics_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>getMinimum_float(hitPos1, normal1, hitID1, hitPos2, normal2, hitID2, hitPos, normal, hitID);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/camera/cameraBackAndForth/","title":"Back And Forth","text":"Camera Back and Forth by Frieda Hentschel <p>This function imitates a camera translation by changing the ray origin and the camera matrix. The translation occurs along the z-axis going from 0 to 1 using a sinus function.</p>"},{"location":"engines/unity/camera/cameraBackAndForth/#the-code","title":"The Code","text":"<pre><code>void backAndForth_float(float speed, out float3x3 mat)\n{\n    float t = _Time.y * speed;\n    mat = float3x3(1, 0, 0, 0, 1, 0, 0, 0, abs(sin(t)));\n}\n</code></pre>"},{"location":"engines/unity/camera/cameraBackAndForth/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/camera/cameraBackAndForth/#inputs","title":"Inputs:","text":"Name Type Description <code>speed</code> float Speed with which the translation is applied  ShaderGraph default value: 1"},{"location":"engines/unity/camera/cameraBackAndForth/#outputs","title":"Outputs:","text":"Name Type Description <code>mat</code> float3x3 Transformation matrix which needs to be plugged into the Camera Matrix before it can be used within the rest of the pipeline. This is necessary to apply the transformation matrix to the ray origin and to compute the correct camera matrix"},{"location":"engines/unity/camera/cameraBackAndForth/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Camera/Back and Forth</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3x3 transformMatrix;\nbackAndForth_float(2.0, transformMatrix);\n</code></pre> <p>ADD LINK Find the original shader code here.</p>"},{"location":"engines/unity/camera/cameraMatrix/","title":"Camera Matrix","text":"Camera Matrix by Frieda Hentschel <p>This function computes the camera matrix based on two input matrices. This allows the combination of two or more camera animations. It is required after a camera animation is applied. </p>"},{"location":"engines/unity/camera/cameraMatrix/#the-code","title":"The Code","text":"<pre><code>void getCameraMatrix_float(float3x3 mat1, float3x3 mat2, float3 lookAtPosition, out float3x3 cameraMatrix)\n{\n    float3x3 combinedMatrix = mul(mat1, mat2);\n    _rayOrigin = mul(_rayOrigin, combinedMatrix);\n    cameraMatrix = computeCameraMatrix(lookAtPosition, _rayOrigin, combinedMatrix);\n}\n</code></pre> <p>See Helper Functions to find out more about <code>computeCameraMatrix(float3 lookAtPosition, float3 eye, float3x3 mat)</code></p>"},{"location":"engines/unity/camera/cameraMatrix/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/camera/cameraMatrix/#inputs","title":"Inputs:","text":"Name Type Description <code>mat1</code> float3x3 First transformation matrix to be combined for the computation  ShaderGraph default value: 3x3 identity matrix <code>mat2</code> float3x3 Second transformation matrix to be combined for the computation  ShaderGraph default value: 3x3 identity matrix <code>lookAtPosition</code> float3 Focal point of the camera <p>Examplary matrices that can be used as input to this function are Camera Rotation or Camera Back and Forth. </p> <p>It is possible to only add one custom matrix as the multiplication with the default identity matrix yields correct results. If more than two matrices are to be combined, multiply them together via script or a Multiply Node before plugging the result into this function.</p>"},{"location":"engines/unity/camera/cameraMatrix/#outputs","title":"Outputs:","text":"Name Type Description <code>cameraMatrix</code> float3x3 final camera matrix that can be plugged into the Water Shader or the SDF Raymarching"},{"location":"engines/unity/camera/cameraMatrix/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Camera/Camera Matrix</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3x3 camMatrix;\ngetCameraMatrix_float(matA, matB, dist, targetPos, camMatrix);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/camera/cameraRotation/","title":"Rotation","text":"Camera Rotation by Frieda Hentschel <p>This function imitates a camera rotation by changing the ray origin and the camera matrix. The rotation will always be centred at the world origin. The distance at which the rotation is applied is defined by the distance between the world origin and the current ray origin.</p>"},{"location":"engines/unity/camera/cameraRotation/#the-code","title":"The Code","text":"<pre><code>void rotateCamera_float(float3 axis, float speed, out float3x3 mat)\n{\n    float angle = _Time.y * speed;\n    mat = computeRotationMatrix(normalize(axis), angle);\n}\n</code></pre> <p>See Helper Functions to find out more about <code>computeRotationMatrix(float3 axis, float angle)</code></p>"},{"location":"engines/unity/camera/cameraRotation/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/camera/cameraRotation/#inputs","title":"Inputs:","text":"Name Type Description <code>axis</code> float3 Axis around which the camera rotates   ShaderGraph default value: float3(0,1,0) <code>speed</code> float Speed with which the rotation is applied  ShaderGraph default value: 1"},{"location":"engines/unity/camera/cameraRotation/#outputs","title":"Outputs:","text":"Name Type Description <code>mat</code> float3x3 Transformation matrix which needs to be plugged into the Camera Matrix before it can be used within the rest of the pipeline. This is necessary to apply the transformation matrix to the ray origin and to compute the correct camera matrix"},{"location":"engines/unity/camera/cameraRotation/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Camera/Rotate Camera</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3x3 rotationMatrix;\nrotateCamera_float(rotationAxis, rotationSpeed, rotationMatrix);\n</code></pre> <p>ADD LINK Find the original shader code here.</p>"},{"location":"engines/unity/camera/mouseBasedMovement/","title":"Mouse-Based Rotation","text":"Mouse-Based Camera Rotation by Frieda Hentschel <p>This function imitates a camera rotation based on the mouse position. With a left mouse-click the world can be rotated in the x- and y-direction. </p>"},{"location":"engines/unity/camera/mouseBasedMovement/#the-code","title":"The Code","text":"<pre><code>void rotateViaMouse_float(out float3x3 mat)\n{\n    float2 mouse = _mousePoint.xy / _ScreenParams.xy;\n\n    // Center mouse to [-0.5, +0.5]\n    mouse = mouse - 0.5;\n\n    // Convert to yaw and pitch\n    // == PI * mouse.x when centered\n    float yaw = lerp(-PI, PI, mouse.x + 0.5); \n    // Invert Y axis\n    float pitch = lerp(-PI / 2, PI / 2, -mouse.y + 0.5); \n\n    float3x3 rotY = computeRotationMatrix(float3(0, 1, 0), yaw);\n    float3x3 rotX = computeRotationMatrix(float3(1, 0, 0), pitch);\n\n    mat = mul(rotY, rotX);\n}\n</code></pre> <p>See Helper Functions to find out more about <code>computeRotationMatrix(float3 axis, float angle)</code></p>"},{"location":"engines/unity/camera/mouseBasedMovement/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/camera/mouseBasedMovement/#inputs","title":"Inputs:","text":"<p>None</p>"},{"location":"engines/unity/camera/mouseBasedMovement/#outputs","title":"Outputs:","text":"Name Type Description <code>mat</code> float3x3 Final camera matrix that can be plugged into the Water Shader or the SDF Raymarching"},{"location":"engines/unity/camera/mouseBasedMovement/#experience","title":"Experience","text":"<ul> <li>Rotations via clicking the left mouse-button<ul> <li>Drag left and right for a rotation around the y-axis.</li> <li>Drag up and down for a rotation around the x-axis.</li> </ul> </li> </ul>"},{"location":"engines/unity/camera/mouseBasedMovement/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Camera/Rotate Via Mouse</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/animation_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3x3 camMat;\nrotateViaMouse_float(camMat);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/blinnPhongLight/","title":"Blinn Phong Lighting","text":"Blinn-Phong Lighting by Utku Alkan <p>This function implements the Blinn-Phong lighting model using per-pixel calculations. It computes diffuse and specular reflections based on the surface normal, view direction, and light direction. A small ambient component is added for minimal base illumination.      </p>"},{"location":"engines/unity/lighting/blinnPhongLight/#the-code","title":"The Code","text":"<pre><code>void applyBlinnPhongLighting_float(float4 hitPosition, float3 normal, int hitIndex, float3 lightPosition, out\nfloat3 lightingColor)\n{\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n\n    float3 halfVec = normalize(viewDirection + lightDirection);\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float specularValue = pow(max(dot(normal, halfVec), 0.0), _objectShininess[hitIndex]);\n\n    float3 diffuseColor = diffuseValue * _objectBaseColor[hitIndex] * lightColor;\n    float3 specular = specularValue * _objectSpecularColor[hitIndex] * _objectSpecularStrength[hitIndex];\n\n    lightingColor = ambientColor + diffuseColor + specular;\n}\n</code></pre>"},{"location":"engines/unity/lighting/blinnPhongLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/blinnPhongLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component may be ignored <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/blinnPhongLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using Blinn-Phong shading"},{"location":"engines/unity/lighting/blinnPhongLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Blinn Phong Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyBlinnPhongLighting_float(hitPos, surfaceNormal, objectIndex, float3(3, 6, -2), lightColor);\n</code></pre> <p>Find the original shader code here. This basis was adapted to be compatible with Unity's workflow and to allow it to be modifyable within the framework.</p>"},{"location":"engines/unity/lighting/fresnelLight/","title":"Fresnel Lighting","text":"Fresnel Lighting by Utku Alkan <p>This function applies Fresnel-based lighting using Schlick\u2019s approximation to simulate view-dependent reflectivity. It combines Lambertian diffuse shading with a specular fresnel effect that intensifies as the viewing angle approaches grazing.      </p>"},{"location":"engines/unity/lighting/fresnelLight/#the-code","title":"The Code","text":"<pre><code>void applyFresnelLighting_float(float4 hitPosition, float3 normal, int hitIndex, float3 lightPosition, out float3 lightingColor)\n{\n    if (hitPosition.w &gt; _raymarchStoppingCriterium)\n    {\n        lightingColor = float3(0, 0, 0);\n        return;\n    }\n\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n\n    float3 baseColor = _objectBaseColor[hitIndex];\n    float3 specularColor = _objectSpecularColor[hitIndex];\n\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float NdotL = saturate(dot(normal, lightDirection));\n    float3 diffuse = baseColor * lightColor * NdotL;\n\n    // Schlick's approximation\n    float3 F0 = specularColor;\n    float cosTheta = saturate(dot(viewDirection, normal));\n    float3 fresnel = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n\n    lightingColor = ambientColor + diffuse + fresnel;\n}\n</code></pre>"},{"location":"engines/unity/lighting/fresnelLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/fresnelLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component holds the raymarch distance <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/fresnelLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using diffuse and Fresnel specular reflection"},{"location":"engines/unity/lighting/fresnelLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Fresnel Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyFresnelLighting_float(hitPos, surfaceNormal, objectIndex, float3(1, 4, -1), lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/generalInformation/","title":"General Information","text":"Lighting in Unity by Frieda Hentschel <p>The lighting functions are an essential part of the framework. They return the final color for a fragment and without them, the raymarched SDFs and environments are not visualised. </p>"},{"location":"engines/unity/lighting/generalInformation/#types-of-lighting","title":"Types of Lighting","text":"<p>There are two major types of lighting implemented. Make sure to use the one that fits the scene the best or combine them. </p> <ol> <li>Lighting that effect the atmosphere. Even if the fragment does not contain a hit, the fragment is effected by the light.  <ol> <li>Sunrise</li> <li>Point Light</li> </ol> </li> <li>Lighting that does not effect the atmosphere. The lighting only effects objects within the scene and changes the visual output of their surface. <ol> <li>Lambertian Lighting</li> <li>Blinn Phong Lighting</li> <li>Toon Lighting</li> <li>Rim Lighting</li> <li>Soft Subsurface Scattering Lighting</li> <li>Fresnel Lighting</li> <li>UV Gradient Lighting</li> <li>UV Anisotropic Lighting</li> </ol> </li> </ol>"},{"location":"engines/unity/lighting/generalInformation/#the-importance-of-hit-indices","title":"The Importance of Hit-Indices","text":"<p>In order to reduce the amount of outputs of raymarching functions and the amount of inputs to the lighting functions, the scene's materials are stored within global arrays. For each object added to the scene, the values of that object's material are stored at an instance-specific index. </p> <p>During the raymarching, the index of the object that was hit is retained, thus, enabling the retrieval of the corresponding material-values during the application of a lighting function. </p> <p>Since SDFs are stored by their parameters in their own global arrays, one set of indices is used accross the global arrays containing the SDFs' values and the global arrays containing the material-values. See the exact implementation in the Global Variables. </p> <p>To allow the application of lighting functions to the Water Surface as well, an additional hard-coded hit-index for it was introduced. It is defined to be the first index after any of the ones for the SDFs. </p>"},{"location":"engines/unity/lighting/generalInformation/#how-to-combine-lighting-functions","title":"How to Combine Lighting Functions","text":"<p>To combine lighting functions simply add the resulting colors together. For ShaderGraph the Unity's Add Node can be used for convenience.       </p> <p>For the standart scripting users can combine the lights by simply adding the outputs. <pre><code>pointLight_float(hitPos, normal, hitID, rayDir1, _LightPosition, float3(1,1,1), 5, 0.05,  colorOut1);\napplyToonLighting_float(hitPos, normal, hitID, _LightPosition, colorOut2);\nsunriseLight_float(hitPos, normal, hitID, rayDir1, colorOut3);\n\ncolorOut = colorOut1 + colorOut2 + colorOut3;\n</code></pre> Example output      </p>"},{"location":"engines/unity/lighting/lambLight/","title":"Lambertian Lighting","text":"Lambert Lighting by Utku Alkan <p>This function applies simple Lambertian diffuse lighting with a fixed light source. It computes the diffuse reflection based on the angle between the light direction and surface normal, and adds a small constant ambient term. This is a lightweight lighting model ideal for unlit or stylized shading.      </p>"},{"location":"engines/unity/lighting/lambLight/#the-code","title":"The Code","text":"<pre><code>void applyLambertLighting_float(float4 hitPosition, float3 normal, float3 lightPosition, out float3 lightingColor)\n{\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float3 diffuseColor = diffuseValue * lightColor;\n\n    lightingColor = ambientColor + diffuseColor;\n}\n</code></pre>"},{"location":"engines/unity/lighting/lambLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/lambLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component may be ignored <code>normal</code> float3 Surface normal at the hit point <code>lightPosition</code> float3 World-space position of the directional light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/lambLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using diffuse and ambient components"},{"location":"engines/unity/lighting/lambLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Lambertian Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyLambertLighting_float(hitPos, surfaceNormal, float3(2, 5, -2), lightColor);\n</code></pre> <p>Find the original shader code here. This basis was adapted to be compatible with Unity's workflow and to allow it to be modifyable within the framework.</p>"},{"location":"engines/unity/lighting/pointLight/","title":"Point Light","text":"Point Light by Utku Alkan <p>This function simulates a point light source with distance-based attenuation and optional atmospheric decay. It casts a ray through the scene and accumulates light color based on distance from the point light, then applies Phong-based shading at the surface hit point.</p> <p>The function does not check for objects between a point in space and the light. Therefore, it does not reproduce shadows.       </p>"},{"location":"engines/unity/lighting/pointLight/#the-code","title":"The Code","text":"<pre><code>void pointLight_float(float4 hitPosition, float3 normal, int hitIndex, float3 rayDirection, float3 lightPosition, float3 lightColor, float dropPower, float atmosphericDecay, out float3 lightingColor)\n{\n    //raymarch the environment    \n    float t = 0;\n    float3 pixelLightColor = float3(0, 0, 0);\n    while (t &lt; hitPosition.w)\n    {\n        float3 pt = _rayOrigin + t * rayDirection;\n        float dist = distance(pt, lightPosition);\n\n        float attenuation = clamp(1.0 / (pow(dist, dropPower)), 0.0, 1.0); \n        float absorption = exp(-t * atmosphericDecay);\n\n        pixelLightColor += attenuation * lerp(lightColor, float3(1.0, 1.0, 1.0), attenuation) * absorption;\n\n        t += 1;\n    }\n\n    if (hitPosition.w &gt; _raymarchStoppingCriterium)\n    {\n        lightingColor = pixelLightColor;\n        return;\n    }\n\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 reflectedDirection = reflect(-lightDirection, normal);\n\n    float3 ambientColor = float3(0, 0, 0);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float specularValue = pow(max(dot(reflectedDirection, viewDirection), 0.0), _objectShininess[hitIndex]);\n\n    float3 diffuseColor = diffuseValue * _objectBaseColor[hitIndex] * pixelLightColor;\n    float3 specularColor = specularValue * _objectSpecularColor[hitIndex] * _objectSpecularStrength[hitIndex];\n\n    lightingColor = ambientColor + diffuseColor + specularColor;\n}\n</code></pre>"},{"location":"engines/unity/lighting/pointLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/pointLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component holds the raymarch step or distance <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>rayDirection</code> float3 Direction of the incoming ray <code>lightPosition</code> float3 World-space position of the point light <code>lightColor</code> float3 Base color of the point light  ShaderGraph default value:float3(1,1,1) <code>dropPower</code> float Exponent for light attenuation falloff  ShaderGraph default value: 5 <code>atmosphericDecay</code> float Exponential decay factor for atmospheric light absorption  ShaderGraph default value: 0.05 <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/pointLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result from the point light and material shading"},{"location":"engines/unity/lighting/pointLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Point Light</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\npointLight_float(hitPos, normal, hitID, rayDir, float3(2, 5, -2), float3(1,1,1), 5, 0.05, lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/rimLight/","title":"Rim Lighting","text":"Rim Lighting by Utku Alkan <p>This function implements rim lighting, a non-photorealistic effect that highlights the edges of an object based on the view angle. It enhances silhouettes by boosting brightness where the view direction is nearly perpendicular to the surface normal. The effect is combined with ambient and base lighting, and uses the specular color to tint the rim.      </p>"},{"location":"engines/unity/lighting/rimLight/#the-code","title":"The Code","text":"<pre><code>void applyRimLighting_float(float4 hitPosition, float3 normal, int hitIndex, float3 lightPosition, out\nfloat3 lightingColor)\n{\n    if (hitPosition.w &gt; _raymarchStoppingCriterium)\n    {\n        lightingColor = float3(0, 0, 0);\n        return;\n    }\n\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n\n    float rim = 1.0 - saturate(dot(viewDirection, normal));\n    rim = pow(rim, 4.0);\n\n    float3 baseColor = _objectBaseColor[hitIndex];\n    lightingColor = ambientColor + baseColor * lightColor + rim * _objectSpecularColor[hitIndex];\n}\n</code></pre>"},{"location":"engines/unity/lighting/rimLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/rimLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component holds the raymarch distance <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/rimLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using rim lighting, ambient, and base color shading"},{"location":"engines/unity/lighting/rimLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Rim Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyRimLighting_float(hitPos, surfaceNormal, objectIndex, float3(1, 3, -2), lightColor);\n</code></pre> <p>Find the original shader code here. This basis was adapted to be compatible with Unity's workflow and to allow it to be modifyable within the framework.</p>"},{"location":"engines/unity/lighting/softSubsurfaceScattering/","title":"Soft Subsurface Scattering","text":"Soft Subsurface Scattering (SSS) Lighting by Utku Alkan <p>This function simulates a simple soft subsurface scattering (SSS) effect by adding light transmitted through the object\u2019s surface. It enhances realism by combining standard Lambertian diffuse shading with a soft backlighting term.      </p>"},{"location":"engines/unity/lighting/softSubsurfaceScattering/#the-code","title":"The Code","text":"<pre><code>void applySoftSSLighting_float(float4 hitPosition, float3 normal, int hitIndex, float3 lightPosition, out\nfloat3 lightingColor)\n{\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float backLight = max(dot(-normal, lightDirection), 0.0);\n\n    float3 baseColor = _objectBaseColor[hitIndex];\n    float3 sssColor = float3(1.0, 0.5, 0.5);\n\n    float3 diffuseColor = diffuseValue * baseColor * lightColor;\n    float3 sss = backLight * sssColor * 0.25;\n\n    lightingColor = ambientColor + diffuseColor + sss;\n}\n</code></pre>"},{"location":"engines/unity/lighting/softSubsurfaceScattering/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/softSubsurfaceScattering/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component may be ignored <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/softSubsurfaceScattering/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result including diffuse shading and soft backlight (SSS) contribution"},{"location":"engines/unity/lighting/softSubsurfaceScattering/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/SoftSSSLight</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplySoftSSLighting_float(hitPos, surfaceNormal, objectIndex, float3(0, 5, -2), lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/sunriseLight/","title":"Sunrise","text":"Sunrise by Utku Alkan <p>This function computes realistic atmospheric lighting based on a simplified earth-sun model. It simulates sunlight scattering through the atmosphere and includes diffuse and specular reflections using a Phong lighting model. If the ray hits the sky (escapes before hitting geometry), it returns the atmospheric color.      </p>"},{"location":"engines/unity/lighting/sunriseLight/#the-code","title":"The Code","text":"Sunrise Related Helper Functions <pre><code>struct SunriseLight\n{\n    float3 sundir;\n    float3 earthCenter;\n    float earthRadius;\n    float atmosphereRadius;\n    float sunIntensity;\n};\n\nfloat2 densitiesRM(float3 position, SunriseLight light)\n{\n    float h = max(0., length(position - light.earthCenter) - light.earthRadius);\n    return float2(exp(-h / 8e3), exp(-h / 12e2));\n}\n\nfloat escape(float3 position, float3 direction, float atmosphereRadius, float3 earthCenter)\n{\n    float3 v = position - earthCenter;\n    float b = dot(v, direction);\n    float det = b * b - dot(v, v) + atmosphereRadius * atmosphereRadius;\n    if (det &lt; 0.)\n        return -1.;\n    det = sqrt(det);\n    float t1 = -b - det;\n    float t2 = -b + det;\n    return (t1 &gt;= 0.) ? t1 : t2;\n}\n\nfloat2 scatterDepthInt(float3 position, float3 direction, float atmosphericDistance, float steps, SunriseLight light)\n{\n    float2 depthRMs = float2(0., 0);\n    atmosphericDistance /= steps;\n    direction *= atmosphericDistance;\n\n    for (float i = 0.; i &lt; steps; ++i)\n        depthRMs += densitiesRM(position + direction * i, light);\n\n    return depthRMs * atmosphericDistance;\n}\n\nfloat3 applySunriseLighting(float3 position, float3 direction, float atmosphericDistance, float3 Lo, SunriseLight light)\n{\n    float3 bR = float3(58e-7, 135e-7, 331e-7); // Rayleigh scattering coefficient\n    float3 bMs = float3(2e-5, 2e-5, 2e-5); // Mie scattering coefficients\n    float3 bMe = float3(2e-5, 2e-5, 2e-5) * 1.1;\n    float2 totalDepthRM = float2(0., 0);\n    float3 I_R = float3(0., 0, 0);\n    float3 I_M = float3(0., 0, 0);\n    float3 oldDirection = direction;\n    atmosphericDistance /= 16.0;\n    direction *= atmosphericDistance;\n\n    for (float i = 0.; i &lt; 16.0; ++i)\n    {\n        float3 currentPosition = position + direction * i;\n        float2 dRM = densitiesRM(currentPosition, light) * atmosphericDistance;\n        totalDepthRM += dRM;\n        float2 depthRMsum = totalDepthRM + scatterDepthInt(currentPosition, light.sundir, escape(currentPosition, light.sundir, light.atmosphereRadius, light.earthCenter), 4., light);\n        float3 A = exp(-bR * depthRMsum.x - bMe * depthRMsum.y);\n        I_R += A * dRM.x;\n        I_M += A * dRM.y;\n    }\n\n    float mu = dot(oldDirection, light.sundir);\n    return Lo + Lo * exp(-bR * totalDepthRM.x - bMe * totalDepthRM.y)\n        + light.sunIntensity * (1. + mu * mu) * (\n            I_R * bR * .0597 +\n            I_M * bMs * .0196 / pow(1.58 - 1.52 * mu, 1.5));\n}\n</code></pre> <pre><code>void sunriseLight_float(float4 hitPosition, float3 normal, int hitIndex, float3 rayDirection, out float3 lightingColor)\n{ \n    SunriseLight sunrise;\n    sunrise.sundir = normalize(float3(0.5, 0.4 * (1. + sin(0.5 * _Time.y)), -1.));\n    sunrise.earthCenter = float3(0., -6360e3, 0.);\n    sunrise.earthRadius = 6360e3;\n    sunrise.atmosphereRadius = 6380e3;\n    sunrise.sunIntensity = 10.0;\n\n    float atmosphereDist = escape(hitPosition.xyz, rayDirection, sunrise.atmosphereRadius, sunrise.earthCenter);\n    float3 lightColor = applySunriseLighting(hitPosition.xyz, rayDirection, atmosphereDist, float3(0, 0, 0), sunrise);\n\n    if (hitPosition.w &gt; _raymarchStoppingCriterium)\n    {\n        lightingColor = lightColor;\n        return;\n    }\n\n    float3 lightDirection = sunrise.sundir;\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 reflectedDirection = reflect(-lightDirection, normal);\n\n    float3 ambientColor = float3(0, 0, 0);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float specularValue = pow(max(dot(reflectedDirection, viewDirection), 0.0), _objectShininess[hitIndex]);\n\n    float3 diffuseColor = diffuseValue * (0.5 * _objectBaseColor[hitIndex] + 0.5 * lightColor);\n    float3 specularColor = specularValue * _objectSpecularColor[hitIndex] * _objectSpecularStrength[hitIndex];\n\n    lightingColor = ambientColor + diffuseColor + specularColor;\n}\n</code></pre>"},{"location":"engines/unity/lighting/sunriseLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/sunriseLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component holds the raymarch step or distance <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>rayDirection</code> float3 Direction of the incoming ray <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/sunriseLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result, including sunrise sky or surface lighting"},{"location":"engines/unity/lighting/sunriseLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Sunrise</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\nsunriseLight_float(hitPos, surfaceNormal, objectIndex, rayDir, lightColor);\n</code></pre> <p>ADD CORRECT LINK Find the original shader code here. This basis was adapted to be compatible with Unity's workflow and to allow it to be modifyable within the framework.</p>"},{"location":"engines/unity/lighting/toonLight/","title":"Toon Lighting","text":"Toon Lighting by Utku Alkan <p>This function implements a stylized toon shading model using stepped diffuse bands instead of smooth gradients. It divides diffuse reflection into discrete levels and combines it with a minimal ambient term. This creates a cartoon-like appearance with clear lighting bands and no specular highlights.      </p>"},{"location":"engines/unity/lighting/toonLight/#the-code","title":"The Code","text":"<pre><code>void applyToonLighting_float(float4 hitPosition, float3 normal, int hitIndex, float3 lightPosition, out\nfloat3 lightingColor)\n{\n    if (hitPosition.w &gt; _raymarchStoppingCriterium)\n    {\n        lightingColor = float3(0, 0, 0);\n        return;\n    }\n\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.05, 0.05, 0.05);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n\n    float step1 = 0.3;\n    float step2 = 0.6;\n    float step3 = 0.9;\n\n    float toonDiff =\n        diffuseValue &gt; step3 ? 1.0 :\n        diffuseValue &gt; step2 ? 0.7 :\n        diffuseValue &gt; step1 ? 0.4 : 0.1;\n\n    lightingColor = ambientColor + toonDiff * _objectBaseColor[hitIndex] * lightColor;\n}\n</code></pre>"},{"location":"engines/unity/lighting/toonLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/toonLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component holds the raymarch distance <code>normal</code> float3 Surface normal at the hit point <code>hitIndex</code> int Object/material index used to fetch shading parameters <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/toonLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using stepped toon shading"},{"location":"engines/unity/lighting/toonLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/Toon Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyToonLighting_float(hitPos, surfaceNormal, objectIndex, float3(2, 4, -3), lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/uvAnisotropicLight/","title":"UV Anisotropic Lighting","text":"UV Anisotropic Lighting by Utku Alkan <p>This function simulates anisotropic lighting effects using per-pixel tangent vectors derived from UV coordinates. The result mimics materials like brushed metal or hair by modulating specular highlights along UV-based tangent directions. It combines Lambertian diffuse lighting with a directional specular term.      </p>"},{"location":"engines/unity/lighting/uvAnisotropicLight/#the-code","title":"The Code","text":"<pre><code>void applyUVAnisotropicLighting_float(float4 hitPosition, float3 normal, int hitIndex, float2 uv, float3 lightPosition, out\nfloat3 lightingColor)\n{\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 halfVec = normalize(viewDirection + lightDirection);\n\n    float angle = uv.x * 6.2831853; // 2\u03c0\n    float3 localTangent = float3(cos(angle), sin(angle), 0.0);\n    float3 tangent = normalize(localTangent - normal * dot(localTangent, normal));\n    float3 bitangent = cross(normal, tangent);\n\n    float TdotH = dot(tangent, halfVec);\n    float BdotH = dot(bitangent, halfVec);\n    float spectralAnisotropic = pow(TdotH * TdotH + BdotH * BdotH, 8.0);\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n\n    float3 ambientColor = float3(0.1, 0.1, 0.1);\n\n    lightingColor = ambientColor + diffuseValue * _objectBaseColor[hitIndex] + spectralAnisotropic * _objectSpecularColor[hitIndex];\n}\n</code></pre>"},{"location":"engines/unity/lighting/uvAnisotropicLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/uvAnisotropicLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World-space surface hit position; <code>w</code> holds the raymarch step or distance <code>normal</code> float3 Surface normal at the hit location <code>hitIndex</code> int Index used to fetch object material properties <code>uv</code> float2 UV coordinates used to define local tangent direction; for this framework the fragment coordinates from Fragment Coordinates can be used <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/uvAnisotropicLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 RGB lighting result including anisotropic specular highlights and standard diffuse"},{"location":"engines/unity/lighting/uvAnisotropicLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/UV Anisotropic Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyUVAnisotropicLighting_float(hitPos, surfaceNormal, objectIndex, uvCoords, lightPos, lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/lighting/uvGradientLight/","title":"UV Gradient Lighting","text":"UV Gradient Lighting by Utku Alkan <p>This function applies Lambertian diffuse lighting with a color gradient based on the surface's UV coordinates. The gradient interpolates from blue to orange depending on the <code>uv.y</code> value, creating visually interesting color variation across a surface. Ambient light is added for minimal base illumination.      </p>"},{"location":"engines/unity/lighting/uvGradientLight/#the-code","title":"The Code","text":"<pre><code>void applyUVGradientLighting_float(float4 hitPosition, float3 normal, float2 uv, float3 lightPosition, out float3 lightingColor)\n{\n    float3 viewDirection = normalize(_rayOrigin - hitPosition.xyz);\n    float3 lightDirection = normalize(lightPosition - hitPosition.xyz);\n    float3 lightColor = float3(1.0, 1.0, 1.0);\n    float3 ambientColor = float3(0.1, 0.1, 0.1);\n\n    float diffuseValue = max(dot(normal, lightDirection), 0.0);\n    float3 gradientColor = lerp(float3(0.2, 0.4, 0.9), float3(1.0, 0.6, 0.0), uv.y);\n\n    lightingColor = ambientColor + diffuseValue * gradientColor * lightColor;\n}\n</code></pre>"},{"location":"engines/unity/lighting/uvGradientLight/#parameters","title":"Parameters","text":""},{"location":"engines/unity/lighting/uvGradientLight/#inputs","title":"Inputs","text":"Name Type Description <code>hitPosition</code> float4 World position of the surface hit; the w-component is typically the raymarch distance <code>normal</code> float3 Surface normal at the hit point <code>uv</code> float2 UV coordinates used for gradient calculation; for this framework the fragment coordinates from Fragment Coordinates can be used <code>lightPosition</code> float3 World-space position of the light source <p>The inputs are typically provided by the functions SDF Raymarching or Water Surface.</p>"},{"location":"engines/unity/lighting/uvGradientLight/#output","title":"Output","text":"Name Type Description <code>lightingColor</code> float3 Final RGB lighting result using UV-based color gradients and diffuse shading"},{"location":"engines/unity/lighting/uvGradientLight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Lighting/UV Gradient Lighting</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/lighting_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 lightColor;\napplyUVGradientLighting_float(hitPos, surfaceNormal, uvCoords, float3(1, 4, -1), lightColor);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/sdfs/cube/","title":"RoundBox","text":"SDF Round Box by Frieda Hentschel <p>This function creates an internal instance of an SDF-based cube with rounded corners. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/cube/#the-code","title":"The Code","text":"<pre><code>float sdRoundBox(float3 position, float3 size, float radius)\n{\n    float3 q = abs(position) - size + radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - radius;\n}\n\nvoid addRoundBox_float(int index, float3 position, float3 size, float radius, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 1, position, size, radius, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/cube/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/cube/#inputs","title":"Inputs:","text":"Name Type Description <code>index</code> int Index at which the cube is stored <code>position</code> float3 Central position <code>size</code> float3 Expand in each of the three dimensions  ShaderGraph default value: float3(1,1,1) <code>radius</code> float Radius with which the corners are rounded <code>axis</code> float3 Axis determining the orientation  ShaderGraph default value: float3(0,1,0) <code>angle</code> float World-space position of the light source <code>baseColor</code> float3 Underlying color  ShaderGraph default value: float3() <code>specularColor</code> float3 Color of the highlights <code>specularStrength</code> float Intensity with which highlights are created  ShaderGraph default value: 1 <code>shininess</code> float Shape and sharpness of the highlights; the larger the value, the more focussed the highlight   ShaderGraph default value: 32 <code>noise</code> float Noise that is added to the shape of the cube"},{"location":"engines/unity/sdfs/cube/#outputs","title":"Outputs:","text":"Name Type Description <code>indexOut</code> int Incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching"},{"location":"engines/unity/sdfs/cube/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Cube</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addRoundBox_float(index, float3(5,0,-5), float3(2,2,2), 1, float3(0.8,0.1,0.1), 0, float3(0.2,0.2,0.8), float3(0.2,0.8,0.8), 2, 1, 0, index);\n</code></pre> <p>Find the original shader code here.</p>"},{"location":"engines/unity/sdfs/dolphin/","title":"Dolphin","text":"SDF Dolphin by Frieda Hentschel <p>This function creates an internal instance of an SDF-based dolphin. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/dolphin/#the-code","title":"The Code","text":"SDF-Computations for the Dolphin <pre><code>float distanceToBox(float3 p, float3 halfExtent, float radius)\n{\n    float3 distanceToBox = abs(p) - halfExtent;\n    return length(max(distanceToBox, 0.0)) - radius;\n}\n\nfloat smoothUnion(float distance1, float distance2, float smoothFactor)\n{\n    float h = clamp(0.5 + 0.5 * (distance2 - distance1) / smoothFactor, 0.0, 1.0);\n    return lerp(distance2, distance1, h) - smoothFactor * h * (1.0 - h);\n}\n\nfloat2 dolphinAnimation(float position, float timeOffset)\n{\n    float adjustedTime = _Time.y + timeOffset;\n    float angle1 = 0.9 * (0.5 + 0.2 * position) * cos(5.0 * position - 3.0 * adjustedTime + 6.2831 / 4.0);\n    float angle2 = 1.0 * cos(3.5 * position - 1.0 * adjustedTime + 6.2831 / 4.0);\n    float jumping = 0.5 + 0.5 * cos(-0.4 + 0.5 * adjustedTime);\n    float finalAngle = lerp(angle1, angle2, jumping);\n    float thickness = 0.4 * cos(4.0 * position - 1.0 * adjustedTime) * (1.0 - 0.5 * jumping);\n    return float2(finalAngle, thickness);\n}\n\nfloat3 dolphinMovement(float timeOffset, float3 basePosition, float speed)\n{\n    float adjustedTime = _Time.y + timeOffset;\n    float jumping = 0.5 + 0.5 * cos(-0.4 + 0.5 * adjustedTime);\n\n    float3 movement1 = float3(0.0, sin(3.0 * adjustedTime + 6.2831 / 4.0), 0.0);\n    float3 movement2 = float3(0.0, 1.5 + 2.5 * cos(1.0 * adjustedTime), 0.0);\n    float3 finalMovement = lerp(movement1, movement2, jumping);\n    finalMovement.y *= 0.5;\n    finalMovement.x += 0.1 * sin(0.1 - 1.0 * adjustedTime) * (1.0 - jumping);\n\n    float3 worldOffset = float3(0.0, 0.0, fmod(-speed * _Time.y, 20.0) - 5.0);\n\n    return basePosition + finalMovement + worldOffset;\n}\n\n//returning: res.x: The signed distance from point p to the dolphin. res.y: A parameter h that stores a normalized position along the dolphin's body (used for further shaping/decorating).\nfloat2 dolphinDistance(float3 p, float3 position, float timeOffset, float speed)\n{\n\n    //initialize the result to a very large distance and an auxiliary value of 0. We'll minimize this value over the dolphin's body parts.\n    float2 result = float2(1000.0, 0.0);\n    float3 startPoint = dolphinMovement(timeOffset, position, speed);\n\n    float segmentNumberFloat = 11.0;\n    int segmentNumber = int(segmentNumberFloat);\n\n    float3 position1 = startPoint;\n    float3 position2 = startPoint;\n    float3 position3 = startPoint;\n    float3 direction1 = float3(0.0, 0.0, 0.0);\n    float3 direction2 = float3(0.0, 0.0, 0.0);\n    float3 direction3 = float3(0.0, 0.0, 0.0);\n    float3 closestPoint = startPoint;\n\n    for (int i = 0; i &lt; segmentNumber; i++)\n    {\n        float segmentPosition = float(i) / segmentNumberFloat;\n        float2 segmentAnimation = dolphinAnimation(segmentPosition, timeOffset);\n        float segmentLength = 0.48;\n        if (i == 0)\n            segmentLength = 0.655;\n        float3 endPoint = startPoint + segmentLength * normalize(float3(sin(segmentAnimation.y), sin(segmentAnimation.x), cos(segmentAnimation.x)));\n\n        float3 startToPoint = p - startPoint;\n        float3 startToEnd = endPoint - startPoint;\n        float projection = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n        float3 vectorToClosestPoint = startToPoint - projection * startToEnd;\n\n        float2 distance = float2(dot(vectorToClosestPoint, vectorToClosestPoint), projection);\n\n        if (distance.x &lt; result.x)\n        {\n            result = float2(distance.x, segmentPosition + distance.y / segmentNumberFloat);\n            closestPoint = startPoint + distance.y * (endPoint - startPoint);\n\n        }\n        //store Specific Segment Info for Fins and Tail\n        if (i == 3)\n        {\n            position1 = startPoint;\n            direction1 = endPoint - startPoint;\n        }\n        if (i == 4)\n        {\n            position3 = startPoint;\n            direction3 = endPoint - startPoint;\n        }\n        if (i == (segmentNumber - 1))\n        {\n            position2 = endPoint;\n            direction2 = endPoint - startPoint;\n        }\n        //move Forward to Next Segment\n        startPoint = endPoint;\n    }\n    float bodyRadius = result.y;\n    float radius = 0.05 + bodyRadius * (1.0 - bodyRadius) * (1.0 - bodyRadius) * 2.7;\n    radius += 7.0 * max(0.0, bodyRadius - 0.04) * exp(-30.0 * max(0.0, bodyRadius - 0.04)) * smoothstep(-0.1, 0.1, p.y - closestPoint.y);\n    radius -= 0.03 * (smoothstep(0.0, 0.1, abs(p.y - closestPoint.y))) * (1.0 - smoothstep(0.0, 0.1, bodyRadius));\n    radius += 0.05 * clamp(1.0 - 3.0 * bodyRadius, 0.0, 1.0);\n    radius += 0.035 * (1.0 - smoothstep(0.0, 0.025, abs(bodyRadius - 0.1))) * (1.0 - smoothstep(0.0, 0.1, abs(p.y - closestPoint.y)));\n    result.x = 0.75 * (distance(p, closestPoint)- radius);\n\n    //fin part\n    direction3 = normalize(direction3);\n    float k = sqrt(1.0 - direction3.y * direction3.y);\n    float3x3 ms = float3x3(\n            direction3.z / k, -direction3.x * direction3.y / k, direction3.x,\n            0.0, k, direction3.y,\n            -direction3.x / k, -direction3.y * direction3.z / k, direction3.z);\n    float3 ps = mul((p- position3), ms);\n    ps.z -= 0.1; // This is the offset for the fin\n\n    float distance5 = length(ps.yz) - 0.9;\n    distance5 = max(distance5, -(length(ps.yz - float2(0.6, 0.0)) - 0.35));\n    distance5 = max(distance5, distanceToBox(ps + float3(0.0, -0.5, 0.5), float3(0.0, 0.5, 0.5), 0.02));\n    result.x = smoothUnion(result.x, distance5, 0.1);\n\n    //fin \n    direction1 = normalize(direction1);\n    k = sqrt(1.0 - direction1.y * direction1.y);\n    ms = float3x3(\n            direction1.z / k, -direction1.x * direction1.y / k, direction1.x,\n            0.0, k, direction1.y,\n            -direction1.x / k, -direction1.y * direction1.z / k, direction1.z);\n\n    ps = p - position1;\n    ps = mul(ps, ms);\n    ps.x = abs(ps.x);\n    float l = ps.x;\n    l = clamp((l - 0.4) / 0.5, 0.0, 1.0);\n    l = 4.0 * l * (1.0 - l);\n    l *= 1.0 - clamp(5.0 * abs(ps.z + 0.2), 0.0, 1.0);\n    ps.xyz += float3(-0.2, 0.36, -0.2);\n    distance5 = length(ps.xz) - 0.8;\n    distance5 = max(distance5, -(length(ps.xz - float2(0.2, 0.4)) - 0.8));\n    distance5 = max(distance5, distanceToBox(ps + float3(0.0, 0.0, 0.0), float3(1.0, 0.0, 1.0), 0.015 + 0.05 * l));\n    result.x = smoothUnion(result.x, distance5, 0.12);\n\n    //tail part\n    direction2 = normalize(direction2);\n    float2x2 mf = float2x2(\n            direction2.z, direction2.y,\n            -direction2.y, direction2.z);\n    float3 pf = p - position2 - direction2 * 0.25;\n    pf.yz = mul(pf.yz, mf);\n    float distance4 = length(pf.xz) - 0.6;\n    distance4 = max(distance4, -(length(pf.xz - float2(0.0, 0.8)) - 0.9));\n    distance4 = max(distance4, distanceToBox(pf, float3(1.0, 0.005, 1.0), 0.005));\n    result.x = smoothUnion(result.x, distance4, 0.1);\n\n    return result;\n}\n</code></pre> <pre><code>void addDolphin_float(int index, float3 position, float timeOffset, float speed, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, out int indexOut)\n{\n    addSDF(index, 6, position, float3(0.0, 0.0, 0.0), 9, axis, angle, 0, baseColor, specularColor, specularStrength, shininess, timeOffset, speed);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/dolphin/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/dolphin/#inputs","title":"Inputs:","text":"Name Type Description <code>index</code> int Index at which the dolphin is stored <code>position</code> float3 Central position <code>timeOffset</code> float Time at which the dolphin is first seen in the sceen <code>speed</code> float Speed at which the dolphin moves  ShaderGraph default value: 1 <code>axis</code> float3 Axis determining the orientation  ShaderGraph default value: float3(0,1,0) <code>angle</code> float World-space position of the light source <code>baseColor</code> float3 Underlying color  ShaderGraph default value: float3() <code>specularColor</code> float3 Color of the highlights <code>specularStrength</code> float Intensity with which highlights are created  ShaderGraph default value: 1 <code>shininess</code> float Shape and sharpness of the highlights; the larger the value, the more focussed the highlight   ShaderGraph default value: 32 <p>Even when the speed is set to zero, the dolphin will make an up-down movement. It will simply not move forwards.</p>"},{"location":"engines/unity/sdfs/dolphin/#outputs","title":"Outputs:","text":"Name Type Description <code>indexOut</code> int Incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching"},{"location":"engines/unity/sdfs/dolphin/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Dolphin</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addDolphin_float(index, float3(3,-0.5,8), 1, 2, float3(0, 1, 0), 45, float3(0.2,0.5,0.2), float3(0.2,0.5,0.2), 1, 1, index);\n</code></pre> <p>Find the original shader code here.</p>"},{"location":"engines/unity/sdfs/ellipsoid/","title":"Ellipsoid","text":"SDF Ellipsoid by Frieda Hentschel <p>This function creates an internal instance of an SDF-based ellipsoid. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/ellipsoid/#the-code","title":"The Code","text":"<pre><code>float sdEllipsoid(float3 position, float3 r)\n{\n    float k0 = length(position / r);\n    float k1 = length(position / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nvoid addEllipsoid_float(int index, float3 position, float3 size, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 3, position, size, 0, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/ellipsoid/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/ellipsoid/#inputs","title":"Inputs:","text":"Name Type Description <code>index</code> int Index at which the ellipsoid is stored <code>position</code> float3 Central position <code>size</code> float3 Expand in each of the three dimensions  ShaderGraph default value: float3(1,1,1) <code>axis</code> float3 Axis determining the orientation  ShaderGraph default value: float3(0,1,0) <code>angle</code> float World-space position of the light source <code>baseColor</code> float3 Underlying color  ShaderGraph default value: float3() <code>specularColor</code> float3 Color of the highlights <code>specularStrength</code> float Intensity with which highlights are created  ShaderGraph default value: 1 <code>shininess</code> float Shape and sharpness of the highlights; the larger the value, the more focussed the highlight   ShaderGraph default value: 32 <code>noise</code> float Noise that is added to the shape of the ellipsoid <p>Naturally, the sphere can be imitated by the ellipsoid by setting its size to be uniform.</p>"},{"location":"engines/unity/sdfs/ellipsoid/#outputs","title":"Outputs:","text":"Name Type Description <code>indexOut</code> int Incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching"},{"location":"engines/unity/sdfs/ellipsoid/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Ellipsoid</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addEllipsoid_float(index, float3(0, 1, -3), float3(1.5, 1.0, 0.5), float3(0, 1, 0), 0, float3(0.3, 0.6, 0.9), float3(1, 1, 1), 1.0, 32.0, 0.0, index);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/sdfs/generalInformation/","title":"General Information","text":"SDFs in Unity by Frieda Hentschel <p>Due to engine-restrictions, some adjustments to the shader library's implemenation were made in order to achieve the same output. </p>"},{"location":"engines/unity/sdfs/generalInformation/#storage","title":"Storage","text":"<p>Since Unity's ShaderGraph does not support arrays of structs, the struct <code>SDF</code> was split into its separate parameters. Each parameter is stored within its own array. The exact setup of the arrays can be found in the Global Variables. </p> <p>Arrays in their very nature are not modifyable in their size. Thus, a pre-defined size had to be chosen which determines the maximum amount of SDFs that can be added to a scene. For this implementation, that size was set to 20. </p>"},{"location":"engines/unity/sdfs/generalInformation/#instantiation","title":"Instantiation","text":"<p>Furthermore, ShaderGraph does not allow the access of arrays using input parameters, non-static, and non-constant variables. Thus, to fill the arrays, a work-around using for-loops was implemented. Each SDF uses an index to determine the location that it will be stored in. Subsequently, a loop iterates over all possible indices and writes the inputs once the correct index has been reached.</p> <p>To allow for proper processing, the output-indices should be used as input-indices for the following SDF thus connecting the functions in series. The last SDF's output-index should be connected to the number of SDFs in the SDF Raymarching. This setup also ensures that, in case ShaderGraph is used, all nodes are connected to the graph.</p> <p>Additionally, each SDF is defined by a type. The values for the types can be found in the code for the respective SDFs and the SDF Raymarching.</p> <p>The instantiation of an SDF is implemented as follows:</p> <pre><code>void addSDF(int index, int type, float3 position, float3 size, float radius, float3 axis, float angle, float noise, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float timeOffset, float speed){\n    for (int i = 0; i &lt;= MAX_OBJECTS; i++)\n    {\n        if (i == index)\n        {\n            _sdfType[i] = type;\n            _sdfPosition[i] = position;\n            _sdfSize[i] = size;\n            _sdfRadius[i] = radius;\n            _sdfRotation[i] = computeRotationMatrix(normalize(axis), angle * PI / 180);\n            _sdfNoise[i] = noise;\n\n            _objectBaseColor[i] = baseColor;\n            _objectSpecularColor[i] = specularColor;\n            _objectSpecularStrength[i] = specularStrength;\n            _objectShininess[i] = shininess;\n\n            _timeOffsetDolphin[i] = timeOffset;\n            _speedDolphin[i] = speed;\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"engines/unity/sdfs/generalInformation/#example-connectivity","title":"Example Connectivity","text":"Visual ScriptingStandard Scripting <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float index;\n\naddSphere_float(0, float3(-2,0,-5), float3(2,2,2), float3(0.8,0.1,0.1), 0, float3(0.8,0.1,0.1), float3(0.1,0.1,0.8), 2, 1, 0, index);\n\naddRoundBox_float(index, float3(5,0,-5), float3(2,2,2), 1, float3(0.8,0.1,0.1), 0, float3(0.2,0.2,0.8), float3(0.2,0.8,0.8), 2, 1, 0, index);\n\naddTorus_float(index, float3(0,4.5,0), 2, 0.2, float3(0.8,0.1,0.1), 45, float3(0.2,0.5,0.2), float3(0.8,0.1,0.1), 2, 1, 0, index);\naddTorus_float(index, float3(-4.5,4.5,0), 2, 0.2, float3(0.8,0.1,0.1), 0, float3(0.2,0.5,0.2), float3(0.8,0.1,0.1), 2, 1, 0, index);\naddTorus_float(index, float3(-1.5,4.5,0), 2, 0.2, float3(0.8,0.1,0.1), 90, float3(0.2,0.5,0.2), float3(0.8,0.1,0.1), 2, 1, 0, index);\naddTorus_float(index, float3(4.5,4.5,0), 2, 0.2, float3(0.8,0.1,0.1), 0, float3(0.2,0.5,0.2), float3(0.8,0.1,0.1), 2, 1, 0, index);\n\naddDolphin_float(index, float3(3,-0.5,8), 1, 2, float3(0, 1, 0), 45, float3(0.2,0.5,0.2), float3(0.2,0.5,0.2), 1, 1, index);\n</code></pre>"},{"location":"engines/unity/sdfs/hexPrism/","title":"Hexagonal Prism","text":"SDF Hexagonal Prism by Frieda Hentschel <p>This function creates an internal instance of an SDF-based hexagonal prism. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/hexPrism/#the-code","title":"The Code","text":"<pre><code>float sdHexPrism(float3 position, float2 height)\n{\n    const float3 k = float3(-0.8660254, 0.5, 0.57735);\n    position = abs(position);\n    position.xy -= 2.0 * min(dot(k.xy, position.xy), 0.0) * k.xy;\n    float2 d = float2(\n       length(position.xy - float2(clamp(position.x, -k.z * height.x, k.z * height.x), height.x)) * sign(position.y - height.x),\n       position.z - height.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvoid addHexPrism_float(int index, float3 position, float height, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 4, position, float3(0.0, 0.0, 0.0), height, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/hexPrism/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/hexPrism/#inputs","title":"Inputs:","text":"<ul> <li><code>float index</code>: The index at which the hexagonal prism is stored </li> <li><code>float3 position</code>: The central position of the hexagonal prism</li> <li><code>float height</code>: The height of the hexagonal prism <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 axis</code>: The axis determining the orientation of the hexagonal prism <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float angle</code>: The angle around the axis </li> <li>Material parameters<ul> <li><code>float3 baseColor</code>: The underlying color of the hexagonal prism <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float3 specularColor</code>: The color of the highlights</li> <li><code>float3 specularStrength</code>: The intensity with which highlights are created <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 shininess</code>: The shape and sharpness of the highlights; the larger the value, the more focussed the highlight <p>ShaderGraph default value: <code>32</code></p> </li> </ul> </li> <li><code>float3 noise</code>: Noise that is added to the shape of the hexagonal prism</li> </ul>"},{"location":"engines/unity/sdfs/hexPrism/#outputs","title":"Outputs:","text":"<ul> <li><code>float indexOut</code>: The incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching.  </li> </ul>"},{"location":"engines/unity/sdfs/hexPrism/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/HexPrism</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addHexPrism_float(index, float3(2, 0, -4), 3.0, float3(0, 1, 0), 30.0, float3(0.6, 0.3, 0.1), float3(1, 1, 1), 0.8, 16.0, 0.1, index);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/sdfs/octahedron/","title":"Octahedron","text":"SDF Octahedron by Frieda Hentschel <p>This function creates an internal instance of an SDF-based octahedron. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/octahedron/#the-code","title":"The Code","text":"<pre><code>float sdOctahedron(float3 position, float s)\n{\n    position = abs(position);\n    return (position.x + position.y + position.z - s) * 0.57735027;\n}\n\nvoid addOctahedron_float(int index, float3 position, float radius, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 5, position, float3(0.0, 0.0, 0.0), radius, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/octahedron/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/octahedron/#inputs","title":"Inputs:","text":"<ul> <li><code>float index</code>: The index at which the octahedron is stored </li> <li><code>float3 position</code>: The central position of the octahedron</li> <li><code>float radius</code>: The radius of the octahedron <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 axis</code>: The axis determining the orientation of the octahedron <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float angle</code>: The angle around the axis </li> <li>Material parameters<ul> <li><code>float3 baseColor</code>: The underlying color of the octahedron <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float3 specularColor</code>: The color of the highlights</li> <li><code>float3 specularStrength</code>: The intensity with which highlights are created <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 shininess</code>: The shape and sharpness of the highlights; the larger the value, the more focussed the highlight <p>ShaderGraph default value: <code>32</code></p> </li> </ul> </li> <li><code>float3 noise</code>: Noise that is added to the shape of the octahedron</li> </ul>"},{"location":"engines/unity/sdfs/octahedron/#outputs","title":"Outputs:","text":"<ul> <li><code>float indexOut</code>: The incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching.  </li> </ul>"},{"location":"engines/unity/sdfs/octahedron/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Octahedron</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addOctahedron_float(index, float3(-2, 1, -6), 1.2, float3(1, 0, 0), 45.0, float3(0.7, 0.2, 0.5), float3(1, 1, 1), 0.5, 32.0, 0.05, index);\n</code></pre> <p>This is an engine-specific implementation without a shader-basis.</p>"},{"location":"engines/unity/sdfs/raymarching/","title":"SDF Raymarching","text":"SDF Raymarching by Frieda Hentschel <p>This function performs raymarching considering all previously instantiated SDFs.</p>"},{"location":"engines/unity/sdfs/raymarching/#the-code","title":"The Code","text":"<pre><code>float evalSDF(int index, float3 position)\n{\n    int sdfType = _sdfType[index];\n    float3 probePt = mul((position - _sdfPosition[index]), _sdfRotation[index]);\n\n    if (sdfType == 0)\n        return sdSphere(probePt, _sdfRadius[index]);\n    else if (sdfType == 1)\n        return sdRoundBox(probePt, _sdfSize[index], _sdfRadius[index]);\n    else if (sdfType == 2)\n        return sdTorus(probePt, _sdfSize[index].yz);\n    else if (sdfType == 3)\n        return sdEllipsoid(probePt, _sdfSize[index]);\n    else if (sdfType == 4)\n        return sdHexPrism(probePt, _sdfRadius[index]);\n    else if (sdfType == 5)\n        return sdOctahedron(probePt, _sdfRadius[index]);\n    else if (sdfType == 6)\n        return dolphinDistance(probePt, _sdfPosition[index], _timeOffsetDolphin[index], _speedDolphin[index]).x;\n    return 1e5;\n}\n\nvoid raymarch_float(int condition, float3x3 cameraMatrix, int numberSDFs, float2 fragmentCoordinates, out float4 hitPosition, out float3 normal, out int hitIndex, out float3 rayDirection)\n{\n    if (condition == 0)\n    {\n        cameraMatrix = computeCameraMatrix(float3(0, 0, 0), _rayOrigin, float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1));\n    }\n\n    rayDirection = normalize(mul(float3(fragmentCoordinates, -1), cameraMatrix));\n    float t = 0.0;\n    hitPosition = float4(0, 0, 0, 0);\n    for (int i = 0; i &lt; 100; i++)\n    {\n        float3 currentPosition = _rayOrigin + rayDirection * t; \n        float d = 1e5;\n        int bestIndex = -1;\n        for (int j = 0; j &lt; numberSDFs; ++j)\n        {\n            float dj = evalSDF(j, currentPosition);\n            if (dj &lt; d)\n            {\n                d = dj; \n                bestIndex = j;\n            }\n        }\n        hitIndex = bestIndex;\n        d += _sdfNoise[hitIndex] * 0.3;\n        if (d &lt; 0.001)\n        {\n            hitPosition.xyz = currentPosition;\n            normal = getNormal(hitIndex, currentPosition);\n            break;\n        }\n        if (t &gt; _raymarchStoppingCriterium)\n        {\n            hitPosition.xyz = currentPosition;\n            break;\n        }\n        t += d;\n    }\n    hitPosition.w = t;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/raymarching/#the-parameters","title":"The Parameters","text":"<p>float condition, float3x3 cameraMatrix, float numberSDFs, float2 fragmentCoordinates, out float4 hitPosition, out float3 normal, out int hitIndex, out float3 rayDirection</p>"},{"location":"engines/unity/sdfs/raymarching/#inputs","title":"Inputs:","text":"<ul> <li><code>float condition</code>: A value that is used to check whether the default camera matrix should be computed or a custom camera matrix has been put in.<ul> <li>condition = 0: The default camera matrix should be computed</li> <li>condition = 1: A custom camera matrix has been added</li> </ul> </li> <li><code>float3x3 cameraMatrix</code>: The camera matrix <p>Can be aquired using Camera Matrix</p> </li> <li><code>float numberSDFs</code>: The amount of SDFs that are in the scene <p>Should be aquired as the output of the SDF which is instanciated last.</p> </li> <li><code>float2 fragCoordinates</code>: The fragment's coordinates <p>Can be aquired using Fragment Coordinates</p> </li> </ul>"},{"location":"engines/unity/sdfs/raymarching/#outputs","title":"Outputs:","text":"<ul> <li><code>float4 hitPosition</code>: The first three dimensions contain the position at which the water has been hit. The w-component contains the raymarching parameter at which the hit occured. This is required in order to be able to combine the water with other visual elements.</li> <li><code>float3 normal</code>: The normal at the hit position</li> <li><code>float hitIndex</code>: A value determining what surface has been hit. The water gets a hard-coded hitIndex.</li> <li><code>float3 rayDirection</code>: The ray direction from the camera to the hit position</li> </ul>"},{"location":"engines/unity/sdfs/raymarching/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Raymarching</code></p> <p> </p> <p>Due to internal workings of the node, the condition-input is not required. Within the SubGraph a Branch On Input Connection node is used to determine whether a camera matrix was connected to its respective input. This in turn determines the condition-value.</p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>raymarch_float(1, camMat, index, uv, hitPos1, normal1, hitID1, rayDir1);\n</code></pre> <p>Find the original shader code here.</p>"},{"location":"engines/unity/sdfs/sphere/","title":"Sphere","text":"SDF Sphere by Frieda Hentschel <p>This function creates an internal instance of an SDF-based sphere. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/sphere/#the-code","title":"The Code","text":"<pre><code>float sdSphere(float3 position, float radius)\n{\n    return length(position) - radius;\n}\n\nvoid addSphere_float(int index, float3 position, float radius, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 0, position, float3(0,0,0), radius, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/sphere/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/sphere/#inputs","title":"Inputs:","text":"<ul> <li><code>float index</code>: The index at which the sphere is stored </li> <li><code>float3 position</code>: The central position of the sphere</li> <li><code>float radius</code>: The radius of the sphere <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 axis</code>: The axis determining the orientation of the sphere <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float angle</code>: The angle around the axis </li> <li>Material parameters<ul> <li><code>float3 baseColor</code>: The underlying color of the sphere <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float3 specularColor</code>: The color of the highlights</li> <li><code>float3 specularStrength</code>: The intensity with which highlights are created <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 shininess</code>: The shape and sharpness of the highlights; the larger the value, the more focussed the highlight <p>ShaderGraph default value: <code>32</code></p> </li> </ul> </li> <li><code>float3 noise</code>: Noise that is added to the shape of the sphere</li> </ul>"},{"location":"engines/unity/sdfs/sphere/#outputs","title":"Outputs:","text":"<ul> <li><code>float indexOut</code>: The incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching.  </li> </ul>"},{"location":"engines/unity/sdfs/sphere/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Sphere</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addSphere_float(index, float3(-2,0,-5), float3(2,2,2), float3(0.8,0.1,0.1), 0, float3(0.8,0.1,0.1), float3(0.1,0.1,0.8), 2, 1, 0, index);\n</code></pre> <p>Find the original shader code here.</p>"},{"location":"engines/unity/sdfs/torus/","title":"Torus","text":"SDF Torus by Frieda Hentschel <p>This function creates an internal instance of an SDF-based torus. In order for the cube to be visible in the final output, SDF Raymarching and an arbitrary Lighting Function have to be included. </p>"},{"location":"engines/unity/sdfs/torus/#the-code","title":"The Code","text":"<pre><code>// radius.x is the major radius, radius.y is the thickness\nfloat sdTorus(float3 position, float2 radius)\n{\n    float2 q = float2(length(position.xy) - radius.x, position.z);\n    return length(q) - radius.y;\n}\n\nvoid addTorus_float(int index, float3 position, float radius, float thickness, float3 axis, float angle, float3 baseColor, float3 specularColor, float specularStrength,\nfloat shininess, float noise, out int indexOut)\n{\n    addSDF(index, 2, position, float3(0, radius, thickness), 0, axis, angle, noise, baseColor, specularColor, specularStrength, shininess, 0, 0);\n    indexOut = index + 1;\n}\n</code></pre>"},{"location":"engines/unity/sdfs/torus/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/sdfs/torus/#inputs","title":"Inputs:","text":"<ul> <li><code>float index</code>: The index at which the torus is stored </li> <li><code>float3 position</code>: The central position of the torus</li> <li><code>float radius</code>: The radius of the torus from center to the very outside of the tube <p>ShaderGraph default value: <code>3</code></p> </li> <li><code>float thickness</code>: The thickness of the torus' tube <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 axis</code>: The axis determining the orientation of the torus <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float angle</code>: The angle around the axis </li> <li>Material parameters<ul> <li><code>float3 baseColor</code>: The underlying color of the torus <p>ShaderGraph default value: <code>float3(0,1,0)</code></p> </li> <li><code>float3 specularColor</code>: The color of the highlights</li> <li><code>float3 specularStrength</code>: The intensity with which highlights are created <p>ShaderGraph default value: <code>1</code></p> </li> <li><code>float3 shininess</code>: The shape and sharpness of the highlights; the larger the value, the more focussed the highlight <p>ShaderGraph default value: <code>32</code></p> </li> </ul> </li> <li><code>float3 noise</code>: Noise that is added to the shape of the torus</li> </ul>"},{"location":"engines/unity/sdfs/torus/#outputs","title":"Outputs:","text":"<ul> <li><code>float indexOut</code>: The incremented input index that can be used as either the input index to another SDF function or as the amount of SDFs in the scene to the SDF Raymarching.  </li> </ul>"},{"location":"engines/unity/sdfs/torus/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/SDFs/Torus</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/sdf_functions.hlsl\"</code></p> <p>Example Usage</p> <pre><code>addTorus_float(index, float3(0,4.5,0), 2, 0.2, float3(0.8,0.1,0.1), 45, float3(0.2,0.5,0.2), float3(0.8,0.1,0.1), 2, 1, 0, index);\n</code></pre> <p>Find the original shader code here.</p>"},{"location":"engines/unity/water/waterHeight/","title":"Water Height","text":"Sample Water Height by Frieda Hentschel <p>This function computes the height of the water environment using raymarching. It takes an arbitrary input position and returns that very position moved to the correct height. This is useful to place objects on the Water Surface.</p>"},{"location":"engines/unity/water/waterHeight/#the-code","title":"The Code","text":"Water Related Helper Functions <pre><code>float waveStrength = 0.0;\n\nfloat2x2 compute2DRotationMatrix(float angle)\n{\n    float c = cos(angle), s = sin(angle);\n    return float2x2(c, s, -s, c);\n}\n\nfloat hashNoise(float3 p)\n{\n    float3 f = floor(p), magic = float3(7, 157, 113);\n    p -= f;\n    float4 h = float4(0, magic.yz, magic.y + magic.z) + dot(f, magic);\n    p *= p * (3.0 - 2.0 * p);\n    h = lerp(frac(sin(h) * 43785.5), frac(sin(h + magic.x) * 43785.5), p.x);\n    h.xy = lerp(h.xz, h.yw, p.y);\n    return lerp(h.x, h.y, p.z);\n}\n\nfloat computeWave(float3 position)\n{\n    float3 warped = position - float3(0, 0, _Time.y % 62.83 * 3.0);\n\n    float direction = sin(_Time.y * 0.15);\n    float angle = 0.001 * direction;\n    float2x2 rotation = compute2DRotationMatrix(angle);\n\n    float accumulated = 0.0, amplitude = 3.0;\n    for (int i = 0; i &lt; 7; i++)\n    {\n        accumulated += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * (amplitude *= 0.51);\n        warped.xy = mul(warped.xy, rotation);\n        warped *= 1.75;\n    }\n\n    waveStrength = accumulated;\n\n    float height = position.y + accumulated;\n    height *= 0.5;\n    height += 0.3 * sin(_Time.y + position.x * 0.3); // slight bobbing\n    return height;\n}\n</code></pre> <pre><code>void sampleHeightField_float(float3 seedPosition, out float3 heightPosition)\n{\n    float y = 0;\n    float stepSize = 0.05; \n\n    for (int i = 0; i &lt; 100; i++)\n    {\n        seedPosition.y = y;\n        float height = computeWave(seedPosition);\n        if (height &lt; 0.01)\n            break;\n        y -= stepSize;\n    }\n    heightPosition = float3(seedPosition.x, y, seedPosition.z);\n}\n</code></pre>"},{"location":"engines/unity/water/waterHeight/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/water/waterHeight/#inputs","title":"Inputs:","text":"Name Type Description <code>seedPosition</code> float3 Seed position for which the height of the water surface is computed"},{"location":"engines/unity/water/waterHeight/#outputs","title":"Outputs:","text":"Name Type Description <code>heightPosition</code> float3 Original position moved to the correct height of the water. This position can be plugged into the position-input of an SDF function (e.g. Sphere) or lighting functions (e.g. Point Light) in order to place then on top of the water's surface."},{"location":"engines/unity/water/waterHeight/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Environments/Water Height Field</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/water_surface.hlsl\"</code></p> <p>Example Usage</p> <pre><code>sampleHeightField_float(float3(0,0,0), waterSurfacePos);\n</code></pre> <p>This is an engine-specific extension to the shader code's water shader which can be found here.</p>"},{"location":"engines/unity/water/waterNormal/","title":"Water Normal","text":"Sample Water Normal by Frieda Hentschel <p>This function computes the normal of the water surface at a given position. It can be used to adjust an objects orientation to match up with the water. </p> <p>Due to the normal of the water surface changing very rapidly, an approach was implemented that samples four normals with a distance of sampleRadius to the position in the x-z-plane. Their average is taken. To additionally smooth out the rapid change, the normal's influence can be adjusted.</p>"},{"location":"engines/unity/water/waterNormal/#the-code","title":"The Code","text":"Water Related Helper Functions <pre><code>float waveStrength = 0.0;\n\nfloat2x2 compute2DRotationMatrix(float angle)\n{\n    float c = cos(angle), s = sin(angle);\n    return float2x2(c, s, -s, c);\n}\n\nfloat hashNoise(float3 p)\n{\n    float3 f = floor(p), magic = float3(7, 157, 113);\n    p -= f;\n    float4 h = float4(0, magic.yz, magic.y + magic.z) + dot(f, magic);\n    p *= p * (3.0 - 2.0 * p);\n    h = lerp(frac(sin(h) * 43785.5), frac(sin(h + magic.x) * 43785.5), p.x);\n    h.xy = lerp(h.xz, h.yw, p.y);\n    return lerp(h.x, h.y, p.z);\n}\n\nfloat computeWave(float3 position)\n{\n    float3 warped = position - float3(0, 0, _Time.y % 62.83 * 3.0);\n\n    float direction = sin(_Time.y * 0.15);\n    float angle = 0.001 * direction;\n    float2x2 rotation = compute2DRotationMatrix(angle);\n\n    float accumulated = 0.0, amplitude = 3.0;\n    for (int i = 0; i &lt; 7; i++)\n    {\n        accumulated += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * (amplitude *= 0.51);\n        warped.xy = mul(warped.xy, rotation);\n        warped *= 1.75;\n    }\n\n    waveStrength = accumulated;\n\n    float height = position.y + accumulated;\n    height *= 0.5;\n    height += 0.3 * sin(_Time.y + position.x * 0.3); // slight bobbing\n    return height;\n}\n\nfloat3 getNormal(float3 position, float delta)\n{\n    return normalize(float3(\n            computeWave(position + float3(delta, 0.0, 0.0)) -\n            computeWave(position - float3(delta, 0.0, 0.0)),\n            0.02,\n            computeWave(position + float3(0.0, 0.0, delta)) -\n            computeWave(position - float3(0.0, 0.0, delta))\n        ));\n}\n\nfloat4 traceWater(float3 rayDirection)\n{\n    float d = 0;\n    float t = 0;\n    float3 hitPosition = float3(0, 0, 0);\n    float3 outputPos;\n    for (int i = 0; i &lt; 100; i++)\n    {\n        float3 p = _rayOrigin + rayDirection * t;\n        d = computeWave(p);\n        if (d &lt; 0.0001)\n        {\n            hitPosition = p;\n            break;\n        }\n        t += d;\n        if (t &gt; _raymarchStoppingCriterium)\n            break;\n    }\n    return float4(hitPosition, t);\n}\n\nfloat3 getNormal(float3 position, float delta)\n{\n    return normalize(float3(\n            computeWave(position + float3(delta, 0.0, 0.0)) -\n            computeWave(position - float3(delta, 0.0, 0.0)),\n            0.02,\n            computeWave(position + float3(0.0, 0.0, delta)) -\n            computeWave(position - float3(0.0, 0.0, delta))\n        ));\n}\n</code></pre> <pre><code>void adaptableNormal_float(float3 position, float3 offset, float influence, float sampleRadius, out float3 normal)\n{\n    float3 normal1 = getNormal(position + float3(sampleRadius, 0.0, 0.0), 1);\n    float3 normal2 = getNormal(position - float3(sampleRadius, 0.0, 0.0), 1);\n    float3 normal3 = getNormal(position + float3(0, 0.0, sampleRadius), 1);\n    float3 normal4 = getNormal(position - float3(0, 0.0, sampleRadius), 1);\n    normal = influence * (normal1 + normal2 + normal3 + normal4)/4 + offset;\n}\n</code></pre>"},{"location":"engines/unity/water/waterNormal/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/water/waterNormal/#inputs","title":"Inputs:","text":"Name Type Description <code>position</code> float3 Position at which the normal is to be sampled <code>offset</code> float3 Offset axis that is added to the computed normal to allow for object rotation's to be applied on top of this normal <code>influence</code> float Amount with which the water's normal contributes to the output. Typically a value between 0 and 1  ShaderGraph default value: 1 <code>sampleRadius</code> float Distance at which four normals are sampled in x- and z-direction"},{"location":"engines/unity/water/waterNormal/#outputs","title":"Outputs:","text":"Name Type Description <code>normal</code> float3 Adjusted normal at the inputted position. The vector can be used as an axis for an SDF function (e.g. Sphere). The normal is not normalised due to the normalisation occuring in later computations <p>To get the true normal at a given position, set <code>influence=1</code> and <code>sampleRadius=0</code>.</p>"},{"location":"engines/unity/water/waterNormal/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Environments/Water Normal</code></p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/water_surface.hlsl\"</code></p> <p>Example Usage</p> <pre><code>float3 adjustedNormal;\nadaptableNormal_float(float3(0,0,0), float3(0,0,0), 1, 0, adjustedNormal);\n</code></pre> <p>This is an engine-specific extension to the shader code's water shader which can be found here.</p>"},{"location":"engines/unity/water/waterSurface/","title":"Water Surface","text":"Water Surface by Frieda Hentschel <p>This function computes a water surface through raymarching a height field. </p>"},{"location":"engines/unity/water/waterSurface/#the-code","title":"The Code","text":"Water Related Helper Functions <pre><code>float waveStrength = 0.0;\n\nfloat2x2 compute2DRotationMatrix(float angle)\n{\n    float c = cos(angle), s = sin(angle);\n    return float2x2(c, s, -s, c);\n}\n\nfloat hashNoise(float3 p)\n{\n    float3 f = floor(p), magic = float3(7, 157, 113);\n    p -= f;\n    float4 h = float4(0, magic.yz, magic.y + magic.z) + dot(f, magic);\n    p *= p * (3.0 - 2.0 * p);\n    h = lerp(frac(sin(h) * 43785.5), frac(sin(h + magic.x) * 43785.5), p.x);\n    h.xy = lerp(h.xz, h.yw, p.y);\n    return lerp(h.x, h.y, p.z);\n}\n\nfloat computeWave(float3 position)\n{\n    float3 warped = position - float3(0, 0, _Time.y % 62.83 * 3.0);\n\n    float direction = sin(_Time.y * 0.15);\n    float angle = 0.001 * direction;\n    float2x2 rotation = compute2DRotationMatrix(angle);\n\n    float accumulated = 0.0, amplitude = 3.0;\n    for (int i = 0; i &lt; 7; i++)\n    {\n        accumulated += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * (amplitude *= 0.51);\n        warped.xy = mul(warped.xy, rotation);\n        warped *= 1.75;\n    }\n\n    waveStrength = accumulated;\n\n    float height = position.y + accumulated;\n    height *= 0.5;\n    height += 0.3 * sin(_Time.y + position.x * 0.3); // slight bobbing\n    return height;\n}\n\nfloat3 getNormal(float3 position, float delta)\n{\n    return normalize(float3(\n            computeWave(position + float3(delta, 0.0, 0.0)) -\n            computeWave(position - float3(delta, 0.0, 0.0)),\n            0.02,\n            computeWave(position + float3(0.0, 0.0, delta)) -\n            computeWave(position - float3(0.0, 0.0, delta))\n        ));\n}\n\nfloat4 traceWater(float3 rayDirection)\n{\n    float d = 0;\n    float t = 0;\n    float3 hitPosition = float3(0, 0, 0);\n    float3 outputPos;\n    for (int i = 0; i &lt; 100; i++)\n    {\n        float3 p = _rayOrigin + rayDirection * t;\n        d = computeWave(p);\n        if (d &lt; 0.0001)\n        {\n            hitPosition = p;\n            break;\n        }\n        t += d;\n        if (t &gt; _raymarchStoppingCriterium)\n            break;\n    }\n    return float4(hitPosition, t);\n}\n</code></pre> <pre><code>void computeWater_float(int condition, float3x3 cameraMatrix, float2 fragmentCoordinates, out float4 hitPosition, out float3 normal, out float hitIndex, out float3 rayDirection)\n{\n    if (condition == 0)\n    {\n        cameraMatrix = computeCameraMatrix(float3(0, 0, 0), _rayOrigin, float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1));\n    }\n\n    rayDirection = normalize(mul(float3(fragmentCoordinates, -1), cameraMatrix));\n\n    //default background color\n    float3 baseColor = float3(0.05, 0.07, 0.1);\n    float3 color = baseColor;\n\n    hitPosition = traceWater(rayDirection);\n    if (hitPosition.w &lt; _raymarchStoppingCriterium)\n    {\n        normal = getNormal(hitPosition.xyz, 0.01);\n\n        //fresnel-style highlight\n        float fresnel = pow(1.0 - dot(normal, -rayDirection), 5.0);\n        float highlight = clamp(fresnel * 1.5, 0.0, 1.0);\n\n        //water shading: deep vs bright\n        float3 deepColor = float3(0.05, 0.1, 0.6);\n        float3 brightColor = float3(0.1, 0.3, 0.9);\n        float shading = clamp(waveStrength * 0.1, 0.0, 1.0);\n        float3 waterColor = lerp(deepColor, brightColor, shading);\n\n        //add highlight\n        waterColor += float3(1.0, 1, 1) * highlight * 0.4;\n\n        //depth-based fog\n        float fog = exp(-0.00005 * hitPosition.x * hitPosition.x * hitPosition.x);\n        color = lerp(baseColor, waterColor, fog);\n    }\n\n    //gamma correction\n    _objectBaseColor[MAX_OBJECTS] = pow(color, float3(0.55, 0.55, 0.55));\n    _objectSpecularColor[MAX_OBJECTS] = pow(color, float3(0.55, 0.55, 0.55));\n    _objectSpecularStrength[MAX_OBJECTS] = 1;\n    _objectShininess[MAX_OBJECTS] = 32;\n    //hard-coded hit-index for the water\n    hitIndex = MAX_OBJECTS;\n}\n</code></pre> <p>See Helper Functions to find out more about <code>computeCameraMatrix(float3 lookAtPosition, float3 eye, float3x3 mat)</code>.</p> <p>Read about setting the water's material-values and hit-index at Lighting General Information.</p>"},{"location":"engines/unity/water/waterSurface/#the-parameters","title":"The Parameters","text":""},{"location":"engines/unity/water/waterSurface/#inputs","title":"Inputs:","text":"Name Type Description <code>condition</code> int A value that is used to check whether the default camera matrix should be computed or a custom camera matrix has been put in   condition = 0: The default camera matrix should be computed   condition = 1: A custom camera matrix has been added  <code>cameraMatrix</code> float3x3 Camera matrix  Can be aquired using Camera Matrix <code>fragmentCoordinates</code> float2 The fragment's coordinates  Can be aquired using Fragment Coordinates"},{"location":"engines/unity/water/waterSurface/#outputs","title":"Outputs:","text":"Name Type Description <code>hitPosition</code> float4 The first three dimensions contain the position at which the water has been hit. The w-component contains the raymarching parameter at which the hit occured. This is required in order to be able to combine the water with other visual elements. <code>normal</code> float3 Normal at the hit position <code>hitIndex</code> int A value determining what surface has been hit. The water gets a hard-coded hitIndex. <code>rayDirection</code> float3 Ray direction from the camera to the hit position <p>All outputs are to be plugged into a Combine Color or an arbitrary Lighting Function.</p>"},{"location":"engines/unity/water/waterSurface/#implementation","title":"Implementation","text":"Visual ScriptingStandard Scripting <p>Find the node at <code>PSF/Environments/Water Surface</code></p> <p> </p> <p>Due to internal workings of the node, the condition-input is not required. Within the SubGraph a Branch On Input Connection node is used to determine whether a camera matrix was connected to its respective input. This in turn determines the condition-value.</p> <p> </p> <p>Include - <code>#include \"Packages/com.tudresden.proceduralshaderframeworkpackage/Runtime/scripts/water_surface.hlsl\"</code></p> <p>Example Usage</p> <pre><code>computeWater_float(1, camMat, uv, hitPos, normal, hitID, rayDir);\n</code></pre> <p>Find the original shader code here. This basis was adapted to be compatible with Unity's workflow and to allow it to be modifyable within the framework.</p>"},{"location":"shaders/general_structure/","title":"General Structure Shader","text":"<ul> <li>Category: General Structure</li> <li>Author: Saeed Shamseldin</li> </ul>"},{"location":"shaders/general_structure/#overview","title":"Overview","text":"<p>This GLSL shader follows a modular, data-driven architecture designed for real-time 3D rendering using Signed Distance Fields (SDFs) and raymarching.</p>"},{"location":"shaders/general_structure/#key-components","title":"Key Components","text":"<ul> <li>Scene Representation \u2013 Uses SDFs to define geometry.</li> <li>Raymarching Loop \u2013 Efficiently traces rays through the scene.</li> <li>Material System \u2013 Handles lighting and shading.</li> <li>Animation System \u2013 Procedural motion for dynamic objects.</li> <li>Noise &amp; Utility Functions \u2013 For procedural effects and surface detail.</li> </ul>"},{"location":"shaders/general_structure/#1-signed-distance-fields-sdfs","title":"1. Signed Distance Fields (SDFs)","text":"<ul> <li>The shader represents objects using mathematical distance functions, which define how far a point is from a surface.</li> <li>Primitives such as Sphere, Box, and Torus are defined via SDFs.</li> <li><code>evalSDF()</code> \u2013 Evaluates a single SDF function.</li> <li><code>evaluateScene()</code> \u2013 Checks all SDFs and tracks the closest hit.</li> </ul>"},{"location":"shaders/general_structure/#2-raymarching","title":"2. Raymarching","text":"<p>This shader uses raymarching to render 3D scenes efficiently.</p>"},{"location":"shaders/general_structure/#how-it-works","title":"How It Works","text":"<ul> <li>Ray Origin (<code>ro</code>) and Direction (<code>rd</code>) are set up based on the camera.</li> <li>A marching loop steps along the ray, checking <code>evaluateScene()</code> at each step.</li> <li>Early exit occurs if a surface is hit (distance &lt; threshold) or max steps are reached.</li> </ul>"},{"location":"shaders/general_structure/#key-functions","title":"Key Functions","text":"<pre><code>vec3 raymarch(vec3 ro, vec3 rd, out vec3 hitPos); // Main raymarching loop\n</code></pre>"},{"location":"shaders/general_structure/#3-material-lighting-system","title":"3. Material &amp; Lighting System","text":"<p>The shader supports dynamic materials with Phong lighting for realistic shading.</p>"},{"location":"shaders/general_structure/#components","title":"Components","text":"<ul> <li>Base Color \u2013 Defined per SDF (e.g., <code>SDF.color</code>)</li> <li>Lighting Model \u2013 Uses <code>applyPhongLighting()</code> for diffuse and specular shading</li> <li>Material Properties \u2013 Adjustable via <code>MakePlasticMaterial()</code></li> </ul>"},{"location":"shaders/general_structure/#lighting-workflow","title":"Lighting Workflow","text":""},{"location":"shaders/general_structure/#1-get-the-surface-normal-using","title":"1. Get the surface normal using:","text":"<ul> <li><code>SDFsNormal()</code> for basic shapes</li> <li>Custom normal functions for complex surfaces</li> </ul>"},{"location":"shaders/general_structure/#2-compute-lighting-using","title":"2. Compute lighting using:","text":"<ul> <li>Diffuse \u2013 Lambertian reflection</li> <li>Specular \u2013 Phong or Blinn-Phong highlights</li> <li>Ambient \u2013 A fixed base illuminatio</li> </ul>"},{"location":"shaders/general_structure/#4-animation-system","title":"4. Animation System","text":"<p>This GLSL shader implements a comprehensive animation system that coordinates multiple animated elements including:</p> <ul> <li> <p>Camera movement with multiple behavior modes</p> </li> <li> <p>Procedural object animation</p> </li> <li> <p>Time-based effects</p> </li> <li> <p>Dolphin character with articulated body motion</p> </li> </ul> <p>The system uses a unified time-based approach where all animations synchronize to a master clock (iTime) while maintaining independent control over each element's timing and behavior.</p>"},{"location":"shaders/general_structure/#5-noise-procedural-generation","title":"5. Noise &amp; Procedural Generation","text":"<p>The shader includes several noise functions used for procedural effects and surface detailing.</p>"},{"location":"shaders/general_structure/#available-noise-types","title":"Available Noise Types","text":"<ul> <li>Gradient Noise (<code>Pseudo3dNoise</code>) \u2013 Smooth, Perlin-like noise</li> <li>Fractal Brownian Motion (<code>fbmPseudo3D</code>) \u2013 Adds layered detail via multiple octaves</li> <li>Alternative 3D Noise (<code>n31</code>) \u2013 A different style of 3D noise with unique characteristics</li> </ul>"},{"location":"shaders/general_structure/#6-rendering-pipeline-summary","title":"6. Rendering Pipeline Summary","text":""},{"location":"shaders/general_structure/#setup","title":"Setup","text":"<ul> <li>Define SDFs, lights, and camera parameters</li> </ul>"},{"location":"shaders/general_structure/#raymarching","title":"Raymarching","text":"<ul> <li>Trace rays through the scene using the <code>raymarch()</code> function</li> </ul>"},{"location":"shaders/general_structure/#shading","title":"Shading","text":"<ul> <li>Compute surface normals and apply lighting via <code>applyPhongLighting()</code></li> </ul>"},{"location":"shaders/general_structure/#key-advantages","title":"Key Advantages","text":"<ul> <li>\u2714 Flexible \u2013 Easily add new SDF shapes</li> <li>\u2714 Performant \u2013 Raymarching is efficient for complex scenes</li> <li>\u2714 Procedural \u2013 No need for pre-made textures or models</li> </ul>"},{"location":"shaders/shaderPage/","title":"\ud83e\uddf1 Shader Library Overview","text":"<p>Welcome to the Shader Library, a central hub for exploring all procedural shaders in this project.</p> <p>\ud83d\udd0d Each shader includes:</p> <ul> <li>\ud83d\udcdc A brief description and visual preview  </li> <li>\ud83e\udde0 Algorithm or math explanation  </li> <li>\ud83d\udcbb Source code with syntax highlighting  </li> <li>\ud83d\uddbc\ufe0f Results and demo screenshots or videos  </li> </ul>"},{"location":"shaders/shaderPage/#shader-categories","title":"\ud83d\udcc2 Shader Categories","text":""},{"location":"shaders/shaderPage/#general-structure","title":"\ud83d\udd2d General Structure","text":"<p>General structure of the shaders logic</p> <ul> <li>General Structure</li> </ul>"},{"location":"shaders/shaderPage/#signed-distance-field-sdf-system-shader","title":"Signed Distance Field (SDF) System Shader","text":"<p>This documentation covers the Signed Distance Field (SDF) module used in the GLSL shader.</p> <ul> <li>SDF System</li> </ul>"},{"location":"shaders/shaderPage/#lighting-and-material-system-shader","title":"Lighting and Material System Shader","text":"<p>This documentation covers the Phong-based lighting model and material system used in the GLSL.</p> <ul> <li>Lighting &amp; Material System</li> </ul>"},{"location":"shaders/shaderPage/#animation-system-shader","title":"Animation System Shader","text":"<p>This documentation covers the Animation module used in the GLSL shader.</p> <ul> <li>Animation System</li> </ul>"},{"location":"shaders/shaderPage/#noise-system-shader","title":"Noise System Shader","text":"<p>The noise system in this shader provides procedural pattern generation for textures, terrain, and effects.</p> <ul> <li>Noise System</li> </ul>"},{"location":"shaders/shaderPage/#animation-shaders","title":"\ud83c\udf00 Animation Shaders","text":"<p>Shaders that control movement over time, often using sine/cosine functions or time-based interpolation.</p> <ul> <li>TIE Fighter</li> <li>Camera Orientation Setup Shader</li> <li>SDF Animation</li> <li>Camera Animation</li> </ul>"},{"location":"shaders/shaderPage/#noise-shaders","title":"\u2601\ufe0f Noise Shaders","text":"<p>Procedural textures using hash-based value, gradient, and fractal noise. Grouped by functional type for clarity:</p>"},{"location":"shaders/shaderPage/#core-modules","title":"Core Modules","text":"<p>Unified entry point and hash support.</p> <ul> <li>noise.glsl \u2014 Main include file, collects all noise types  </li> <li>hash.glsl \u2014 Random number and hash utilities</li> </ul>"},{"location":"shaders/shaderPage/#classic-noise","title":"Classic Noise","text":"<p>Basic, smooth procedural noise generators.</p> <ul> <li>1D_noise.glsl \u2014 1D interpolated value noise  </li> <li>2D_noise.glsl \u2014 2D grid-based value noise  </li> <li>3D_Perlin_noise.glsl \u2014 Classic 3D gradient noise  </li> <li>simplex_noise.glsl \u2014 Fast, low-artifact simplex noise</li> </ul>"},{"location":"shaders/shaderPage/#utility-noise","title":"Utility Noise","text":"<p>Variants and helpers used for animation or visual variation.</p> <ul> <li>3D_noise.glsl \u2014 Time-varying pseudo 3D gradient noise  </li> <li>grayScale_noise.glsl \u2014 Grayscale noise helper</li> </ul>"},{"location":"shaders/shaderPage/#spatial-noise","title":"Spatial Noise","text":"<p>Noise patterns structured around space and proximity.</p> <ul> <li>cell_noise.glsl \u2014 2D Voronoi cell structure with jitter</li> </ul>"},{"location":"shaders/shaderPage/#fractal-noise","title":"Fractal Noise","text":"<p>Multi-octave patterns for natural surfaces.</p> <ul> <li>fbm.glsl \u2014 Fractal Brownian Motion</li> </ul>"},{"location":"shaders/shaderPage/#noise-based-effects","title":"Noise-based Effects","text":"<p>Visual effects built using the above noise modules.</p> <ul> <li>stylized_glow_and_star_shape.glsl \u2014 Stylized star shape and bloom  </li> <li>TIE Fighter_noise.glsl \u2014 Procedural engine trail + noise shading</li> </ul>"},{"location":"shaders/shaderPage/#geometry-shaders","title":"\ud83d\udd37 Geometry Shaders","text":"<p>Shaders that generate or modify geometry procedurally.</p> <ul> <li>SDF Raymarching</li> <li>SDF Sphere</li> <li>SDF Square</li> <li>SDF Rock</li> <li>SDF Cactus</li> </ul>"},{"location":"shaders/shaderPage/#material-shaders","title":"\ud83e\uddf1 Material Shaders","text":"<p>Define the visual appearance of surfaces by specifying physical or stylized material properties such as color, roughness, metallicity, and transparency. Used alongside lighting models to produce realistic or artistic effect.</p> <ul> <li>Material System</li> <li>Volume Material System</li> </ul>"},{"location":"shaders/shaderPage/#lighting-shaders","title":"\ud83d\udca1 Lighting Shaders","text":"<p>Compute surface lighting effects including diffuse, specular, rim, and reflection. Often used in combination with geometry to produce realism or stylized appearances.</p> <ul> <li>Rim Reflection Lighting</li> <li>Lighting Functions</li> <li>Lighting Context</li> <li>Volume Lighting Functions</li> <li>Volume Lighting Context</li> <li>Sunrise</li> </ul>"},{"location":"shaders/shaderPage/#rendering-shaders","title":"Rendering Shaders","text":"<ul> <li>Ray_Marching</li> <li>Sphere Intersection</li> <li>Volumetric Ray Marching</li> <li>Heightfield Ray Intersection</li> <li>Oriented Box Intersection</li> <li>Surface Normal Estimation</li> <li>Advanced Normal Estimation</li> </ul>"},{"location":"shaders/shaderPage/#scenes-shaders","title":"\ud83d\udd37 Scenes Shaders","text":"<p>Shaders that render complete background or environmental elements such as sky, sun, clouds, or horizon effects. These shaders are not limited to lighting or material computation but instead define the overall visual atmosphere of a scene.</p> <ul> <li>Sun And Halo</li> <li>Volumetric FBM Cloud</li> <li>Water Surface</li> <li>Boat And Flag</li> <li>Cloud Volume</li> <li>Cloud And Ground</li> <li>Cloud And Water</li> <li>Terrain And Castle</li> <li>Dolphin</li> </ul> <p>\ud83d\udcd8 How to Read a Shader Page</p> <p>Every shader entry follows the same layout:</p> <ul> <li>Overview \u2014 What it is, what it does  </li> <li>Algorithm \u2014 Description of logic and flow  </li> <li>Code \u2014 Full GLSL/HLSL implementation  </li> <li>Results \u2014 Previews, GIFs, or videos  </li> </ul>"},{"location":"shaders/shader_template/","title":"\ud83e\udde9 [Shader Name] Shader","text":"Your browser does not support the video tag.  <ul> <li>Category: [e.g., Animation / Noise / Scene]</li> <li>Author: [Contributor Name]</li> <li>Shader Type: Raymarching with SDFs  </li> <li>Input Requirements: [Time / UV / Mouse / etc.]</li> </ul>"},{"location":"shaders/shader_template/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/shader_template/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>Explain the logic used in this shader.</p> <ul> <li>Movement logic (e.g., <code>cos(t)</code>, <code>sin(t * speed)</code>)</li> <li>Procedural math (e.g., FBM, noise)</li> <li>Camera path, lighting, deformation, etc.</li> </ul>"},{"location":"shaders/shader_template/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Range Default <code>T</code> Looping time 0\u201340 \u2014 ... ... ... ..."},{"location":"shaders/shader_template/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<p>```glsl     // Paste full GLSL or HLSL code here</p> <p>```</p> \ud83d\udcc4 sdf_updated.gdshader <p>```glsl     shader_type canvas_item;</p> <pre><code>#include \"res://addons/includes/sdf_updated.gdshaderinc\"\nvoid fragment() {\n    vec4 color;\nvec3 lightPosition = camera_position;\nIntegrationFlexible(UV, color, lightPosition);\n    COLOR = color;\n\n}\n</code></pre> <p>```</p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/animation/Animation_System/","title":"Animation System","text":"Animation Shader by Wanzhang He"},{"location":"shaders/animation/Animation_System/#overview","title":"Overview","text":"<p>The shader supports two types of animation: camera animation and SDF object animation.</p>"},{"location":"shaders/animation/Animation_System/#camera-animation","title":"Camera Animation","text":"<ul> <li>Based on a modular system using <code>CameraState</code> and <code>CameraAnimParams</code> structs.</li> <li>Provides four animation modes:</li> <li>Static \u2013 fixed viewpoint</li> <li>Orbit \u2013 camera revolves around a scene center</li> <li>Ping-pong \u2013 camera moves back and forth</li> <li>First-person \u2013 camera moves forward continuously</li> <li>The system outputs a camera matrix used for ray direction setup in raymarching shaders.</li> <li>View matrix is constructed in column-major order using eye, target, and up vectors.</li> </ul>"},{"location":"shaders/animation/Animation_System/#sdf-object-animation","title":"SDF Object Animation","text":"<ul> <li>Uses a matrix-based animation system that transforms each SDF object individually.</li> <li>Supports five animation types:</li> <li>Translate \u2013 sinusoidal motion along a direction</li> <li>Orbit \u2013 circular movement around a center</li> <li>Self Rotate \u2013 object spins around its own axis</li> <li>Pulse Scale \u2013 scales up and down periodically</li> <li>TIE Path \u2013 complex figure-8 motion with rotation</li> <li>Each animation is driven by global time (<code>iTime</code>) and mode-dependent parameters.</li> <li>The animation matrix is applied before raymarching, and its inverse is used to transform rays into object-local space.</li> <li>Time modulation allows smooth or oscillating patterns using linear, <code>sin(t)</code>, or <code>abs(sin(t))</code> curves.</li> </ul> <p>To see the different animation functions, refer to Animation Shaders</p>"},{"location":"shaders/animation/Camera_Anim/","title":"\ud83c\udfa5 Modular Camera Animation Shader","text":"<ul> <li>Category: Animation</li> <li>Author: Wanzhang He  </li> <li>Input Requirements: <code>time</code>, <code>CameraAnimParams</code> </li> <li>Output: <code>CameraState</code> (eye, target, up) used for view matrix setup  </li> </ul>"},{"location":"shaders/animation/Camera_Anim/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This module provides a modular and reusable camera animation system for raymarching / SDF-based scenes.  </li> <li>It supports multiple camera animation modes:  </li> <li><code>0</code>: Static  </li> <li><code>1</code>: Orbit  </li> <li><code>2</code>: Ping-pong  </li> <li><code>3</code>: First-person  </li> <li>Designed for plug-and-play integration into main SDF rendering pipeline.</li> </ul>"},{"location":"shaders/animation/Camera_Anim/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/animation/Camera_Anim/#core-concept","title":"\ud83d\udd04 Core Concept","text":"<ul> <li>The main function <code>animate_camera()</code> computes a time-varying camera state based on:  </li> <li>Current time  </li> <li>Speed and offset  </li> <li>Chosen animation mode  </li> <li>The helper <code>get_camera_matrix()</code> constructs a view-space matrix from the camera state:</li> <li>Forward vector is <code>target - eye</code></li> <li>Right vector is orthogonal to forward &amp; up</li> <li>Matrix is returned in column-major <code>[right, up, -forward]</code> order</li> </ul>"},{"location":"shaders/animation/Camera_Anim/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>mode</code> Animation mode (0\u20133) <code>int</code> <code>1</code> (orbit) <code>speed</code> Playback speed multiplier <code>float</code> <code>1.0</code> <code>offset</code> Time offset <code>float</code> <code>0.0</code> <code>center</code> Point to look at <code>vec3</code> <code>vec3(0)</code> <code>radius</code> Orbit or movement radius <code>float</code> <code>5.0</code>"},{"location":"shaders/animation/Camera_Anim/#camera-modes","title":"\ud83e\udded Camera Modes","text":"Mode Behavior Motion Axis 0 Static - 1 Orbit around center Y-axis 2 Ping-pong back and forth Z-axis 3 First-person forward movement X-axis"},{"location":"shaders/animation/Camera_Anim/#data-structures","title":"\ud83e\uddf1 Data Structures","text":""},{"location":"shaders/animation/Camera_Anim/#struct-camerastate","title":"<code>struct CameraState</code>","text":"Field Type Description <code>eye</code> <code>vec3</code> Camera position (origin) <code>target</code> <code>vec3</code> Look-at target position <code>up</code> <code>vec3</code> Upward vector direction"},{"location":"shaders/animation/Camera_Anim/#struct-cameraanimparams","title":"<code>struct CameraAnimParams</code>","text":"Field Type Description <code>mode</code> <code>int</code> Animation mode (0\u20133) <code>speed</code> <code>float</code> Playback speed <code>offset</code> <code>float</code> Time offset <code>center</code> <code>vec3</code> Target center for orbit/ping-pong <code>radius</code> <code>float</code> Orbit radius / movement amplitude"},{"location":"shaders/animation/Camera_Anim/#functions","title":"\ud83d\udcd0 Functions","text":""},{"location":"shaders/animation/Camera_Anim/#mat3-get_camera_matrixcamerastate-cam","title":"<code>mat3 get_camera_matrix(CameraState cam)</code>","text":"<p>Builds a view direction matrix based on camera state: - <code>right</code>, <code>up</code>, <code>-forward</code> are returned in column-major order. - Can be used to transform rays to camera space.</p>"},{"location":"shaders/animation/Camera_Anim/#camerastate-animate_camerafloat-time-cameraanimparams-param","title":"<code>CameraState animate_camera(float time, CameraAnimParams param)</code>","text":"<p>Returns an animated <code>CameraState</code> based on time and selected mode.</p>"},{"location":"shaders/animation/Camera_Anim/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>struct CameraState {\n    vec3 eye;\n    vec3 target;\n    vec3 up;\n};\n\nstruct CameraAnimParams {\n    int mode;\n    float speed;\n    float offset;\n    vec3 center;\n    float radius;\n};\n\nmat3 get_camera_matrix(CameraState cam) {\n    vec3 f = normalize(cam.target - cam.eye);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = cross(r, f);\n    return mat3(r, u, -f);\n}\n\nCameraState animate_camera(float time, CameraAnimParams param) {\n    CameraState cam;\n    float t = time * param.speed + param.offset;\n\n    if (param.mode == 0) {\n        cam.eye = vec3(0.0, 2.0, 5.0);\n        cam.target = param.center;\n    } else if (param.mode == 1) {\n        cam.eye = vec3(sin(t), 1.5, cos(t)) * param.radius;\n        cam.target = param.center;\n    } else if (param.mode == 2) {\n        cam.eye = vec3(0.0, 1.5, sin(t) * param.radius + 5.0);\n        cam.target = param.center;\n    } else if (param.mode == 3) {\n        cam.eye = vec3(t * param.radius, 1.0, 0.0);\n        cam.target = cam.eye + vec3(0.0, 0.0, -1.0);\n    } else {\n        cam.eye = vec3(0.0, 1.5, 5.0);\n        cam.target = param.center;\n    }\n\n    cam.up = vec3(0.0, 1.0, 0.0);\n    return cam;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/animation/calcLookAtMatrix/","title":"\ud83e\udde9 Camera Orientation Setup Shader","text":"<ul> <li>Category: Animation / Camera  </li> <li>Author: Wanzhang He  </li> <li>Shader Type: Dynamic camera matrix computation  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code>, <code>iTime</code>, <code>iChannel0</code> </li> <li>Output: Animated environment sample using orbiting camera</li> </ul>"},{"location":"shaders/animation/calcLookAtMatrix/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>Defines a time-varying camera system using a <code>look-at</code> matrix with optional roll.</li> <li>Simulates orbiting motion around the scene origin, with adjustable speed and tilt.</li> <li>Can be reused in raymarchers, reflections, or scene viewers for dynamic camera control.</li> <li>Texture sample is done via flat projection for visualization.</li> </ul>"},{"location":"shaders/animation/calcLookAtMatrix/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/animation/calcLookAtMatrix/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<ul> <li>Uses <code>calcLookAtMatrix()</code> to create a camera basis matrix from:</li> <li>Eye position <code>ro</code></li> <li>Target position <code>ta</code></li> <li>Roll angle (optional tilt)</li> <li>The ray direction is transformed from screen space to world space using this basis.</li> <li>Final color is sampled from a texture (<code>iChannel0</code>) using the view direction.</li> </ul>"},{"location":"shaders/animation/calcLookAtMatrix/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Viewport resolution <code>vec2</code> uniform <code>iTime</code> Global time for animation <code>float</code> uniform <code>iChannel0</code> Environment texture for visualization <code>sampler2D</code> loaded externally"},{"location":"shaders/animation/calcLookAtMatrix/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>mat3 calcLookAtMatrix(vec3 ro, vec3 ta, float roll) {\n    vec3 forward = normalize(ta - ro);\n    vec3 right = normalize(cross(forward, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.5;\n    vec3 ta = vec3(0.0);\n    vec3 ro = vec3(2.0 * cos(t), 1.0, 2.0 * sin(t));\n    float roll = sin(iTime * 0.3) * 0.3;\n\n    mat3 camMat = calcLookAtMatrix(ro, ta, roll);\n    vec3 rayDir = normalize(camMat * vec3(p, -1.0));\n\n    vec2 envUV = rayDir.xy * 0.5 + 0.5;\n    vec3 col = texture(iChannel0, envUV).rgb;\n\n    fragColor = vec4(col, 1.0);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/animation/sdf_animation_shader/","title":"\ud83e\udde9 SDF Animation Shader","text":"<ul> <li>Category: Animation / SDF / Scene</li> <li>Author: Wanzhang He</li> </ul>"},{"location":"shaders/animation/sdf_animation_shader/#input-requirements","title":"\ud83d\udce5 Input Requirements","text":"<p>This shader animation module depends on the following inputs:</p>"},{"location":"shaders/animation/sdf_animation_shader/#time-input","title":"\u23f1 Time Input","text":"<ul> <li><code>iTime</code> (<code>float</code>) \u2013 global shader time (in seconds)</li> <li><code>timeMode</code> (<code>int</code>) \u2013 animation time modulation mode</li> <li><code>0</code>: linear time</li> <li><code>1</code>: <code>sin(t)</code></li> <li><code>2</code>: <code>abs(sin(t))</code></li> </ul>"},{"location":"shaders/animation/sdf_animation_shader/#animation-control-parameters","title":"\ud83c\udf9b Animation Control Parameters","text":"<ul> <li><code>animationType</code> (<code>int</code>) \u2013 selects the animation type:</li> <li>1 = Translate</li> <li>2 = Orbit</li> <li>3 = Self Rotate</li> <li>4 = Pulse Scale</li> <li>5 = TIE Path</li> <li><code>translateParam</code> (<code>vec4</code>) \u2013 direction (xyz), speed (w)</li> <li><code>orbitParam</code> (<code>vec4</code>) \u2013 center (xyz), angular speed (w)</li> <li><code>selfRotateParam</code> (<code>vec4</code>) \u2013 axis (xyz), angular speed (w)</li> <li><code>pulseParam</code> (<code>vec2</code>) \u2013 frequency, amplitude</li> </ul>"},{"location":"shaders/animation/sdf_animation_shader/#sdf-object-parameters","title":"\ud83e\udde9 SDF Object Parameters","text":"<ul> <li><code>_sdfTypeFloat[]</code> (<code>float</code>) \u2013 object type (0=Sphere, 1=Box, etc.)</li> <li><code>_sdfPositionFloat[]</code> (<code>vec3</code>) \u2013 object positions</li> <li><code>_sdfSizeFloat[]</code> (<code>vec3</code>) \u2013 size/scale per object</li> <li><code>_sdfRadiusFloat[]</code> (<code>float</code>) \u2013 object radius (for spheres, torus)</li> </ul> <p>These parameters define the structure and behavior of the animated SDF objects. The animation matrix is applied to these objects dynamically during rendering.</p>"},{"location":"shaders/animation/sdf_animation_shader/#algorithm","title":"\ud83e\udde0 Algorithm","text":"<p>This shader implements a modular animation system for SDF-based objects. It supports several animation types with matrix-based transformations.</p>"},{"location":"shaders/animation/sdf_animation_shader/#1-animation-modes","title":"1. Animation Modes","text":"<p>Supported animation types: - Translate: sinusoidal movement along a direction - Orbit: rotate around a given point - Self Rotate: spin around own axis - Pulse Scale: object expands/contracts periodically - TIE Path: figure-8 path with additional rotation</p>"},{"location":"shaders/animation/sdf_animation_shader/#2-time-modulation","title":"2. Time Modulation","text":"<p>Time is modulated with three modes: - <code>t</code> (linear) - <code>sin(t)</code> - <code>abs(sin(t))</code></p> <p>This allows for smooth, oscillatory, or one-direction movement patterns.</p>"},{"location":"shaders/animation/sdf_animation_shader/#3-matrix-composition","title":"3. Matrix Composition","text":"<p>Each animation mode returns a <code>mat4</code> transformation matrix. These are composed in <code>getAnimationMatrix(...)</code> to produce: - <code>animationMatrix</code>: applied to SDF object - <code>inverseAnimationMatrix</code>: used for raymarching transform</p>"},{"location":"shaders/animation/sdf_animation_shader/#4-sdf-integration","title":"4. SDF Integration","text":"<p>Objects are described by arrays like <code>_sdfTypeFloat</code>, <code>_sdfPositionFloat</code>, etc. Each object's ray is transformed by the matrix before raymarching, enabling animation.</p>"},{"location":"shaders/animation/sdf_animation_shader/#code","title":"\ud83d\udcbb Code","text":""},{"location":"shaders/animation/sdf_animation_shader/#1-sdf-object-configuration","title":"1. SDF Object Configuration","text":"<pre><code>// ===== SDF Variables =====\n#define SDF_COUNT 10\nfloat _sdfTypeFloat[SDF_COUNT];\nvec3 _sdfPositionFloat[SDF_COUNT];\nvec3 _sdfSizeFloat[SDF_COUNT];\nfloat _sdfRadiusFloat[SDF_COUNT];\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#2-animation-parameters","title":"2. Animation Parameters","text":"<pre><code>// ===== Animation Variables =====\nint animationType = 1;\nint timeMode = 1;\n\nvec4 translateParam = vec4(1.0, 0.0, 0.0, 2.0);\nvec4 orbitParam     = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 selfRotateParam = vec4(0.0, 1.0, 0.0, 1.5);\nvec2 pulseParam     = vec2(3.0, 0.2);\n\nmat4 animationMatrix = mat4(1.0);\nmat4 inverseAnimationMatrix = mat4(1.0);\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#3-animation-parameter-setters","title":"3. Animation Parameter Setters","text":"<pre><code>// Sets the translation animation parameters.\nvoid setTranslateParam(vec3 direction, float speed) {\n// Sets the orbit animation parameters.\nvoid setOrbitParam(vec3 center, float orbitSpeed) {\n// Sets the self-rotation animation parameters.\nvoid setSelfRotateParam(vec3 axis, float angularSpeed) {\n// Sets the pulse-scale animation parameters.\nvoid setPulseParam(float frequency, float amplitude) {\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#4-time-modulation-function","title":"4. Time Modulation Function","text":"<pre><code>float applyTimeMode(float t, int mode) {\n    if (mode == 1) return sin(t);\n    if (mode == 2) return abs(sin(t));\n    return t;\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#5-animation-matrix-functions","title":"5. Animation Matrix Functions","text":""},{"location":"shaders/animation/sdf_animation_shader/#51-translate-animation","title":"5.1 Translate Animation","text":"<pre><code>mat4 getTranslateMatrix(float t, int mode) {\n    float modT = applyTimeMode(t, mode);\n    vec3 offset = translateParam.xyz * sin(modT * translateParam.w);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        offset.x, offset.y, offset.z, 1.0\n    );\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#engine-integrations","title":"Engine Integrations","text":"Unity"},{"location":"shaders/animation/sdf_animation_shader/#53-orbit-animation","title":"5.3 Orbit Animation","text":"<pre><code>mat4 getOrbitMatrix(float t, int mode) {\n    float modT = applyTimeMode(t, mode);\n    float angle = modT * orbitParam.w;\n    float c = cos(angle), s = sin(angle);\n    vec3 center = orbitParam.xyz;\n\n    mat4 toOrigin = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        -center.x, -center.y, -center.z, 1.0\n    );\n\n    mat4 rotationY = mat4(\n         c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n         s, 0.0,  c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    mat4 back = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        center.x, center.y, center.z, 1.0\n    );\n\n    return back * rotationY * toOrigin;\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#engine-integrations_1","title":"Engine Integrations","text":"Unity"},{"location":"shaders/animation/sdf_animation_shader/#53-self-rotate-animation","title":"5.3 Self-Rotate Animation","text":"<pre><code>mat4 getSelfRotateMatrix(float t, int mode) {\n    float modT = applyTimeMode(t, mode);\n    float angle = modT * selfRotateParam.w;\n    vec3 axis = normalize(selfRotateParam.xyz);\n    float c = cos(angle), s = sin(angle);\n    float x = axis.x, y = axis.y, z = axis.z;\n\n    return mat4(\n        c + (1.0 - c)*x*x,     (1.0 - c)*x*y - s*z, (1.0 - c)*x*z + s*y, 0.0,\n        (1.0 - c)*y*x + s*z,   c + (1.0 - c)*y*y,   (1.0 - c)*y*z - s*x, 0.0,\n        (1.0 - c)*z*x - s*y,   (1.0 - c)*z*y + s*x, c + (1.0 - c)*z*z,   0.0,\n        0.0,                   0.0,                 0.0,                 1.0\n    );\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#engine-integrations_2","title":"Engine Integrations","text":"Unity"},{"location":"shaders/animation/sdf_animation_shader/#54-pulse-scale-animation","title":"5.4 Pulse Scale Animation","text":"<pre><code>mat4 getPulseScaleMatrix(float t, int mode) {\n    float modT = applyTimeMode(t, mode);\n    float scale = 1.0 + sin(modT * pulseParam.x) * pulseParam.y;\n\n    return mat4(\n        scale, 0.0,   0.0,   0.0,\n        0.0,   scale, 0.0,   0.0,\n        0.0,   0.0,   scale, 0.0,\n        0.0,   0.0,   0.0,   1.0\n    );\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#engine-integrations_3","title":"Engine Integrations","text":"Unity"},{"location":"shaders/animation/sdf_animation_shader/#55-tie-path-animation","title":"5.5 TIE Path Animation","text":"<pre><code>mat4 getTIEPathMatrix(float t, int mode) {\n    float modT = applyTimeMode(t, mode);\n    float x = cos(modT * 0.7);\n    vec3 offset = vec3(x, cos(modT), sin(modT * 1.1));\n    float angle = -x * 0.1;\n    float c = cos(angle), s = sin(angle);\n\n    mat4 rotation = mat4(\n         c, s,   0.0, 0.0,\n        -s, c,   0.0, 0.0,\n         0.0, 0.0, 1.0, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n\n    mat4 translate = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        offset.x, offset.y, offset.z, 1.0\n    );\n\n    return translate * rotation;\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#6-animation-dispatcher","title":"6. Animation Dispatcher","text":"<pre><code>mat4 getAnimationMatrix(float t, int animationType, int timeMode) {\n    if (animationType == 1) {\n        return getTranslateMatrix(t, timeMode);   // Translate\n    }\n    else if (animationType == 2) {\n        return getOrbitMatrix(t, timeMode);       // Orbit\n    }\n    else if (animationType == 3) {\n        return getSelfRotateMatrix(t, timeMode);  // SelfRotate\n    }\n    else if (animationType == 4) {\n        return getPulseScaleMatrix(t, timeMode);  // PulseScale\n    }\n    else if (animationType == 5) {\n        return getTIEPathMatrix(t, timeMode);     // TIEPath\n    }\n    return mat4(1.0); // Identity matrix if no animation\n}\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#7-raymarch-function","title":"7. Raymarch Function","text":"<pre><code>float raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    const float tMax = 100.0;\n    const float epsilon = 0.001;\n\n    for (int i = 0; i &lt; 128; ++i) {\n        vec3 p = ro + rd * t;\n\n        // Example SDF: sphere at origin with radius 1\n        // Replace with getSDF(p) if you have a general SDF function\n        float dist = length(p) - 1.0;\n\n        if (dist &lt; epsilon) {\n            return t; // hit found, return distance\n        }\n</code></pre>"},{"location":"shaders/animation/sdf_animation_shader/#8-example-mainimage-function","title":"8. Example mainImage Function","text":"<pre><code>void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.5));\n\n    // Compute animation matrix and inverse matrix\n    animationMatrix = getAnimationMatrix(iTime, animationType, timeMode);\n    inverseAnimationMatrix = inverse(animationMatrix);\n\n    // Transform ray into object space\n    vec3 transformed_ro = vec3(inverseAnimationMatrix * vec4(ro, 1.0));\n    vec3 transformed_rd = normalize(vec3(inverseAnimationMatrix * vec4(rd, 0.0)));\n\n    // Raymarching call\n    float t = raymarch(transformed_ro, transformed_rd);\n\n    if (t &gt; 0.0) {\n        fragColor = vec4(1.0, 0.5, 0.2, 1.0); // Hit color\n    } else {\n        fragColor = vec4(0.0); // Background color\n    }\n</code></pre>"},{"location":"shaders/animation/tie_fighter/","title":"\ud83e\udde9 TIE Fighter Animation Shader","text":"<ul> <li>Category: Animation </li> <li>Author: Ruimin Ma</li> </ul>"},{"location":"shaders/animation/tie_fighter/#input-requirements","title":"\ud83d\udce5 Input Requirements","text":"<p>This shader relies on a looped time input <code>T</code> ranging approximately from <code>0</code> to <code>40</code>, which drives both the object and camera animation.</p>"},{"location":"shaders/animation/tie_fighter/#time-input","title":"\u23f1 Time Input","text":"<ul> <li><code>T</code> (<code>float</code>) \u2013 scene time in seconds, typically looped over <code>[0\u202540]</code></li> </ul>"},{"location":"shaders/animation/tie_fighter/#fighter-animation-tieposvec3-p-float-t","title":"\u2708\ufe0f Fighter Animation: <code>tiePos(vec3 p, float t)</code>","text":"<p>This function applies stylized, non-linear movement to the TIE Fighter body:</p> <ul> <li>Lateral sway: <code>cos(t * 0.7)</code> affects X position  </li> <li>Vertical bob: <code>cos(t)</code> affects Y position  </li> <li>Depth sway: <code>sin(t * 1.1)</code> affects Z position  </li> <li>Roll: <code>mat2</code> rotation applied in the X\u2013Y plane, scaled by <code>-x * 0.1</code></li> </ul> <p>These effects combine into a figure-8\u2013like flight pattern with gentle roll, creating a more cinematic, natural feel.</p>"},{"location":"shaders/animation/tie_fighter/#camera-animation-getcamerafloat-t-out-vec3-ro-out-vec3-lookat","title":"\ud83c\udfa5 Camera Animation: <code>getCamera(float T, out vec3 ro, out vec3 lookAt)</code>","text":"<p>The camera follows the fighter dynamically, with two phases:</p> <ol> <li>Close follow (0\u20135s):  </li> <li><code>lookAt</code> targets the animated fighter's position  </li> <li> <p><code>ro</code> (camera origin) is just behind the target</p> </li> <li> <p>Pull-back transition (after 5s):  </p> </li> <li><code>lookAt</code> transitions to a fixed point  </li> <li><code>ro</code> moves into an orbiting camera path</li> </ol> <p>This is achieved using <code>smoothstep(0.0, 5.0, T)</code> to blend between the two states.</p>"},{"location":"shaders/animation/tie_fighter/#algorithm-summary","title":"\ud83e\udde0 Algorithm Summary","text":"Function Purpose <code>tiePos(...)</code> Animate fighter motion <code>getCamera(...)</code> Animate cinematic camera <p>These are not part of the general animation system, but instead define a scene-specific animation pipeline for demonstration or cinematic shots.</p>"},{"location":"shaders/animation/tie_fighter/#code-snippet","title":"\ud83d\udcbb Code Snippet","text":"<pre><code>/** Fighter body motion */\nvec3 tiePos(vec3 p, float t)\n{\n    float x = cos(t * 0.7);\n    p += vec3(x, cos(t), sin(t * 1.1));\n    p.xy *= mat2(cos(-x*0.1), sin(-x*0.1),\n                -sin(-x*0.1), cos(-x*0.1));\n    return p;\n}\n\n/** Camera path: follow then pull out */\nvoid getCamera(float T, out vec3 ro, out vec3 lookAt)\n{\n    float t = smoothstep(0.0, 5.0, T);\n\n    lookAt = mix(vec3(0,0,6) - tiePos(vec3(0), T-0.2),\n                 vec3(2.5,0,0), t);\n\n    ro = mix(lookAt - vec3(0,0,1),\n             vec3(4.0 + cos(T),\n                  0.2 * sin(T),\n                 -8.0 + 6.0 * cos(T * 0.2)),\n             t);\n}\n</code></pre>"},{"location":"shaders/geometry/SDF_Cactus/","title":"\ud83e\udde9 SDF Cactus Shader","text":"<ul> <li>Category: Geometry  </li> <li>Author: Wanzhang He   </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code> </li> <li>Output: Procedural cactus with branches and spines using capsule-based SDF  </li> </ul>"},{"location":"shaders/geometry/SDF_Cactus/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader renders a 3D cactus using Signed Distance Fields (SDF) and capsule primitives.  </li> <li>Includes a vertical stem and two horizontal arms.  </li> <li>Adds simplex noise to deform the cactus surface.  </li> <li>Also adds spiky decorations (spines) using small sphere SDFs.  </li> <li>Basic Lambert shading is applied based on estimated normals.</li> </ul>"},{"location":"shaders/geometry/SDF_Cactus/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/geometry/SDF_Cactus/#core-concept","title":"\ud83c\udf35 Core Concept","text":"<ul> <li>Main body and arms are constructed from capsule shapes.  </li> <li>Shape is rotated using axis-angle to matrix conversion.  </li> <li>Noise-based perturbation adds realism to the surface.  </li> <li>Spines are placed as small spheres distributed along the stem.  </li> <li>Raymarching is used to find surface hits, and central difference computes normals.</li> </ul>"},{"location":"shaders/geometry/SDF_Cactus/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example Value <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Screen resolution <code>vec2</code> uniform <code>position</code> Base world-space position of cactus <code>vec3</code> <code>vec3(0.0, -0.2, -2.2)</code> <code>height</code> Vertical height of the cactus stem <code>float</code> <code>0.8</code> <code>radius</code> Radius of cactus body and arms <code>float</code> <code>0.1</code> <code>axis</code>, <code>angle</code> Rotation axis and angle (degrees) <code>vec3</code>, <code>float</code> <code>vec3(1,0,0)</code>, <code>0.0</code> <code>baseColor</code> Surface color of the cactus <code>vec3</code> <code>vec3(0.2, 0.5, 0.2)</code> <code>specularColor</code> Specular highlight color <code>vec3</code> <code>vec3(0.05)</code> <code>specularStrength</code> Strength of specular lighting <code>float</code> <code>0.2</code> <code>shininess</code> Phong shininess value <code>float</code> <code>32.0</code> <code>noiseAmount</code> Amplitude of surface noise <code>float</code> <code>0.25</code>"},{"location":"shaders/geometry/SDF_Cactus/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>float sdCapsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat evalCactusSDF(int i, vec3 p) {\n  vec3 probePt = transpose(_sdfRotation[i]) * (p - _sdfPositionFloat[i]);\n  float dMain = sdCapsule(probePt, height, radius);\n\n  vec3 pBranch1 = probePt - vec3(0.2, 0.4, 0.0);\n  pBranch1 = vec3(pBranch1.y, pBranch1.x, pBranch1.z);\n  float dBranch1 = sdCapsule(pBranch1, 0.5, radius * 0.6);\n\n  vec3 pBranch2 = probePt - vec3(-0.2, 0.4, 0.0);\n  pBranch2 = vec3(pBranch2.y, pBranch2.x, pBranch2.z);\n  float dBranch2 = sdCapsule(pBranch2, 0.5, radius * 0.6);\n\n  float base = min(dMain, min(dBranch1, dBranch2));\n  float noise = snoise(probePt * 5.0) * 0.1;\n  float baseWithNoise = base - noise * _sdfNoise[i];\n\n  vec3 decoColor;\n  float deco = addCactusDecorations(probePt, radius, decoColor);\n  return min(baseWithNoise, deco);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized screen coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float index = 0.0;\n\n    // Add a cactus to the scene\n    addCactus_float(\n        vec3(0.0, -0.2, -2.2),   // position\n        0.8,                     // height\n        0.1,                     // radius\n        index,\n        vec3(1.0, 0.0, 0.0),     // rotation axis\n        0.0,                     // rotation angle\n        vec3(0.2, 0.5, 0.2),     // base color (green)\n        vec3(0.05),              // specular color\n        0.2,                     // specular strength\n        32.0,                    // shininess\n        0.25,                    // noise intensity\n        index\n    );\n\n    // Ray origin and direction\n    vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    float dist;\n    int hitID = -1;\n\n    // Sphere tracing loop\n    for (int step = 0; step &lt; 100; step++) {\n        vec3 p = rayOrigin + t * rayDir;\n        dist = 1e5;\n\n        for (int i = 0; i &lt; 10; i++) {\n            if (_sdfTypeFloat[i] == 8) {\n                float d = evalSDF(i, p);\n                if (d &lt; dist) {\n                    dist = d;\n                    hitID = i;\n                }\n            }\n        }\n\n        if (dist &lt; 0.001) break;\n        t += dist;\n        if (t &gt; 10.0) break;\n    }\n\n    // Shading\n    if (t &lt; 10.0) {\n        vec3 hitPoint = rayOrigin + t * rayDir;\n\n        // Estimate normal by central differences\n        float eps = 0.001;\n        vec3 n;\n        vec2 e = vec2(1.0, -1.0) * 0.5773;\n        n = normalize(\n            e.xyy * evalSDF(hitID, hitPoint + e.xyy * eps) +\n            e.yyx * evalSDF(hitID, hitPoint + e.yyx * eps) +\n            e.yxy * evalSDF(hitID, hitPoint + e.yxy * eps) +\n            e.xxx * evalSDF(hitID, hitPoint + e.xxx * eps)\n        );\n\n        // Light and shading\n        vec3 lightDir = normalize(vec3(0.6, 1.0, 0.5));\n        float diff = max(dot(n, lightDir), 0.0);\n\n        vec3 color = _baseColorFloat[hitID] * diff;\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0); // Background black\n    }\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/geometry/SDF_Rock/","title":"\ud83e\udde9 SDF Rock Shader","text":"<ul> <li>Category: Geometry  </li> <li>Author: Wanzhang He  </li> <li>Shader Type: Grometry </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code> </li> <li>Output: Noisy procedural rock rendered via SDF and raymarching  </li> </ul>"},{"location":"shaders/geometry/SDF_Rock/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader renders a 3D rock using Signed Distance Field (SDF) with noise distortion.  </li> <li>Supports object rotation, surface normal estimation, and diffuse shading.  </li> <li>Uses a box primitive perturbed by simplex noise to create irregular rock forms.  </li> <li>A useful module for building procedural terrain or object libraries.</li> </ul>"},{"location":"shaders/geometry/SDF_Rock/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/geometry/SDF_Rock/#core-concept","title":"\ud83e\udea8 Core Concept","text":"<ul> <li>The base rock is a rotated box (<code>sdBox</code>) in local space.  </li> <li>To add realism, 3D simplex noise displaces the surface, creating bumpy detail.  </li> <li>Raymarching is used to detect the surface hit point.  </li> <li>Surface normal is estimated by central difference and shaded using Lambert lighting.</li> </ul>"},{"location":"shaders/geometry/SDF_Rock/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example Value <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Screen resolution <code>vec2</code> uniform <code>position</code> World-space position of the rock <code>vec3</code> <code>vec3(0.0, 0.0, -2.5)</code> <code>size</code> Half-size of the rock (box) <code>vec3</code> <code>vec3(0.4, 0.3, 0.5)</code> <code>axis</code>, <code>angle</code> Rotation axis and angle (degrees) <code>vec3</code>, <code>float</code> <code>vec3(0,1,0)</code>, <code>30.0</code> <code>baseColor</code> Rock surface color <code>vec3</code> <code>vec3(0.67, 0.52, 0.35)</code> <code>specularColor</code> Specular highlight color <code>vec3</code> <code>vec3(0.1)</code> <code>specularStrength</code> Specular coefficient <code>float</code> <code>0.2</code> <code>shininess</code> Phong shininess factor <code>float</code> <code>16.0</code> <code>noiseAmount</code> Strength of surface bump noise <code>float</code> <code>0.3</code>"},{"location":"shaders/geometry/SDF_Rock/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>float sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvoid addRock_float(...) {\n  _sdfTypeFloat[i] = 7;\n  _sdfPositionFloat[i] = position;\n  _sdfSizeFloat[i] = size;\n  _sdfRotation[i] = rotationMatrixFromAxisAngle(axis, angle);\n  _baseColorFloat[i] = baseColor;\n  _sdfNoise[i] = noiseAmount;\n}\n\nfloat evalSDF(int i, vec3 p) {\n  vec3 localP = transpose(_sdfRotation[i]) * (p - _sdfPositionFloat[i]);\n  float base = sdBox(localP, _sdfSizeFloat[i]);\n  float noise = snoise(localP * 5.0) * 0.1;\n  return base - noise * _sdfNoise[i];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float index = 0.0;\n\n    addRock_float(\n        vec3(0.0, 0.0, -2.5),      // position\n        vec3(0.4, 0.3, 0.5),       // size\n        index,\n        vec3(0.0, 1.0, 0.0),       // rotation axis\n        30.0,                      // angle in degrees\n        vec3(0.67, 0.52, 0.35),       // base color\n        vec3(0.1),                 // specular color\n        0.2,                       // specular strength\n        16.0,                      // shininess\n        0.3,                       // noise amount\n        index                      // output new index\n    );\n\n    // Just visualize as distance field:\n    vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    float dist;\n    int hitID = -1;\n\n    for (int step = 0; step &lt; 100; step++) {\n        vec3 p = rayOrigin + t * rayDir;\n        dist = 1e5;\n\n        for (int i = 0; i &lt; 10; i++) {\n            if (_sdfTypeFloat[i] == 7) {\n                float d = evalSDF(i, p);\n                if (d &lt; dist) {\n                    dist = d;\n                    hitID = i;\n                }\n            }\n        }\n\n        if (dist &lt; 0.001) break;\n        t += dist;\n        if (t &gt; 10.0) break;\n    }\n\n    if (t &lt; 10.0) {\n        vec3 hitPoint = rayOrigin + t * rayDir;\n\n        // Normal estimation by central difference\n        float eps = 0.001;\n        vec3 n;\n        vec2 e = vec2(1.0, -1.0) * 0.5773;\n        n = normalize(\n            e.xyy * evalSDF(hitID, hitPoint + e.xyy * eps) +\n            e.yyx * evalSDF(hitID, hitPoint + e.yyx * eps) +\n            e.yxy * evalSDF(hitID, hitPoint + e.yxy * eps) +\n            e.xxx * evalSDF(hitID, hitPoint + e.xxx * eps)\n        );\n\n        // Lambert lighting from one direction\n        vec3 lightDir = normalize(vec3(0.6, 1.0, 0.5));\n        float diff = max(dot(n, lightDir), 0.0);\n\n        // Apply diffuse light to base color\n        vec3 color = _baseColorFloat[hitID] * diff;\n\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0); // background\n    }\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/geometry/SDF_Shader/","title":"\ud83e\udde9 Signed Distance Field (SDF) Shader","text":"<ul> <li>Category: SDF</li> <li>Author: Saeed Shamseldin</li> </ul>"},{"location":"shaders/geometry/SDF_Shader/#overview","title":"Overview","text":"<p>This documentation covers the Signed Distance Field (SDF) module used in the GLSL shader. SDFs define 3D shapes mathematically, enabling raymarching-based rendering without using traditional polygon meshes.</p>"},{"location":"shaders/geometry/SDF_Shader/#key-features","title":"Key Features","text":"<ul> <li>Defines shapes via distance functions: <code>sdSphere</code>, <code>sdRoundBox</code>, <code>sdTorus</code></li> <li>Supports smooth blending between shapes using <code>smoothUnion()</code></li> <li>Enables volumetric effects like fog and clouds, and supports complex geometry like fractals</li> </ul>"},{"location":"shaders/geometry/SDF_Shader/#scene-composition","title":"Scene Composition","text":""},{"location":"shaders/geometry/SDF_Shader/#sdf-struct","title":"SDF Struct","text":"<pre><code>struct SDF {\n    int   type;      // Shape type (0=sphere, 1=box, 2=torus, etc)\n    vec3  position;  // World position\n    vec3  size;      // Dimensions (varies by type)\n    float radius;    // Rounding/radius\n    vec3  color;     // Base color\n};\n</code></pre>"},{"location":"shaders/geometry/SDF_Shader/#scene-evaluation","title":"Scene Evaluation","text":"<pre><code>float evaluateScene(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i &lt; 10; i++) {\n        float di = evalSDF(sdfArray[i], p); // Check each SDF\n        if (di &lt; d) d = di; // Track closest hit\n    }\n    return d;\n}\n</code></pre>"},{"location":"shaders/geometry/SDF_Shader/#normal-estimation","title":"Normal Estimation","text":"<p>Calculates surface normals for lighting using central differences:</p> <pre><code>vec3 SDFsNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1, -1);\n    return normalize(\n        k.xyy * evaluateScene(p + k.xyy * h) + // X-axis\n        k.yyx * evaluateScene(p + k.yyx * h) + // Y-axis\n        k.yxy * evaluateScene(p + k.yxy * h) + // Z-axis\n        k.xxx * evaluateScene(p + k.xxx * h)\n    );\n}\n</code></pre>"},{"location":"shaders/geometry/SDF_Shader/#raymarching-integration","title":"Raymarching Integration","text":"<p>Basic Raymarching Loop</p> <p><pre><code>float raymarch(vec3 ro, vec3 rd, out vec3 hitPos) {\n    float t = 0.0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = evaluateScene(p); // Query SDF\n        if (d &lt; 0.001) { \n            hitPos = p; \n            return t; // Hit!\n        }\n        t += d; // March forward\n        if (t &gt; 50.0) break; // Max distance\n    }\n    return -1.0; // Miss\n}\n</code></pre> Optimizations</p> <p>Early Termination \u2013 Exit the loop as soon as a surface is hit</p> <p>Distance Clamping \u2013 Break the loop if t &gt; maxDist to avoid unnecessary</p>"},{"location":"shaders/geometry/SDF_Sphere/","title":"\ud83e\udde9 SDF Sphere Raymarch Shader","text":"<ul> <li>Category: Geometry </li> <li>Author: Wanzhang He</li> <li>Shader Type: 3D primitive via signed distance field  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code> </li> <li>Output: Raymarched red sphere with basic diffuse lighting</li> </ul>"},{"location":"shaders/geometry/SDF_Sphere/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader uses Signed Distance Field (SDF) and sphere tracing to render a 3D sphere.</li> <li>Implements normal estimation using central differences.</li> <li>Provides diffuse shading with a fixed directional light.</li> <li>A useful base for learning SDF-based rendering and raymarching geometry.</li> </ul>"},{"location":"shaders/geometry/SDF_Sphere/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/geometry/SDF_Sphere/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<ul> <li>Distance Function: A sphere is defined as <code>length(pos) - radius</code>.</li> <li>Raymarching: The ray steps through space until it hits a surface (<code>d &lt; threshold</code>).</li> <li>Normal Calculation: Central differences estimate surface gradient.</li> <li>Shading: Simple diffuse lighting based on normal\u2013light dot product.</li> </ul>"},{"location":"shaders/geometry/SDF_Sphere/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Screen resolution <code>vec2</code> uniform <code>radius</code> Sphere radius (in scene function) <code>float</code> <code>0.3</code> <code>camera_pos</code> Camera position <code>vec3</code> <code>vec3(0,0,1.5)</code>"},{"location":"shaders/geometry/SDF_Sphere/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>float scene(vec3 position) {\n    float radius = 0.3;\n    return length(position) - radius;\n}\n\nvec3 getNormal(vec3 pos, float smoothness) {\n    vec3 n;\n    vec2 dn = vec2(smoothness, 0.0);\n    n.x = scene(pos + dn.xyy) - scene(pos - dn.xyy);\n    n.y = scene(pos + dn.yxy) - scene(pos - dn.yxy);\n    n.z = scene(pos + dn.yyx) - scene(pos - dn.yyx);\n    return normalize(n);\n}\n\nfloat raymarch(vec3 position, vec3 direction) {\n    float total_distance = 0.0;\n    for (int i = 0; i &lt; 32; ++i) {\n        float d = scene(position + direction * total_distance);\n        if (d &lt; 0.005) return total_distance;\n        total_distance += d;\n    }\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera_pos = vec3(0.0, 0.0, 1.5);\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - camera_pos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 ray_dir = normalize(uv.x * right + uv.y * up + forward);\n\n    float dist = raymarch(camera_pos, ray_dir);\n\n    vec3 color;\n    if (dist &gt; 0.0) {\n        vec3 hit_pos = camera_pos + ray_dir * dist;\n        vec3 normal = getNormal(hit_pos, 0.001);\n        vec3 light_dir = normalize(vec3(0.8, 0.6, 1.0));\n        float diffuse = max(dot(normal, light_dir), 0.0);\n        color = vec3(1.0, 0.3, 0.2) * diffuse;\n    } else {\n        color = vec3(0.9);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/geometry/SDF_Square/","title":"\ud83e\udde9 SDF Square Shader","text":"<ul> <li>Category: Geometry</li> <li>Author: Wanzhang He</li> <li>Shader Type: 2D Primitive (SDF)  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code> </li> <li>Output: Red square in white background using SDF logic</li> </ul>"},{"location":"shaders/geometry/SDF_Square/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader draws a centered red square using a Signed Distance Function (SDF).</li> <li>It normalizes and aspect-corrects the UV coordinates for pixel-perfect squares.</li> <li>Fragments inside the square are red, outside are white.</li> <li>Useful as a basic primitive test, SDF intro, or 2D shape module.</li> </ul>"},{"location":"shaders/geometry/SDF_Square/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/geometry/SDF_Square/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>The shader computes the signed distance to an axis-aligned square, then uses that distance to choose color:</p> <ul> <li>Distance \u2264 0 \u2192 inside square \u2192 red</li> <li>Distance &gt; 0 \u2192 outside square \u2192 white</li> </ul> <p>It also corrects for non-square screen aspect ratio to avoid stretching.</p>"},{"location":"shaders/geometry/SDF_Square/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Screen resolution <code>vec2</code> uniform <code>size</code> Half the square\u2019s side length <code>float</code> <code>0.2</code> <code>offset</code> UV center position of the square <code>vec2</code> <code>vec2(0.0)</code>"},{"location":"shaders/geometry/SDF_Square/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>vec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float d = max(abs(x), abs(y)) - size;\n  return d &gt; 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  uv -= 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n  vec2 offset = vec2(0.0, 0.0);\n  vec3 col = sdfSquare(uv, 0.2, offset);\n  fragColor = vec4(col, 1.0);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/geometry/raymarching_sdf/","title":"\ud83e\udde9 SDF with Ray Marching Shader","text":"<ul> <li>Category: Geometry  </li> <li>Author: Shader Team  </li> <li>Shader Type: Raymarching with SDFs  </li> <li>Inputs: <code>t</code> \u2014 time for raymarching loop (0 \u2192 100)</li> </ul>"},{"location":"shaders/geometry/raymarching_sdf/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/geometry/raymarching_sdf/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader implements raymarching using signed distance fields (SDFs) to render procedurally generated geometry in real-time. Unlike traditional mesh-based rendering:</p> <ul> <li>The scene is described using mathematical distance functions for each shape.</li> <li>A raymarch loop iteratively steps forward from the camera along the ray until a surface is hit or the max steps/distance is reached.</li> <li>Lighting is applied using surface normal approximation using phong lighting model.</li> </ul> <p>This makes it perfect for real-time visuals with minimal mesh overhead \u2014 and easily portable across engines like Unity, Godot, and Unreal.</p>"},{"location":"shaders/geometry/raymarching_sdf/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Input Name Type Description <code>t</code> <code>float</code> Looping time variable for raymarching (0\u2013100) <code>UV</code> <code>vec2</code> Default Godot input for pixel coordinates <code>resolution</code> <code>vec2</code> Optional \u2014 screen or texture resolution for scaling"},{"location":"shaders/geometry/raymarching_sdf/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<p>\ud83d\udd17 View Full Shader Code on GitHub</p> \ud83d\udcc4 sdf_updated.gdshader <pre><code>    shader_type canvas_item;\n\n    #include \"res://addons/includes/sdf_updated.gdshaderinc\"\n    void fragment() {\n        vec4 color;\n    vec3 lightPosition = camera_position;\n    IntegrationFlexible(UV, color, lightPosition);\n        COLOR = color;\n\n    }\n</code></pre> \ud83d\udcc4 sdf_updated.gdshaderinc <pre><code>    // Integration Shader\n    //=========Neu =====================\n\n    #include \"res://addons/includes/helper_functions/helper_func.gdshaderinc\"\n\n    // Maximum number of objects\n    const int MAX_OBJECTS=10;\n    //uniform int MAX_OBJECTS;\n    // Flattened arrays for SDF object data\n    uniform int obj_type[MAX_OBJECTS];\n    uniform vec3 obj_position[MAX_OBJECTS];\n    uniform vec3 obj_size[MAX_OBJECTS];\n    uniform float obj_radius[MAX_OBJECTS];\n    uniform vec3 obj_color[MAX_OBJECTS];\n    uniform vec2 screen_resolution;\n    // Count of actual input objects\n    uniform int inputCount;\n    uniform vec3 specularColorFloat[MAX_OBJECTS];\n    uniform float specularStrengthFloat[MAX_OBJECTS];\n    uniform float shininessFloat[MAX_OBJECTS];\n    // Other common global uniforms (optional, depending on usage)\n    //uniform vec3 lightPosition;\n    //uniform float _GammaCorrect;\n    //uniform float _Resolution;\n    // for camera position and ray dirction\n    uniform vec3 camera_position;\n    uniform vec3 look_at_position;\n    //camera\n    uniform vec4 _mousePoint;\n    uniform vec4 _ScreenParams;\n    uniform float iTime;\n\n\n    //from SDF shader\n    void applyPhongLighting_float(vec3 hitPos, int hitID, vec3 lightPosition, vec3 cameraPosition, vec3 normal, vec3 baseColor, vec3 specularColor, float specularStrength, float shininess, out vec3 lightingColor)\n    {\n        vec3 viewDir, lightDir, lightColor, ambientColor;\n        lightingContext(hitPos, lightPosition, cameraPosition , viewDir, lightDir, lightColor, ambientColor);\n\n        normal = normalize(normal);\n        float diff = max(dot(normal, lightDir), 0.15); // change from 0.0 to 0.15 Lambertian diffuse\n\n        vec3 R = reflect(-lightDir, normal); // Reflected light direction\n        float spec = pow(max(dot(R, viewDir), 0.0), shininess); // Phong specular\n\n        //float3 colour = _sdfTypeFloat[hitID] == 3 ? getDolphinColor(hitPos, normal, lightPosition) : _baseColorFloat[hitID];\n        vec3 colour = baseColor;\n        vec3 diffuse = diff * colour * lightColor;\n        vec3 specular = spec * specularColor * specularStrength;\n\n        // FIXED: Increased ambient lighting\n        vec3 enhancedAmbient = ambientColor * baseColor * 0.4; // \u2705 Changed from 0.1 to 0.4\n\n        lightingColor = enhancedAmbient + diffuse + specular;\n\n    // if (hitPos.z == 0.0)\n        //{\n        // lightingColor = vec3(0, 0, 0);\n        //}\n    }\n\n    //=============================\n\n    float sdSphere(vec3 position, float radius)\n    {\n        return length(position) - radius;\n    }\n\n    float sdRoundBox(vec3 p, vec3 b, float r)\n    {\n        vec3 q = abs(p) - b + r;\n        return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r;\n    }\n\n    float sdTorus(vec3 p, vec2 radius)\n    {\n        vec2 q = vec2(length(p.xy) - radius.x, p.z);\n        return length(q) - radius.y;\n    }\n\n    float evalSDF(int type,vec3 position ,vec3 size, float radius,vec3 p)\n    {\n        if (type == 0)\n        {\n            return sdSphere(p - position, radius);\n        }\n        else if (type == 1)\n        {\n            return sdRoundBox(p - position, size, radius);\n        }\n        else if (type == 2)\n            return sdTorus(p - position,size.yz);\n\n        return 100000.;\n    }\n\n    float evaluateScene(vec3 p ,out int gHitID )\n    {\n        float d = 100000.;\n        int bestID = -1;\n        for (int i = 0; i &lt; inputCount; ++i)\n        {\n            float di = evalSDF(obj_type[i],obj_position[i],obj_size[i],obj_radius[i], p);\n            if (di &lt; d)\n            {\n                d = di;\n                bestID = i;\n            }\n\n        }\n        gHitID = bestID;\n        return d;\n    }\n\n    vec3 getNormal(vec3 p)\n    {\n        float h = 0.0001;\n        vec2 k = vec2(1, -1);\n        int dummy;\n        return normalize(k.xyy * evaluateScene(p + k.xyy * h,dummy) + k.yyx * evaluateScene(p + k.yyx * h,dummy) + k.yxy * evaluateScene(p + k.yxy * h,dummy) + k.xxx * evaluateScene(p + k.xxx * h,dummy));\n    }\n\n    vec2 GetGradient(vec2 intPos, float t)\n    {\n        float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.547);\n        float angle = 6.283185 * rand + 4. * t * rand;\n        return vec2(cos(angle), sin(angle));\n    }\n\n    float Pseudo3dNoise(vec3 pos)\n    {\n        vec2 i = floor(pos.xy);\n        vec2 f = fract(pos.xy);\n        vec2 blend = f * f * (3. - 2. * f);\n        float a = dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0., 0.));\n        float b = dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1., 0.));\n        float c = dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0., 1.));\n        float d = dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1., 1.));\n        float xMix = mix(a, b, blend.x);\n        float yMix = mix(c, d, blend.x);\n        return mix(xMix, yMix, blend.y) / 0.7;\n    }\n\n    float fbmPseudo3D(vec3 p, int octaves)\n    {\n        float result = 0.;\n        float amplitude = 0.5;\n        float frequency = 1.;\n        for (int i = 0; i &lt; octaves; ++i)\n        {\n            result += amplitude * Pseudo3dNoise(p * frequency);\n            frequency *= 2.;\n            amplitude *= 0.5;\n        }\n        return result;\n    }\n\n    vec4 hash44(vec4 p)\n    {\n        p = fract(p * vec4(0.1031, 0.103, 0.0973, 0.1099));\n        p += dot(p, p.wzxy + 33.33);\n        return fract((p.xxyz + p.yzzw) * p.zywx);\n    }\n\n    float n31(vec3 p)\n    {\n        const vec3 S = vec3(7., 157., 113.);\n        vec3 ip = floor(p);\n        p = fract(p);\n        p = p * p * (3. - 2. * p);\n        vec4 h = vec4(0., S.yz, S.y + S.z) + dot(ip, S);\n        h = mix(hash44(h), hash44(h + S.x), p.x);\n        h.xy = mix(h.xz, h.yw, p.y);\n        return mix(h.x, h.y, p.z);\n    }\n\n    float fbm_n31(vec3 p, int octaves)\n    {\n        float value = 0.;\n        float amplitude = 0.5;\n        for (int i = 0; i &lt; octaves; ++i)\n        {\n            value += amplitude * n31(p);\n            p *= 2.;\n            amplitude *= 0.5;\n        }\n        return value;\n    }\n\n    struct MaterialParams\n    {\n        vec3 baseColor;\n        vec3 specularColor;\n        float specularStrength;\n        float shininess;\n        float roughness;\n        float metallic;\n        float rimPower;\n        float fakeSpecularPower;\n        vec3 fakeSpecularColor;\n        float ior;\n        float refractionStrength;\n        vec3 refractionTint;\n    };\n    MaterialParams createDefaultMaterialParams(vec3 color,vec3 specularColor, float specularStrength,float shininess)\n    {\n        MaterialParams mat;\n        //Dyamic fro gd script\n        mat.baseColor = color;\n        mat.specularColor = specularColor;\n        mat.specularStrength = specularStrength;\n        mat.shininess = shininess;\n\n        mat.roughness = 0.5;\n        mat.metallic = 0.;\n        mat.rimPower = 2.;\n        mat.fakeSpecularPower = 32.;\n        mat.fakeSpecularColor = vec3(1.0);\n        mat.ior = 1.45;\n        mat.refractionStrength = 0. ;\n        mat.refractionTint = vec3(1.0);\n        return mat;\n    }\n\n    MaterialParams makePlastic(vec3 color,vec3 specularColor, float specularStrength,float shininess  )\n    {\n        MaterialParams mat = createDefaultMaterialParams( color,specularColor,specularStrength,shininess);\n        mat.metallic = 0.;\n        mat.roughness = 0.4;\n        mat.specularStrength = 0.5; //special value for plastic\n        return mat;\n    }\n\n\n\n    float raymarch(vec3 ro, vec3 rd, out vec3 hitPos, out int gHitID )\n    {\n        gHitID = -1;\n        hitPos = vec3(0.0);\n        float t = 0.;\n        for (int i = 0; i &lt; 100; i++)\n        {\n            vec3 p = ro + rd * t;\n            float noise = fbmPseudo3D(p, 1);\n            float d = evaluateScene(p, gHitID) + noise * 0.3;\n            if (d &lt; 0.001)\n            {\n                hitPos = p;\n                return t;\n            }\n\n            if (t &gt; 50.)\n                break;\n\n            t += d;\n        }\n        return -1.;\n    }\n\n    // Add this before IntegrationFlexible, inside sdf_updated.gdshaderinc\n\n    void moveCamera_float(vec2 uv, out vec3 rayOrigin, out vec3 rayDirection)\n    {\n        vec2 mouse = (_mousePoint.xy == vec2(0.0)) ? vec2(0.0) : _mousePoint.xy / screen_resolution;\n\n        float xCameraAngle = 1.2 - 12.0 * (mouse.x - 0.5);\n        float yCameraAngle = 1.2 - 12.0 * (mouse.y - 0.5);\n        rayOrigin = vec3(4.0 * sin(xCameraAngle), 4.0 * cos(yCameraAngle), 10.0);\n\n        vec3 forward = normalize(-rayOrigin);\n        vec3 right = normalize(vec3(-forward.z, 0.0, forward.x));\n        vec3 up = normalize(cross(right, forward));\n\n        rayDirection = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    }\n\n    void IntegrationFlexibleFixed(vec2 INuv, out vec4 frgColor3, vec3 lightPosition)\n    {\n        vec4 frgColor = vec4(0.0);\n        vec2 fragCoord = INuv * screen_resolution;\n        vec2 uv = fragCoord / screen_resolution.xy * 2.0 - 1.0;\n        uv.x *= screen_resolution.x / screen_resolution.y;\n\n        // IMPROVED CAMERA SETUP:\n        vec3 ro = camera_position;\n        vec3 target = look_at_position;\n\n        // Use your helper function for better camera basis\n        mat3 camera_basis = compute_camera_basis(target, ro);\n        vec3 rd = normalize(camera_basis * vec3(uv, -1.5)); // Changed from 2.0 to -1.5\n\n        vec3 hitPos;\n        int gHitID;\n        float t = raymarch(ro, rd, hitPos, gHitID);\n        vec3 color;\n\n        if (t &gt; 0.0)\n        {\n            // Get surface normal\n            vec3 normal = getNormal(hitPos);\n\n            // Get material properties\n            vec3 base_color = obj_color[gHitID];\n            vec3 specular_color = specularColorFloat[gHitID];\n            float shininess = shininessFloat[gHitID];\n            float specular_strength = specularStrengthFloat[gHitID];\n\n            // Apply improved lighting\n            applyPhongLighting_float(\n                hitPos,\n                gHitID,\n                lightPosition,\n                ro, // camera position\n                normal,\n                base_color,\n                specular_color,\n                specular_strength,\n                shininess,\n                color\n            );\n        }\n        else\n        {\n            // Background color - make it consistent\n            color = vec3(0.1, 0.1, 0.2);\n        }\n\n        frgColor = vec4(color, 1.0);\n        frgColor3 = frgColor;\n    }\n\n    void IntegrationFlexible(vec2 INuv, out vec4 frgColor3,vec3 lightPosition)\n    {\n        //initilize SDF Array\n        //SDF sdfArray[MAX_OBJECTS];\n        vec4 frgColor = vec4(0.0);\n        vec2 fragCoord = INuv * screen_resolution;\n        vec2 uv = fragCoord / screen_resolution.xy * 2. - 1.;\n        uv.x *= screen_resolution.x / screen_resolution.y;\n\n    // for (int i = 0; i &lt; inputCount; ++i)\n    // {\n    //     int t = objInputs[i].type;\n    //     if (t == 0)\n    //         sdfArray[i] = createSphere(objInputs[i].position, objInputs[i].radius);\n    //    else if (t == 1)\n        //        sdfArray[i] = createRoundedBox(objInputs[i].position, objInputs[i].size, objInputs[i].radius);\n        //   else if (t == 2)\n        //     sdfArray[i] = createTorus(objInputs[i].position, objInputs[i].size, objInputs[i].radius);\n        //}\n        ///////////////\n\n    //    for (int i = 0; i &lt; inputCount; ++i)\n    //   {\n    //     //int t = objInputs[i].type;\n            //if (t == 0)\n        //    obj_type[i]=sdfArray[i].type;\n        //  obj_position[i]=sdfArray[i].position\n            //obj_size[i]=sdfArray[i].size\n        // obj_radius[i]=sdfArray[i].radius\n\n            //else if (t == 1)\n            // sdfArray[i] = createRoundedBox(objInputs[i].position, objInputs[i].size, objInputs[i].radius);\n        // else if (t == 2)\n                //sdfArray[i] = createTorus(objInputs[i].position, objInputs[i].size, objInputs[i].radius);\n        //}\n\n        /////////////\n        //vec3 ro = vec3(0, 0, 7); // Camera origin\n    // vec3 rd = normalize(vec3(uv, -1)); // Ray direction\n\n    //vec3 ro, rd;\n        //moveCamera_float(uv, ro, rd);\n\n        // IMPROVED CAMERA SETUP:\n        vec3 ro = camera_position;\n        vec3 target = look_at_position;\n\n        // Use your helper function for better camera basis\n        mat3 camera_basis = compute_camera_basis(target, ro);\n        vec3 rd = normalize(camera_basis * vec3(uv, -1.0)); // Changed from 2.0 to -1.5\n\n        //vec3 rd=look_at_position-ro;\n        vec3 hitPos;\n        int gHitID;\n        float t = raymarch(ro, rd, hitPos,gHitID);\n        vec3 color;\n        //bool sdfHitSuccess = t &gt; 0.;\n\n\n        //vec3 finalColor;\n\n\n        if (t &gt; 0.)\n        {\n            vec3 normal = getNormal(hitPos);\n            vec3 viewDir = normalize(ro - hitPos);\n            vec3 lightColor = vec3(1., 1., 1.);\n            vec3 L = normalize(lightPosition - hitPos);\n            vec3 ambientCol = vec3(0.1, 0.1, 0.1);\n            //color = applyPhongLighting(ctx, mat);\n            vec3 base_color = obj_color[gHitID];\n            vec3 specular_color = specularColorFloat[gHitID];\n            float shininess = shininessFloat[gHitID];\n            float specular_strength = specularStrengthFloat[gHitID];\n\n            MaterialParams mat;\n            if (gHitID &gt;= 0 &amp;&amp; gHitID &lt; MAX_OBJECTS)\n            {\n                mat = makePlastic(base_color,specular_color,specular_strength,shininess);\n            }\n            else\n            {\n                mat = createDefaultMaterialParams(base_color,specular_color,specular_strength,shininess);\n            }\n\n\n            applyPhongLighting_float( hitPos,gHitID, lightPosition, ro, normal, mat.baseColor,mat.specularColor ,mat.specularStrength,mat.shininess,color);\n        }\n    else\n        {\n                color = vec3(1.0, 1.0, 1.0);\n        }\n\n        frgColor = vec4(color, 1.0);\n        //if (_GammaCorrect)\n            //frgColor.rgb = pow(frgColor.rgb, 2.2);\n\n        frgColor3 = frgColor;\n    }\n\n    //#endif\n</code></pre> \ud83d\udcc4 helper_func.gdshaderinc <pre><code>    void lightingContext(vec3 hitPos, vec3 lightPosition, vec3 cameraPos, out vec3 viewDir, out vec3 lightDir, out vec3 lightColor, out vec3 ambientColor)\n    {\n        viewDir = normalize(cameraPos - hitPos); // Use the actual camera position\n        lightDir = normalize(lightPosition - hitPos);\n        lightColor = vec3(1.0, 1.0, 1.0);\n        ambientColor = vec3(0.1, 0.1, 0.1);\n    }\n\n\n    // Computes a camera basis matrix (right, up, -forward) given eye and target position\n    mat3 compute_camera_basis(vec3 look_at_pos, vec3 eye) {\n        vec3 f = normalize(look_at_pos - eye);            // Forward\n        vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // Right\n        vec3 u = cross(r, f);                              // Up\n        return mat3(r, u, -f); // Column-major matrix for camera orientation\n    }\n</code></pre> \ud83d\udcc4 sdf_updated.gd (GDScript) <pre><code>    extends Node2D\n\n    @export var shader_material_target: CanvasItem\n    @export var MAX_OBJECTS := 10\n    @export var use_dynamic_look_at := false\n\n    class ShaderObject:\n        var type: int\n        var position: Vector3\n        var size: Vector3\n        var radius: float\n        var color: Vector3\n        var specular_color: Vector3 = Vector3.ONE\n        var specular_strength: float = 0.5\n        var shininess: float = 32.0\n\n        func set_values(t, pos, sz, r, c, spec_col := Vector3.ONE, spec_str := 1.0, shin := 32.0) -&gt; ShaderObject:\n            type = t\n            position = pos\n            size = sz\n            radius = r\n            color = c\n            specular_color = spec_col\n            specular_strength = spec_str\n            shininess = shin\n            return self\n\n    var shader_objects := []\n\n    func _ready():\n        shader_objects = [\n            ShaderObject.new().set_values(0, Vector3(0, 0, 0), Vector3.ZERO, 1.0, Vector3(0.2, 0.2, 1.0)),\n            ShaderObject.new().set_values(1, Vector3(1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2)),\n            ShaderObject.new().set_values(1, Vector3(-1.9, 0, 0), Vector3(1, 1, 1), 0.2, Vector3(0.2, 1.0, 0.2)),\n            ShaderObject.new().set_values(2, Vector3(0, 0, 0), Vector3(1, 5, 1.5), 0.2, Vector3(1.0, 0.2, 0.2))\n        ]\n        fill_shader_parameters(shader_objects)\n\n    func _process(delta):\n        update_shader_uniforms()\n\n    func fill_shader_parameters(obj_list: Array):\n        var mat := shader_material_target.material\n        if mat == null or not mat is ShaderMaterial:\n            push_error(\"No valid ShaderMaterial found!\")\n            return\n\n        var count := min(obj_list.size(), MAX_OBJECTS)\n\n        var types := PackedInt32Array()\n        var positions := PackedVector3Array()\n        var sizes := PackedVector3Array()\n        var radii := PackedFloat32Array()\n        var colors := PackedVector3Array()\n        var specular_colors := PackedVector3Array()\n        var specular_strengths := PackedFloat32Array()\n        var shininesses := PackedFloat32Array()\n\n        for obj in obj_list:\n            types.append(obj.type)\n            positions.append(obj.position)\n            sizes.append(obj.size)\n            radii.append(obj.radius)\n            colors.append(obj.color)\n            specular_colors.append(obj.specular_color)\n            specular_strengths.append(obj.specular_strength)\n            shininesses.append(obj.shininess)\n\n        while types.size() &lt; MAX_OBJECTS:\n            types.append(0)\n            positions.append(Vector3.ZERO)\n            sizes.append(Vector3.ZERO)\n            radii.append(0.0)\n            colors.append(Vector3.ZERO)\n            specular_colors.append(Vector3.ONE)\n            specular_strengths.append(0.0)\n            shininesses.append(1.0)\n\n        mat.set_shader_parameter(\"obj_type\", types)\n        mat.set_shader_parameter(\"obj_position\", positions)\n        mat.set_shader_parameter(\"obj_size\", sizes)\n        mat.set_shader_parameter(\"obj_radius\", radii)\n        mat.set_shader_parameter(\"obj_color\", colors)\n        mat.set_shader_parameter(\"specularColorFloat\", specular_colors)\n        mat.set_shader_parameter(\"specularStrengthFloat\", specular_strengths)\n        mat.set_shader_parameter(\"shininessFloat\", shininesses)\n        mat.set_shader_parameter(\"inputCount\", count)\n\n    func update_shader_uniforms():\n        var mat := shader_material_target.material\n        if mat == null or not mat is ShaderMaterial:\n            return\n\n        var screen_size := get_viewport().get_visible_rect().size\n        var mouse_pos := get_viewport().get_mouse_position()\n\n        # Update common uniforms\n        mat.set_shader_parameter(\"screen_resolution\", screen_size)\n        mat.set_shader_parameter(\"_ScreenParams\", Vector4(screen_size.x, screen_size.y, 0, 0))\n        mat.set_shader_parameter(\"_mousePoint\", Vector4(mouse_pos.x, mouse_pos.y, 0, 0))\n        mat.set_shader_parameter(\"iTime\", Time.get_ticks_msec() / 1000.0)\n\n        # Orbit-style camera controlled by mouse\n        var x_angle = (mouse_pos.x / screen_size.x - 0.5) * TAU\n        var y_angle = clamp((mouse_pos.y / screen_size.y - 0.5) * PI, -PI * 0.4, PI * 0.4)\n\n        var radius = 12.0\n        var cam_x = radius * cos(y_angle) * sin(x_angle)\n        var cam_y = radius * sin(y_angle)\n        var cam_z = radius * cos(y_angle) * cos(x_angle)\n        var cam_pos = Vector3(cam_x, cam_y, cam_z)\n\n        mat.set_shader_parameter(\"camera_position\", cam_pos)\n\n        if use_dynamic_look_at:\n            mat.set_shader_parameter(\"look_at_position\", get_scene_center())\n        else:\n            mat.set_shader_parameter(\"look_at_position\", Vector3(0, 0, 0))\n\n    func get_scene_center() -&gt; Vector3:\n        if shader_objects.is_empty():\n            return Vector3.ZERO\n        var center := Vector3.ZERO\n        for obj in shader_objects:\n            center += obj.position\n        return center / shader_objects.size()\n</code></pre>"},{"location":"shaders/lighting/Lighting_and_Material_System/","title":"Lighting and Material System Shader","text":"<ul> <li>Category: Lighting &amp; Material</li> <li>Author: Saeed Shamseldin </li> </ul>"},{"location":"shaders/lighting/Lighting_and_Material_System/#overview","title":"Overview","text":"<p>This documentation covers the Phong-based lighting model and material system used in the GLSL shader. The system provides realistic shading for SDF-rendered objects, supporting:</p> <ul> <li> <p>Diffuse/specular lighting</p> </li> <li> <p>Custom material properties (plastic, metals, etc.)</p> </li> <li> <p>Dynamic normal mapping (via SDF derivatives)</p> </li> </ul>"},{"location":"shaders/lighting/Lighting_and_Material_System/#core-components","title":"Core Components","text":"<p>A. Lighting Model</p> <p>Based on the Phong reflection model, with three components:</p> <ol> <li> <p>Ambient: Base illumination (constant).</p> </li> <li> <p>Diffuse: Lambertian scattering (depends on surface normal).</p> </li> <li> <p>Specular: Glossy highlights (depends on view direction).</p> </li> </ol> <p>B. Material Properties</p> <p>Controlled by four parameters:</p> Parameter Description Example Values <code>BaseColor</code> Albedo (RGB) <code>vec3(1.0, 0.0, 0.0)</code> (red) <code>SpecularColor</code> Highlight tint <code>vec3(1.0)</code> (white) <code>SpecularStrength</code> Highlight intensity <code>0.5</code> (medium) <code>Shininess</code> Highlight tightness <code>32.0</code> (plastic)"},{"location":"shaders/lighting/Lighting_and_Material_System/#key-functions","title":"Key Functions","text":"<p>A. applyPhongLighting()</p> <p>Calculates the final pixel color using Phong shading.</p> Parameter Type Description <code>Position</code> <code>vec3</code> World-space hit point <code>Normal</code> <code>vec3</code> Surface normal (unit vector) <code>ViewDir</code> <code>vec3</code> Direction to camera (<code>normalize(camPos - Position)</code>) <code>LightPos</code> <code>vec3</code> World-space light position <code>LightColor</code> <code>vec3</code> RGB light color <code>AmbientColor</code> <code>vec3</code> Ambient light (constant) <code>BaseColor</code> <code>vec3</code> Material albedo <code>SpecularColor</code> <code>vec3</code> Specular tint <code>SpecularStrength</code> <code>float</code> Highlight intensity <code>Shininess</code> <code>float</code> Highlight exponent (higher = sharper) <code>OutputColor</code> <code>out vec3</code> Final shaded color <p>Implementation <pre><code>void applyPhongLighting(\n    vec3 Position, vec3 Normal, vec3 ViewDir,\n    vec3 LightPos, vec3 LightColor, vec3 AmbientColor,\n    vec3 BaseColor, vec3 SpecularColor, float SpecularStrength, float Shininess,\n    out vec3 OutputColor\n) {\n    // Diffuse (Lambertian)\n    vec3 L = normalize(LightPos - Position);\n    float diff = max(dot(Normal, L), 0.0);\n    vec3 diffuse = diff * BaseColor * LightColor;\n\n    // Specular (Phong)\n    vec3 R = reflect(-L, Normal);\n    float spec = pow(max(dot(R, ViewDir), 0.0), Shininess);\n    vec3 specular = spec * SpecularColor * SpecularStrength;\n\n    // Combine\n    OutputColor = AmbientColor + diffuse + specular;\n}\n</code></pre></p> <p>B. MakePlasticMaterial()</p> <p>Configures a plastic-like material.</p> Parameter Type Description <code>Color</code> <code>vec3</code> Albedo color <code>specularcolor</code> <code>vec3</code> Specular tint (usually white) <code>specularstrength</code> <code>float</code> Highlight intensity (e.g., <code>0.5</code>) <code>shininess</code> <code>float</code> Highlight exponent (e.g., <code>32.0</code>) <code>BaseColor</code> <code>out vec3</code> Output albedo <code>SpecularColor</code> <code>out vec3</code> Output specular tint <code>SpecularStrength</code> <code>out float</code> Output highlight strength <code>Shininess</code> <code>out float</code> Output shininess <p>Implementation <pre><code>void MakePlasticMaterial(\n    vec3 Color, vec3 specularcolor, float specularstrength, float shininess,\n    out vec3 BaseColor, out vec3 SpecularColor, out float SpecularStrength, out float Shininess\n) {\n    BaseColor = Color;\n    SpecularColor = specularcolor;\n    SpecularStrength = specularstrength;\n    Shininess = shininess;\n}\n</code></pre> Integration with Raymarching</p> <ol> <li> <p>After raymarching, call <code>SDFsNormal(hitPos)</code> to get normals.</p> </li> <li> <p>Configure materials using MakePlasticMaterial().</p> </li> <li> <p>Apply lighting via applyPhongLighting().</p> </li> </ol>"},{"location":"shaders/lighting/Rim_lighting_and_reflection/","title":"\ud83e\udde9 Rim Reflection Lighting Shader","text":"<ul> <li>Category: Lighting  </li> <li>Author: Wanzhang He  </li> <li>Shader Type: Surface lighting effect (rim + reflection)  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code>, <code>iChannel1</code> </li> <li>Output: Fragment color with rim light and environment reflection</li> </ul>"},{"location":"shaders/lighting/Rim_lighting_and_reflection/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader computes rim lighting (highlighting object edges facing away from the viewer) and reflection (sampling environment from <code>iChannel1</code>).</li> <li>Useful for toon shading, highlight effects, or reflective surfaces like plastic, glass, and wet materials.</li> <li>Uses a fake 3D sphere generated from 2D UVs to simulate surface normals.</li> </ul>"},{"location":"shaders/lighting/Rim_lighting_and_reflection/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/lighting/Rim_lighting_and_reflection/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<ul> <li> <p>Rim Lighting:   A soft glow appears near edges (when <code>dot(N, viewDir)</code> is small). It is computed as: <code>rim = max(0.0, 0.7 + dot(N, viewDir))</code></p> </li> <li> <p>Reflection:   Computes reflection vector <code>reflect(dir, N)</code> and samples <code>iChannel1</code> to simulate environment reflection.</p> </li> <li> <p>Final color is a combination: <code>rimColor + reflection</code></p> </li> </ul>"},{"location":"shaders/lighting/Rim_lighting_and_reflection/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Viewport resolution <code>vec2</code> uniform <code>iChannel1</code> Environment texture for reflection <code>sampler2D</code> Bayer or HDRI"},{"location":"shaders/lighting/Rim_lighting_and_reflection/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>vec4 computeRimReflectionLighting(vec3 dir, vec3 N) {\n    vec3 ref = reflect(dir, N);\n    vec2 uv_ref = ref.xy * 0.5 + 0.5;\n\n    float rim = max(0.0, 0.7 + dot(N, dir));\n    vec4 rimColor = vec4(rim, rim * 0.5, 0.0, 1.0);\n    vec4 reflection = texture(iChannel1, uv_ref) * 0.3;\n\n    return rimColor + reflection;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = length(uv);\n    if (r &gt; 0.8) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec3 N = normalize(vec3(uv, sqrt(1.0 - clamp(dot(uv, uv), 0.0, 1.0))));\n    vec3 dir = normalize(vec3(uv, -1.0));\n\n    vec4 lighting = computeRimReflectionLighting(dir, N);\n    fragColor = lighting;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/Sunrise/","title":"Sunrise","text":"Sunrise Shader by Saeed Shamseldin"},{"location":"shaders/lighting/Sunrise/#overview","title":"Overview","text":"<p>This GLSL shader implements physically-based atmospheric scattering to simulate realistic sunrise lighting effects. It models Rayleigh and Mie scattering phenomena to create the characteristic colors and glow of sunrise/sunset conditions.</p>"},{"location":"shaders/lighting/Sunrise/#key-features","title":"Key Features","text":"<ul> <li> <p>Physically-based atmospheric scattering simulation</p> </li> <li> <p>Configurable earth and atmosphere parameters</p> </li> <li> <p>Rayleigh scattering (blue sky effect)</p> </li> <li> <p>Mie scattering (sun glare and halo effects)</p> </li> <li> <p>Time-based sun direction animation</p> </li> </ul>"},{"location":"shaders/lighting/Sunrise/#constants","title":"Constants","text":"<ul> <li> <p>bR: Rayleigh scattering coefficients (per color channel)</p> </li> <li> <p>bMs: Mie scattering coefficients</p> </li> <li> <p>bMe: Extended Mie coefficients (1.1 \u00d7 bMs)</p> </li> </ul>"},{"location":"shaders/lighting/Sunrise/#sunriselight-struct","title":"<code>SunriseLight</code> Struct","text":"<pre><code>struct SunriseLight {\n    vec3 sundir;            // Normalized sun direction vector\n    vec3 earthCenter;       // Earth center position in meters\n    float earthRadius;      // Earth radius in meters (6360km)\n    float atmosphereRadius; // Atmosphere radius in meters (6380km)\n    float sunIntensity;     // Sun light intensity multiplier\n};\n</code></pre>"},{"location":"shaders/lighting/Sunrise/#core-functions","title":"Core Functions","text":"<p><code>initSunriseLight(out SunriseLight light, float time)</code></p> <p>Initializes sunrise lighting parameters with time-based animation.</p> <p>Parameters:</p> <ul> <li> <p><code>light</code>: Output SunriseLight structure</p> </li> <li> <p><code>time</code>: Animation time value</p> </li> </ul> <p><code>densitiesRM(vec3 p, SunriseLight light)</code></p> <p>Calculates Rayleigh and Mie density at a point in atmosphere.</p> <p>Returns:</p> <ul> <li><code>vec2</code>: x = Rayleigh density, y = Mie density</li> </ul> <p><code>escape(vec3 p, vec3 d, float R, vec3 earthCenter)</code></p> <p>Calculates distance to atmosphere boundary along a ray.</p> <p>Returns:</p> <ul> <li>Distance to boundary or -1 if no intersection</li> </ul> <p><code>scatterDepthInt(vec3 o, vec3 d, float L, float steps, SunriseLight light)</code></p> <p>Computes integrated scattering depths along a ray segment.</p> <p>Returns:</p> <ul> <li><code>vec2</code>: Integrated Rayleigh and Mie depths</li> </ul> <p><code>scatterIn(vec3 o, vec3 d, float L, float steps, SunriseLight light)</code></p> <p>Accumulates in-scattering contributions along a view ray.</p> <p><code>applySunriseLighting(vec3 o, vec3 d, float L, vec3 Lo, SunriseLight light)</code></p> <p>Main function to apply sunrise lighting to a scene.</p> <p>Parameters:</p> <ul> <li> <p><code>o</code>: Ray origin (camera position)</p> </li> <li> <p><code>d</code>: Ray direction (normalized)</p> </li> <li> <p><code>L</code>: Ray length</p> </li> <li> <p><code>Lo</code>: Original scene color</p> </li> <li> <p><code>light</code>: SunriseLight parameters</p> </li> </ul> <p>Returns:</p> <ul> <li>Final lit color with atmospheric effects</li> </ul>"},{"location":"shaders/lighting/Sunrise/#technical-details","title":"Technical Details","text":""},{"location":"shaders/lighting/Sunrise/#scattering-models","title":"Scattering Models","text":"<ul> <li> <p>Rayleigh scattering: Simulates shorter wavelength (blue) light scattering</p> </li> <li> <p>Mie scattering: Simulates longer wavelength (red/orange) light scattering and glare</p> </li> </ul>"},{"location":"shaders/lighting/Sunrise/#atmospheric-model","title":"Atmospheric Model","text":"<ul> <li> <p>Exponential density falloff with altitude</p> </li> <li> <p>8km scale height for Rayleigh scattering</p> </li> <li> <p>1.2km scale height for Mie scattering</p> </li> </ul> Show Code <pre><code>// Global variables for sunrise lighting\nvec2 totalDepthRM;\nvec3 I_R, I_M;\nconst vec3 bR = vec3(58e-7, 135e-7, 331e-7); // Rayleigh scattering coefficient\nconst vec3 bMs = vec3(2e-5); // Mie scattering coefficients\nconst vec3 bMe = bMs * 1.1;\n\nstruct SunriseLight {\n    vec3 sundir;\n    vec3 earthCenter;\n    float earthRadius;\n    float atmosphereRadius;\n    float sunIntensity;\n};\n\nvoid initSunriseLight(out SunriseLight light, float time) {\n    light.sundir = normalize(vec3(.5, .4 * (1. + sin(.5 * time)), -1.));\n    light.earthCenter = vec3(0., -6360e3, 0.);\n    light.earthRadius = 6360e3;\n    light.atmosphereRadius = 6380e3;\n    light.sunIntensity = 10.0;\n}\n\nvec2 densitiesRM(vec3 p, SunriseLight light) {\n    float h = max(0., length(p - light.earthCenter) - light.earthRadius);\n    return vec2(exp(-h/8e3), exp(-h/12e2));\n}\n\nfloat escape(vec3 p, vec3 d, float R, vec3 earthCenter) {\n    vec3 v = p - earthCenter;\n    float b = dot(v, d);\n    float det = b * b - dot(v, v) + R*R;\n    if (det &lt; 0.) return -1.;\n    det = sqrt(det);\n    float t1 = -b - det, t2 = -b + det;\n    return (t1 &gt;= 0.) ? t1 : t2;\n}\n\nvec2 scatterDepthInt(vec3 o, vec3 d, float L, float steps, SunriseLight light) {\n    vec2 depthRMs = vec2(0.);\n    L /= steps; d *= L;\n\n    for (float i = 0.; i &lt; steps; ++i)\n        depthRMs += densitiesRM(o + d * i, light);\n\n    return depthRMs * L;\n}\n\nvoid scatterIn(vec3 o, vec3 d, float L, float steps, SunriseLight light) {\n    L /= steps; d *= L;\n\n    for (float i = 0.; i &lt; steps; ++i) {\n        vec3 p = o + d * i;\n        vec2 dRM = densitiesRM(p, light) * L;\n        totalDepthRM += dRM;\n        vec2 depthRMsum = totalDepthRM + scatterDepthInt(p, light.sundir, escape(p, light.sundir, light.atmosphereRadius, light.earthCenter), 4., light);\n        vec3 A = exp(-bR * depthRMsum.x - bMe * depthRMsum.y);\n        I_R += A * dRM.x;\n        I_M += A * dRM.y;\n    }\n}\n\nvec3 applySunriseLighting(vec3 o, vec3 d, float L, vec3 Lo, SunriseLight light) {\n    totalDepthRM = vec2(0.);\n    I_R = I_M = vec3(0.);\n    scatterIn(o, d, L, 16., light);\n\n    float mu = dot(d, light.sundir);\n    return Lo + Lo * exp(-bR * totalDepthRM.x - bMe * totalDepthRM.y)\n        + light.sunIntensity * (1. + mu * mu) * (\n            I_R * bR * .0597 +\n            I_M * bMs * .0196 / pow(1.58 - 1.52 * mu, 1.5));\n}\n</code></pre>"},{"location":"shaders/lighting/lighting_context/","title":"\ud83e\udde9 Lighting Context Header","text":"<ul> <li>Category: Lighting</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Utility header (struct + helper)</li> <li>Input Requirements: N/A (header only)</li> </ul>"},{"location":"shaders/lighting/lighting_context/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/lighting/lighting_context/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p><code>LightingContext</code> is a small struct that stores everything a lighting\u2011routine usually needs: <code>position</code>, <code>normal</code>, <code>viewDir</code>, <code>lightDir</code>, <code>lightColor</code>, and <code>ambient</code>. The helper\u202f<code>createLightingContext()</code> fills these fields, so later code can pass one struct instead of six separate vectors.</p> <p>Usage: <code>#include \"lighting/surface_lighting/lighting_context.glsl\"</code></p>"},{"location":"shaders/lighting/lighting_context/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Type Description <code>position</code> vec3 World\u2011space fragment position <code>normal</code> vec3 Unit surface normal <code>viewDir</code> vec3 Unit direction from surface to camera <code>lightDir</code> vec3 Unit direction from surface to light <code>lightColor</code> vec3 RGB intensity / colour of the light <code>ambient</code> vec3 Ambient\u2011light contribution"},{"location":"shaders/lighting/lighting_context/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<pre><code>#ifndef LIGHTING_CONTEXT_GLSL\n#define LIGHTING_CONTEXT_GLSL\n\nstruct LightingContext {\n    vec3 position;    // World-space fragment position\n    vec3 normal;      // Normal at the surface point (normalized)\n    vec3 viewDir;     // Direction from surface to camera (normalized)\n    vec3 lightDir;    // Direction from surface to light (normalized)\n    vec3 lightColor;  // RGB intensity of the light source\n    vec3 ambient;     // Ambient light contribution\n};\n\nLightingContext createLightingContext(\n    vec3 position,\n    vec3 normal,\n    vec3 viewDir,\n    vec3 lightDir,\n    vec3 lightColor,\n    vec3 ambient\n) {\n    LightingContext ctx;\n    ctx.position = position;\n    ctx.normal = normal;\n    ctx.viewDir = viewDir;\n    ctx.lightDir = lightDir;\n    ctx.lightColor = lightColor;\n    ctx.ambient = ambient;\n    return ctx;\n}\n\n#endif\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/","title":"\ud83e\udde9 Lighting Function Collection","text":"<ul> <li>Category: Lighting</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Lighting function library</li> <li>Input Requirements: LightingContext, MaterialParams</li> </ul>"},{"location":"shaders/lighting/lighting_functions/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/lighting/lighting_functions/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This module defines multiple lighting models for shading surfaces based on their physical or stylized properties. Each model computes the final color by combining diffuse, specular, and ambient contributions using information in the LightingContext and MaterialParams.</p>"},{"location":"shaders/lighting/lighting_functions/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Default Role <code>ctx</code> Lighting context input LightingContext \u2014 \u2014 Input <code>mat</code> Material parameters MaterialParams \u2014 \u2014 Input <code>(return)</code> Final RGB color vec3 0.0\u20131.0 \u2014 Output"},{"location":"shaders/lighting/lighting_functions/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<pre><code>#include \"lighting/surface_lighting/lighting_context.glsl\"\n#include \"lighting/surface_lighting/material_params.glsl\"\n</code></pre>"},{"location":"shaders/lighting/lighting_functions/#1-phong","title":"1. Phong","text":"<p>The Phong lighting model computes specular highlights using the reflected light vector, resulting in sharper and more localized reflections. It offers a classic and intuitive approach to lighting, useful for surfaces where accurate highlight direction is important.</p> <p><pre><code> vec3 applyPhongLighting(LightingContext ctx, MaterialParams mat) {\n    float diff = max(dot(ctx.normal, ctx.lightDir), 0.0);\n    vec3 R = reflect(-ctx.lightDir, ctx.normal);\n    float spec = pow(max(dot(R, ctx.viewDir), 0.0), mat.shininess); \n    vec3 diffuse = diff * mat.baseColor * ctx.lightColor;\n    vec3 specular = spec * mat.specularColor * mat.specularStrength;\n    return ctx.ambient + diffuse + specular;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/#2-blinn-phong","title":"2. Blinn-phong","text":"<p>The Blinn-Phong lighting model calculates diffuse and specular highlights using the halfway vector between the light and view directions. It provides a smoother and more efficient alternative to the classic Phong model, making it suitable for real-time rendering with stylized or semi-realistic surfaces.</p> <p><pre><code>vec3 applyBlinnPhongLighting(LightingContext ctx, MaterialParams mat) {\n    float diff = max(dot(ctx.normal, ctx.lightDir), 0.0); \n    vec3 H = normalize(ctx.lightDir + ctx.viewDir); \n    float spec = pow(max(dot(ctx.normal, H), 0.0), mat.shininess); \n    vec3 diffuse = diff * mat.baseColor * ctx.lightColor;\n    vec3 specular = spec * mat.specularColor * mat.specularStrength;\n    return ctx.ambient + diffuse + specular;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/#engine-integrations","title":"Engine Integrations","text":"Unity"},{"location":"shaders/lighting/lighting_functions/#3-lambert","title":"3. Lambert","text":"<p>Implements a classic Lambertian diffuse model. It computes the intensity of reflected light based on the angle between surface normal and light direction, producing soft, angle-dependent shading.</p> <p><pre><code>vec3 lambertDiffuse(LightingContext ctx, MaterialParams mat) {\n    float diff = max(dot(ctx.normal, ctx.lightDir), 0.0);\n    return mat.baseColor * ctx.lightColor * diff;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/#engine-integrations_1","title":"Engine Integrations","text":"Unity"},{"location":"shaders/lighting/lighting_functions/#4-physically-based-rendering","title":"4. Physically Based Rendering","text":"<p>Simulates realistic lighting by blending diffuse and specular reflections based on surface roughness and metallic properties. Produces soft highlights on rough surfaces and sharp reflections on polished materials, enabling physically plausible rendering across diverse material types.</p> <p><pre><code>vec3 applyPBRLighting(LightingContext ctx, MaterialParams mat) {\n    vec3 N = normalize(ctx.normal);\n    vec3 V = normalize(ctx.viewDir);\n    vec3 L = normalize(ctx.lightDir);\n    vec3 H = normalize(L + V);\n    vec3 F0 = mix(vec3(0.04), mat.baseColor, mat.metallic);\n\n    float NDF = pow(mat.roughness + 1.0, 2.0);\n    float a = NDF * NDF;\n    float a2 = a * a;\n\n    float NdotH = max(dot(N, H), 0.0);\n    float D = a2 / (PI * pow((NdotH * NdotH) * (a2 - 1.0) + 1.0, 2.0));\n\n    float HdotV = max(dot(H, V), 0.0);\n    vec3 F = F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float k = pow(mat.roughness + 1.0, 2.0) / 8.0;\n    float G_V = NdotV / (NdotV * (1.0 - k) + k);\n    float G_L = NdotL / (NdotL * (1.0 - k) + k);\n    float G = G_V * G_L;\n\n    vec3 specular = (D * F * G) / (4.0 * NdotL * NdotV + 0.001);\n\n    vec3 kd = (1.0 - F) * (1.0 - mat.metallic);\n    vec3 diffuse = kd * mat.baseColor / PI;\n\n    vec3 lighting = (diffuse + specular) * ctx.lightColor * NdotL;\n    return lighting;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/#5-rim-lighting","title":"5. Rim Lighting","text":"<p>Adds a soft glow around the edges of objects by highlighting areas where the surface normal is nearly perpendicular to the view direction.</p> <p><pre><code>vec3 computeRimLighting(LightingContext ctx, MaterialParams mat, vec3 rimColor) {\n    float rim = pow(1.0 - max(dot(ctx.normal, ctx.viewDir), 0.0), mat.rimPower);\n    return rim * rimColor;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/lighting_functions/#engine-integrations_2","title":"Engine Integrations","text":"Unity"},{"location":"shaders/lighting/lighting_functions/#6-fake-specular","title":"6. Fake Specular","text":"<p>Simulates stylized highlights without relying on physical material properties. </p> <p><pre><code>vec3 computeFakeSpecular(LightingContext ctx, MaterialParams mat) {\n    vec3 H = normalize(ctx.lightDir + ctx.viewDir);\n    float highlight = pow(max(dot(ctx.normal, H), 0.0), mat.fakeSpecularPower);\n    return highlight * mat.fakeSpecularColor * ctx.lightColor;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/volume_lighting_context/","title":"\ud83e\udde9 Volume Lighting Context Header","text":"<ul> <li>Category: Lighting</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Utility header (struct + helper)</li> <li>Input Requirements: N/A (header only)</li> </ul>"},{"location":"shaders/lighting/volume_lighting_context/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/lighting/volume_lighting_context/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p><code>VolCtxLocal</code> is a small struct that stores everything a lighting\u2011routine usually needs: <code>position</code>,<code>viewDir</code>, <code>lightDir</code>, <code>lightColor</code>, and <code>ambient</code>, <code>stepSize</code>. The helper\u202f<code>createVolCtxLocal()</code> fills these fields, so later code can pass one struct instead of six separate vectors.</p> <p>Usage: <code>#include \"lighting/volume_lighting/vol_lit_context.glsl\"</code></p>"},{"location":"shaders/lighting/volume_lighting_context/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Type Description <code>position</code> vec3 World\u2011space fragment position <code>viewDir</code> vec3 Unit direction from surface to camera <code>lightDir</code> vec3 Unit direction from surface to light <code>lightColor</code> vec3 RGB intensity / colour of the light <code>ambient</code> vec3 Ambient\u2011light contribution <code>stepSize</code> float Raymarch step size at this sample ---"},{"location":"shaders/lighting/volume_lighting_context/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<pre><code>#ifndef VOL_LIT_CONTEXT_GLSL\n#define VOL_LIT_CONTEXT_GLSL\n\nstruct VolCtxLocal {\n    vec3 position;\n    vec3 viewDir;\n    vec3 lightDir;\n    vec3 lightColor;\n    vec3 ambient;\n    float stepSize;\n};\n\nVolCtxLocal createVolCtxLocal(\n    vec3 position,\n    vec3 viewDir,\n    vec3 lightDir,\n    vec3 lightColor,\n    vec3 ambient,\n    float stepSize\n) {\n    VolCtxLocal ctx;\n    ctx.position = position;\n    ctx.viewDir = viewDir;\n    ctx.lightDir = lightDir;\n    ctx.lightColor = lightColor;\n    ctx.ambient = ambient;\n    ctx.stepSize = stepSize;\n    return ctx;\n}\n\n#endif\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/lighting/volume_lighting_functions/","title":"\ud83e\udde9 Volume Lighting Functions for Clouds","text":"<ul> <li>Category: Lighting</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Lighting function library</li> <li>Input Requirements: <code>VolCtxLocal</code>, <code>VolMaterialParams</code>, <code>VolumeSample</code></li> </ul>"},{"location":"shaders/lighting/volume_lighting_functions/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This module contains volumetric lighting computation functions for rendering clouds and fog, supporting:</p> <ul> <li>Light scattering phase functions (<code>computePhaseIsotropic</code>, <code>computePhaseHG</code>, etc.)</li> <li>Local lighting models for clouds and fog (<code>applyVolLitCloud</code>, <code>applyVolLitFog</code>)</li> <li>Volumetric integration (<code>integrateCloud</code>, <code>integrateFog</code>)</li> <li>Occlusion estimation (<code>computeCloudOcclusion</code>, <code>computeFogOcclusion</code>)</li> </ul>"},{"location":"shaders/lighting/volume_lighting_functions/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Role <code>s</code> Volume sample (density, emission) VolumeSample Input <code>ctx</code> Lighting context input VolCtxLocal Input <code>mat</code> Volumetric material parameters VolMaterialParams Input"},{"location":"shaders/lighting/volume_lighting_functions/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":""},{"location":"shaders/lighting/volume_lighting_functions/#1light-scattering-phase-functions","title":"1.Light scattering phase functions","text":"<ul> <li><code>computePhaseIsotropic</code>: Models uniform scattering in all directions.</li> <li><code>computePhaseHG</code>: Models anisotropic scattering based on a single anisotropy parameter g[-1, 1].</li> <li><code>computePhaseSchlick</code>: Fast approximation of HG phase function.</li> <li><code>computePhaseRayleigh</code>: Models scattering of very small particles (e.g. air molecules) producing blue sky and atmospheric glow.</li> <li><code>computePhaseMie</code>: Simulates scattering by larger particles like smoke, dust, or mist using HG as an approximation.</li> </ul> <p>\ud83d\udd17 View Source on GitHub</p>"},{"location":"shaders/lighting/volume_lighting_functions/#2local-lighting-models","title":"2.Local lighting models","text":"<ul> <li><code>applyVolLitCloud</code>: Computes lighting for a sample in a cloud volume, supporting scattering, emission, ambient, and absorption.</li> </ul> \ud83d\udcc4 vol_lit.glsl <pre><code>vec4 applyVolLitCloud(\n    VolumeSample s,\n    VolumeLightingContextI ctx,\n    VolumeMaterialParams mat\n) {\n    // === Phase Function Selection ===\n    float cosTheta = dot(ctx.viewDir, ctx.lightDir);\n    float phase = computePhaseIsotropic();\n\n    // === Scattering ===\n    vec3 scatter = vec3(0.0);\n    if (mat.scatteringCoeff &gt; 0.0 &amp;&amp; s.density &gt; 0.0) {\n        scatter = mat.baseColor * ctx.lightColor * phase * mat.scatteringCoeff * s.density;\n    }\n\n    // === Emission ===\n    vec3 emission = vec3(0.0);\n    if (mat.emissionStrength &gt; 0.0 &amp;&amp; s.emission &gt; 0.0) {\n        emission = mat.emissionColor * mat.emissionStrength * s.emission;\n    }\n\n    return vec4((scatter + emission + ambient) * alpha, alpha);\n    // === Ambient ===\n    vec3 ambient = mat.baseColor * ctx.ambient * (0.2 + 0.8 * s.density);\n\n    // === Absorption / Alpha ===\n    float alpha = 1.0 - exp(-s.density * mat.absorptionCoeff * ctx.stepSize * 30.0);\n\n    return vec4((scatter + emission + ambient) * (1.8 - alpha), alpha);\n}\n</code></pre> <ul> <li><code>applyVolLitFog</code>: Computes lighting for fog using isotropic scattering, softer ambient contribution, and beam enhancements.</li> </ul> \ud83d\udcc4 vol_lit.glsl <pre><code>vec4 applyVolLitFog(\n    VolumeSample s,\n    VolCtxLocal ctx,\n    VolMaterialParams mat\n) {\n    // === Phase Function Selection ===\n    float cosTheta = dot(ctx.viewDir, ctx.lightDir);\n    float phase = computePhaseIsotropic(); \n\n    // === Scattering ===\n    vec3 scatter = vec3(0.0);\n    if (mat.scatteringCoeff &gt; 0.0 &amp;&amp; s.density &gt; 0.0) {\n        scatter = mat.baseColor * ctx.lightColor * phase * mat.scatteringCoeff * s.density;\n    }\n\n    // === Emission ===\n    vec3 emission = vec3(0.0);\n    if (mat.emissionStrength &gt; 0.0 &amp;&amp; s.emission &gt; 0.0) {\n        emission = mat.emissionColor * mat.emissionStrength * s.emission;\n    }\n\n    // === Ambient ===\n    vec3 ambient = mat.baseColor * ctx.ambient * (0.1 + 0.3 * s.density); // \u6bd4\u4e91\u66f4\u7a00\u8584\u3001\u67d4\u548c\n\n    // === Absorption / Alpha ===\n    float alpha = 1.0 - exp(-s.density * mat.absorptionCoeff * ctx.stepSize * 10.0);\n\n    // === Beam Enhancement ===\n    vec3 beam = vec3(0.0);\n    if (mat.beamBoost &gt; 0.0) {\n        beam = applyVolLitBeam(s.density, ctx, mat.anisotropy, mat.beamBoost);\n    }\n\n    // === Final Color Composition ===\n    vec3 color = scatter + emission + ambient + beam;\n\n    return vec4(color * (1.2 - alpha), alpha);\n}\n</code></pre> <p>\ud83d\udd17 View Source on GitHub</p>"},{"location":"shaders/lighting/volume_lighting_functions/#3volumetric-integration","title":"3.Volumetric integration","text":"<ul> <li><code>integrateCloud</code>: Performs step-based integration along a ray inside a bounded cloud layer using <code>applyVolLitCloud</code>.</li> </ul> \ud83d\udcc4 vol_integration.glsl <pre><code>vec4 integrateCloud(\n    vec3 rayOrigin, vec3 rayDir, float rayLength,\n    float stepCount, vec3 lightDir, vec3 lightColor, \n    vec3 ambient, VolMaterialParams mat\n) {\n    const float yb = CLOUD_BASE;\n    const float yt = CLOUD_TOP;\n    float tb = (yb - rayOrigin.y) / rayDir.y;\n    float tt = (yt - rayOrigin.y) / rayDir.y;\n\n    float tmin, tmax;\n    if (rayOrigin.y &gt; yt) {\n        if (tt &lt; 0.0) return vec4(0.0);\n        tmin = tt; tmax = tb;\n    }\n    else if (rayOrigin.y &lt; yb) {\n        if (tb &lt; 0.0) return vec4(0.0);\n        tmin = tb; tmax = tt;\n    }\n    else {\n        tmin = 0.0;\n        tmax = rayLength;\n        if (tt &gt; 0.0) tmax = min(tmax, tt);\n        if (tb &gt; 0.0) tmax = min(tmax, tb);\n    }\n\n    vec4 accum = vec4(0.0);\n\n    vec2 uv = gl_FragCoord.xy / Resolution;\n    float jitter = texture(NoiseTex, uv).x;\n    float t = tmin + 0.1 * jitter;\n\n    for (int i = 0; i &lt; int(stepCount); ++i) {\n        float dt = max(0.05, 0.02 * t);\n        vec3 p = rayOrigin + t * rayDir;\n\n        float density = map(p, 5);\n        if (density &gt; 0.01) {\n            VolumeSample s;\n            s.density = density * mat.densityScale;\n            s.emission = 0.0;\n\n            VolCtxLocal ctx = createVolCtxLocal(\n                p, -rayDir, lightDir, lightColor, ambient, dt\n            );\n\n            vec4 local = applyVolLitCloud(s, ctx, mat);       \n\n            accum.rgb += (1.0 - accum.a) * local.a * local.rgb;\n            accum.a += (1.0 - accum.a) * local.a;\n        }\n\n        t += dt;\n        if (t &gt; tmax || accum.a &gt; 0.99) break;\n    }\n\n    return clamp(accum, 0.0, 1.0);\n}\n</code></pre> <ul> <li><code>integrateFog</code>: Integrates fog volume using constant step raymarching, suitable for ground-level haze.</li> </ul> \ud83d\udcc4 vol_integration.glsl <pre><code>vec4 integrateFog(\n    vec3 rayOrigin, vec3 rayDir, float rayLength,\n    float stepCount, vec3 lightDir, vec3 lightColor, \n    vec3 ambient, VolMaterialParams mat\n) {\n    vec4 accum = vec4(0.0);\n\n    float jitter = fract(sin(dot(rayOrigin.xz, vec2(12.9898, 78.233))) * 43758.5453 + iTime);\n    float t = 0.1 + 0.2 * jitter;\n\n    for (int i = 0; i &lt; int(stepCount); ++i) {\n        float dt = 0.2;\n        vec3 p = rayOrigin + t * rayDir;\n\n        float density = FogDensity(p, rayOrigin);\n        if (density &gt; 0.001) {\n            VolumeSample s;\n            s.density = density * mat.densityScale;\n            s.emission = 0.0;\n\n            VolCtxLocal ctx = createVolCtxLocal(\n                p, -rayDir, lightDir, lightColor, ambient, dt\n            );\n\n            vec4 local = applyVolLitFog(s, ctx, mat);\n\n            accum.rgb += (1.0 - accum.a) * local.a * local.rgb;\n            accum.a += (1.0 - accum.a) * local.a;\n        }\n\n        t += dt;\n        if (t &gt; rayLength || accum.a &gt; 0.99) break;\n    }\n\n    return clamp(accum, 0.0, 1.0);\n}\n</code></pre> <p>\ud83d\udd17 View Source on GitHub</p>"},{"location":"shaders/lighting/volume_lighting_functions/#4occlusion-estimation","title":"4.Occlusion estimation","text":"<ul> <li><code>computeCloudOcclusion</code>: Estimates how much light is blocked by a cloud between a point and a light source.</li> </ul> \ud83d\udcc4 vol_occlusion.glsl <pre><code>float computeCloudOcclusion(vec3 startPos, vec3 lightDir) {\n    const float maxDistance = 10.0;  \n    const float stepSize = 0.3;  \n    const float extinctionScale = 2.0;\n\n    float t = 0.1;                 \n    float accumulatedDensity = 0.0;\n\n    for (int i = 0; i &lt; 32; ++i) {\n        vec3 samplePos = startPos + t * lightDir;\n        float density = map(samplePos, 5); \n        accumulatedDensity += density * stepSize;\n\n        t += stepSize;\n        if (t &gt; maxDistance) break;\n    }\n\n    float occlusion = 1.0 - exp(-accumulatedDensity * extinctionScale);\n    return clamp(occlusion, 0.0, 1.0);\n}\n</code></pre> <ul> <li><code>computeFogOcclusion</code>: Estimates how much light is blocked by fog between a point and a light source.</li> </ul> \ud83d\udcc4 vol_occlusion.glsl <pre><code>float computeFogOcclusion(vec3 startPos, vec3 lightDir, vec3 rayOrigin) {\n    const float maxDistance = 8.0; \n    const float stepSize = 0.25;\n    const float extinctionScale = 1.2;\n\n    float t = 0.1;\n    float accumulatedDensity = 0.0;\n\n    for (int i = 0; i &lt; 32; ++i) {\n        vec3 samplePos = startPos + t * lightDir;\n        float fogDensity = FogDensity(samplePos, rayOrigin);\n        accumulatedDensity += fogDensity * stepSize;\n\n        t += stepSize;\n        if (t &gt; maxDistance) break;\n    }\n\n    float occlusion = 1.0 - exp(-accumulatedDensity * extinctionScale);\n    return clamp(occlusion, 0.0, 1.0);\n}\n</code></pre> <p>\ud83d\udd17 View Source on GitHub</p>"},{"location":"shaders/material/material_system/","title":"\ud83e\udde9 Material System Documentation","text":"<ul> <li>Category: Material</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Utility header</li> <li>Input Requirements: Material ID; uv; material property parameters (see the table below for details)</li> </ul>"},{"location":"shaders/material/material_system/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/material/material_system/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This system organizes material appearance using a three-part module:</p>"},{"location":"shaders/material/material_system/#1-materialparams-struct","title":"1. <code>MaterialParams</code> Struct","text":"<p>Defines a data structure storing surface reflectance info (diffuse, specular, roughness, etc.)</p>"},{"location":"shaders/material/material_system/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Member Type Description <code>baseColor</code> vec3 Base surface color (albedo/diffuse) <code>specularColor</code> vec3 Color of specular highlights <code>specularStrength</code> float Strength of specular reflections <code>shininess</code> float Phong/Blinn exponent <code>roughness</code> float Microfacet roughness (PBR) <code>metallic</code> float Degree of metallic reflection <code>rimPower</code> float Rim light exponent (stylized look) <code>fakeSpecularPower</code> float Controls sharpness of stylized highlights <code>fakeSpecularColor</code> vec3 Color of stylized highlights <code>ior</code> float Index of refraction (for transparent materials) <code>refractionStrength</code> float Blending factor for refracted background <code>refractionTint</code> vec3 Tint color applied to refracted background"},{"location":"shaders/material/material_system/#code","title":"\ud83d\udcbb Code","text":"<p><pre><code>#ifndef MATERIAL_PARAMS_GLSL\n#define MATERIAL_PARAMS_GLSL\n\nstruct MaterialParams {\n    vec3 baseColor; \n    vec3 specularColor;\n    float specularStrength;\n    float shininess;\n\n    float roughness;\n    float metallic;\n    float rimPower;\n    float fakeSpecularPower;\n    vec3 fakeSpecularColor;\n\n    float ior;\n    float refractionStrength;\n    vec3 refractionTint;\n};\n\n#endif\n</code></pre> Usage: <code>#include \"materials/material/material_params.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/material/material_system/#2-material-presets","title":"2. Material Presets","text":"<p>Defines helper functions to generate common materials like glass, plastic, metal, toon, etc.</p>"},{"location":"shaders/material/material_system/#functions","title":"\ud83d\udd27 Functions","text":"Function Description <code>createDefaultMaterialParams()</code> Returns a neutral white plastic <code>makePlastic(color)</code> Basic plastic with given color <code>makeGlass(tint, ior)</code> Transparent material with tint <code>makeMetalBrushed(base, uv, scale)</code> Brushed metal with noise-based details <code>makeToon(color, edgeSharpness)</code> Flat toon surface with rim light <code>makeWater(color)</code> Shiny semi-transparent water preset <p>\ud83d\udccc Notes: - Metal brushed requires external noise function <code>n31(vec3)</code> - All functions return a <code>MaterialParams</code> struct - These presets are meant to showcase possible material types, but they may not reflect the actual materials used in later shaders.</p>"},{"location":"shaders/material/material_system/#code_1","title":"\ud83d\udcbb Code","text":"\ud83d\udcc4 material_presets.glsl <pre><code>#ifndef MATERIAL_PRESETS_GLSL\n#define MATERIAL_PRESETS_GLSL\n\n// ------------------------------------------\n// Default Material (neutral white plastic)\n// ------------------------------------------\nMaterialParams createDefaultMaterialParams() {\n    MaterialParams mat;\n    mat.baseColor = vec3(1.0);\n    mat.specularColor = vec3(1.0);\n    mat.specularStrength = 1.0;\n    mat.shininess = 32.0;\n\n    mat.roughness = 0.5;\n    mat.metallic = 0.0;\n    mat.rimPower = 2.0;\n    mat.fakeSpecularPower = 32.0;\n    mat.fakeSpecularColor = vec3(1.0);\n\n    mat.ior = 1.45;                    // Typical plastic/glass\n    mat.refractionStrength = 0.0;     // No refraction by default\n    mat.refractionTint = vec3(1.0);\n    return mat;\n}\n\n// ------------------------------------------\n// Plastic material preset\n// ------------------------------------------\nMaterialParams makePlastic(vec3 color) {\n    MaterialParams mat = createDefaultMaterialParams();\n    mat.baseColor = color;\n    mat.metallic = 0.0;\n    mat.roughness = 0.4;\n    mat.specularStrength = 0.5;\n    return mat;\n}\n\n// ------------------------------------------\n// Glass material preset\n// ------------------------------------------\nMaterialParams makeGlass(vec3 tint, float ior) {\n    MaterialParams mat = createDefaultMaterialParams();\n    mat.baseColor = tint;\n    mat.metallic = 0.0;\n    mat.roughness = 0.1;\n    mat.ior = ior;\n    mat.refractionStrength = 0.9;\n    mat.refractionTint = tint;\n    mat.specularStrength = 1.0;\n    return mat;\n}\n\n// ------------------------------------------\n// Brushed metal with procedural noise\n// ------------------------------------------\nMaterialParams makeMetalBrushed(vec3 base, vec3 uv, float scale) {\n    MaterialParams mat = createDefaultMaterialParams();\n    mat.baseColor = base - n31(uv * scale) * 0.1; // Requires external noise n31()\n    mat.metallic = 1.0;\n    mat.roughness = 0.2;\n    mat.specularStrength = 0.5;\n    return mat;\n}\n\n// ------------------------------------------\n// Toon material preset (flat surface with strong rim)\n// ------------------------------------------\nMaterialParams makeToon(vec3 color, float edgeSharpness) {\n    MaterialParams mat = createDefaultMaterialParams();\n    mat.baseColor = color;\n    mat.metallic = 0.0;\n    mat.roughness = 1.0;\n    mat.rimPower = edgeSharpness;\n    mat.fakeSpecularColor = vec3(1.0);\n    mat.fakeSpecularPower = 128.0;\n    return mat;\n}\n\n// ------------------------------------------\n// Water material preset\n// ------------------------------------------\nMaterialParams makeWater(vec3 color) {\n    MaterialParams mat = createDefaultMaterialParams();\n    mat.baseColor = color;\n    mat.fakeSpecularColor = vec3(1.0);\n    mat.fakeSpecularPower = 64.0;\n    mat.specularColor = vec3(1.5);\n    mat.specularStrength = 1.5; \n    mat.shininess = 64.0; \n    mat.ior = 1.333;\n    mat.refractionStrength = 0.0;\n    return mat;\n}\n\n#endif\n</code></pre> <p>Usage: <code>#include \"materials/material/material_presets.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/material/material_system/#3-material-library","title":"3. Material Library","text":"<p>This module maps int IDs to material presets, useful for assigning materials to objects using hit-ID or tag logic in SDF raymarching.</p>"},{"location":"shaders/material/material_system/#common-ids","title":"\ud83c\udff7\ufe0f Common IDs","text":"ID ID Macro Meaning 1 <code>MAT_PLASTIC_WHITE</code> Default neutral material 2 <code>MAT_PLASTIC_COLOR</code> Color plastic material ... ... ... 5 <code>MAT_GLASS_CLEAR</code> Colorless transparent glass ... ... ... <p>\ud83d\udccc Notes: - Material IDs from 1 to 100 are reserved for common preset materials (e.g. plastic, glass, metal). - Scene-specific materials should use IDs starting from 101 to avoid conflicts. - The current list is illustrative only; actual materials may be added, removed, or remapped as the library evolves.</p>"},{"location":"shaders/material/material_system/#code_2","title":"\ud83d\udcbb Code","text":"\ud83d\udcc4 material_library.glsl <pre><code>#ifndef MATERIAL_LIBRARY_GLSL\n#define MATERIAL_LIBRARY_GLSL\n\n// ------------------------------------------\n// Common Physically-Based Material Templates\n// ------------------------------------------\n#define MAT_PLASTIC_WHITE      1\n#define MAT_PLASTIC_COLOR      2\n#define MAT_METAL_BRUSHED      3\n#define MAT_METAL_POLISHED     4\n#define MAT_GLASS_CLEAR        5\n#define MAT_GLASS_TINTED       6\n#define MAT_RUBBER_BLACK       7\n#define MAT_CERAMIC_WHITE      8\n#define MAT_EMISSIVE_WHITE     9\n\n// ------------------------------------------\n// Scene-Specific Materials (Start from 100)\n// ------------------------------------------\n#define MAT_METAL_WING         100\n#define MAT_SOLAR_PANEL        101\n#define MAT_COCKPIT_GLASS      102\n#define MAT_WINDOW_FRAME       103\n#define MAT_COCKPIT_BODY       104\n#define MAT_GUN_BARREL         105\n#define MAT_LASER_EMISSIVE     106\n\n// Material preset registry\nMaterialParams getMaterialByID(int id, vec3 uv) {\n    MaterialParams mat = createDefaultMaterialParams();\n\n    // ---------- Common Material Templates ----------\n    if (id == MAT_PLASTIC_WHITE) {\n        mat = makePlastic(vec3(1.0));\n    }\n    else if (id == MAT_PLASTIC_COLOR) {\n        mat = makePlastic(vec3(0.4, 0.6, 1.0));\n    }\n    else if (id == MAT_METAL_BRUSHED) {\n        mat = makeMetalBrushed(vec3(0.6), uv, 12.0);\n    }\n    else if (id == MAT_METAL_POLISHED) {\n        mat = makeMetalBrushed(vec3(0.9), uv, 0.0);\n        mat.roughness = 0.05;\n        mat.specularStrength = 1.0;\n    }\n    else if (id == MAT_GLASS_CLEAR) {\n        mat = makeGlass(vec3(1.0), 1.5);\n    }\n    else if (id == MAT_GLASS_TINTED) {\n        mat = makeGlass(vec3(0.6, 0.8, 1.0), 1.45);\n    }\n    else if (id == MAT_RUBBER_BLACK) {\n        mat = makePlastic(vec3(0.05));\n        mat.roughness = 0.9;\n        mat.specularStrength = 0.2;\n    }\n    else if (id == MAT_CERAMIC_WHITE) {\n        mat = makePlastic(vec3(0.95));\n        mat.roughness = 0.2;\n        mat.specularStrength = 0.8;\n    }\n    else if (id == MAT_EMISSIVE_WHITE) {\n        mat.baseColor = vec3(1.0);\n        mat.fakeSpecularColor = vec3(1.0);\n        mat.fakeSpecularPower = 1.0;\n        mat.rimPower = 0.0;\n        mat.specularStrength = 0.0;\n    }\n\n    // ---------- Scene-Specific Materials ----------\n    else if (id == MAT_METAL_WING) {\n        mat = makeMetalBrushed(vec3(0.30), uv, 18.7);\n        mat.specularStrength = 0.5;\n    }\n    else if (id == MAT_COCKPIT_BODY) {\n        mat = makeMetalBrushed(vec3(0.30), uv, 18.7);\n        mat.specularStrength = 0.5;\n        float cutout = step(abs(atan(uv.y, uv.z) - 0.8), 0.01);\n        mat.baseColor *= 1.0 - 0.8 * cutout;\n    }\n    else if (id == MAT_SOLAR_PANEL) {\n        vec3 modifiedUV = uv;\n        if (uv.x &lt; uv.y * 0.7) modifiedUV.y = 0.0;\n        float intensity = 0.005 + 0.045 * pow(abs(sin((modifiedUV.x - modifiedUV.y) * 12.0)), 20.0);\n        mat.baseColor = vec3(intensity);\n        mat.specularStrength = 0.2;\n        mat.metallic = 0.0;\n    }\n    else if (id == MAT_GUN_BARREL) {\n        mat.baseColor = vec3(0.02);\n        mat.metallic = 1.0;\n        mat.specularStrength = 0.2;\n    }\n    else if (id == MAT_COCKPIT_GLASS) {\n        mat = makeGlass(vec3(0.6, 0.7, 1.0), 1.45);\n    }\n    else if (id == MAT_WINDOW_FRAME) {\n        mat.baseColor = vec3(0.10);\n        mat.metallic = 1.0;\n    }\n    else if (id == MAT_LASER_EMISSIVE) {\n        mat.baseColor = vec3(0.30, 1.00, 0.30);\n        mat.specularStrength = 0.0;\n        mat.fakeSpecularColor = vec3(0.3, 1.0, 0.3);\n        mat.fakeSpecularPower = 1.0;\n        mat.rimPower = 0.5;\n    }\n\n    return mat;\n}\n\n#endif\n</code></pre> <p>Usage: <code>#include \"materials/material//material_library.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/material/volume_material_system/","title":"\ud83e\udde9 Volume Material System Documentation","text":"<ul> <li>Category: Material</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Utility header</li> <li>Input Requirements: Volume material ID; material property parameters (see the table below for details)</li> </ul>"},{"location":"shaders/material/volume_material_system/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/material/volume_material_system/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This system organizes material appearance using a three-part module:</p>"},{"location":"shaders/material/volume_material_system/#1-volmaterialparams-struct","title":"1. <code>VolMaterialParams</code> Struct","text":"<p>Defines a data structure storing surface reflectance info (diffuse, specular, roughness, etc.)</p>"},{"location":"shaders/material/volume_material_system/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Member Type Description <code>baseColor</code> vec3 Intrinsic color of the medium <code>densityScale</code> float Density multiplier controlling opacity and absorption strength <code>emissionStrength</code> float Strength of light emitted by the medium itself <code>emissionColor</code> vec3 Emission color (if different from baseColor) <code>scatteringCoeff</code> float Scattering strength (higher = more light bounces) <code>absorptionCoeff</code> float Absorption strength (higher = faster light decay) <code>anisotropy</code> float Phase function anisotropy [-1, 1], 0 = isotropic, &gt;0 = forward scattering <code>temperature</code> float Optional scalar used for color remapping or animation (e.g., flame ramp) <code>noiseStrength</code> float Optional density modulation by procedural noise"},{"location":"shaders/material/volume_material_system/#code","title":"\ud83d\udcbb Code","text":"<p><pre><code>#ifndef VOL_MAT_PARAMS_GLSL\n#define VOL_MAT_PARAMS_GLSL\n\nstruct VolMaterialParams {\n    vec3 baseColor;\n    float densityScale;\n    float emissionStrength;\n    vec3 emissionColor;\n    float scatteringCoeff;\n    float absorptionCoeff; \n    float anisotropy;\n    float temperature;\n    float noiseStrength; \n};\n#endif\n</code></pre> Usage: <code>#include \"materials/volume_material/vol_mat_params.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/material/volume_material_system/#2-volume-material-presets","title":"2. Volume Material Presets","text":"<p>Defines helper functions to generate common volume materials like fog, clouds, etc.</p>"},{"location":"shaders/material/volume_material_system/#functions","title":"\ud83d\udd27 Functions","text":"Function Description <code>makeDefaultVolumeMaterial()</code> Neutral white volume (fog-like baseline) <code>makeCloud(baseColor)</code> Light-scattering cloud material <code>makeFog(baseColor)</code> Thin volume with weak scattering <code>makeFlame(emissionColor)</code> Emissive flame-like preset <code>makeSmoke(baseColor)</code> Absorptive, dark smoke material <code>makeMagicMaterial(baseColor)</code> Stylized emissive colored effect <p>\ud83d\udccc Notes: - All functions return a <code>VolMaterialParams</code> struct - These presets are meant to showcase possible material types, but they may not reflect the actual materials used in later shaders.</p>"},{"location":"shaders/material/volume_material_system/#code_1","title":"\ud83d\udcbb Code","text":"\ud83d\udcc4 vol_mat_presets.glsl <pre><code>#ifndef VOL_MAT_PRESETS_GLSL\n#define VOL_MAT_PRESETS_GLSL\n\n// ------------------------------------------\n// Default Volume Material (neutral white fog)\n// ------------------------------------------\nVolMaterialParams makeDefaultVolumeMaterial() {\n    VolMaterialParams mat;\n    mat.baseColor = vec3(1.0);\n    mat.densityScale = 1.0;\n\n    mat.emissionStrength = 0.0;\n    mat.emissionColor = vec3(0.0);\n\n    mat.scatteringCoeff = 0.5;\n    mat.absorptionCoeff = 0.1;\n    mat.anisotropy = 0.0;\n\n    mat.temperature = 0.0;\n    mat.noiseStrength = 0.0;\n    return mat;\n}\n\n// ------------------------------------------\n// Cloud material preset (white fluffy clouds)\n// ------------------------------------------\nVolMaterialParams makeCloud(vec3 baseColor) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n    mat.baseColor = baseColor;\n    mat.densityScale = 1.0;\n\n    mat.scatteringCoeff = 1.0;\n    mat.absorptionCoeff = 0.2;\n    mat.anisotropy = 0.6;\n\n    mat.noiseStrength = 0.3;\n    return mat;\n}\n\n// ------------------------------------------\n// Fog material preset (neutral or tinted fog)\n// ------------------------------------------\nVolMaterialParams makeFog(vec3 baseColor) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n    mat.baseColor = baseColor;\n    mat.densityScale = 0.5;\n\n    mat.scatteringCoeff = 0.4;\n    mat.absorptionCoeff = 0.05;\n    mat.anisotropy = 0.0;\n\n    mat.noiseStrength = 0.1;\n    return mat;\n}\n\n// ------------------------------------------\n// Flame material preset (emissive fire volume)\n// ------------------------------------------\nVolMaterialParams makeFlame(vec3 emissionColor) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n    mat.baseColor = emissionColor;\n    mat.emissionColor = emissionColor;\n    mat.emissionStrength = 6.0;\n\n    mat.densityScale = 0.6;\n    mat.scatteringCoeff = 0.2;\n    mat.absorptionCoeff = 0.1;\n\n    mat.temperature = 1000.0;\n    mat.noiseStrength = 0.3;\n    return mat;\n}\n\n// ------------------------------------------\n// Smoke material preset (dark absorbing medium)\n// ------------------------------------------\nVolMaterialParams makeSmoke(vec3 baseColor) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n    mat.baseColor = baseColor;\n    mat.densityScale = 0.8;\n\n    mat.scatteringCoeff = 0.3;\n    mat.absorptionCoeff = 0.4;\n    mat.anisotropy = 0.0;\n\n    mat.noiseStrength = 0.2;\n    return mat;\n}\n\n// ------------------------------------------\n// Magic effect preset (emissive stylized medium)\n// ------------------------------------------\nVolMaterialParams makeMagicMaterial(vec3 baseColor) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n    mat.baseColor = baseColor;\n    mat.emissionColor = baseColor;\n    mat.emissionStrength = 3.0;\n\n    mat.densityScale = 1.0;\n    mat.scatteringCoeff = 0.6;\n    mat.absorptionCoeff = 0.1;\n\n    mat.noiseStrength = 0.4;\n    return mat;\n}\n\n#endif\n</code></pre> <p>Usage: <code>#include \"materials/volume_material/vol_mat_presets.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/material/volume_material_system/#3-material-library","title":"3. Material Library","text":"<p>This module maps int IDs to material presets, useful for assigning materials to objects using hit-ID or tag logic in SDF raymarching.</p>"},{"location":"shaders/material/volume_material_system/#common-ids","title":"\ud83c\udff7\ufe0f Common IDs","text":"ID ID Macro Meaning 1 <code>VOL_CLOUD_WHITE</code> Default white cloud ... ... ... 3 <code>VOL_FOG_GRAY</code> Neutral low-density fog ... ... ... <p>\ud83d\udccc Notes: - Volume material IDs from 1 to 99 are reserved for common preset materials. - Scene-specific materials should use IDs starting from 100 to avoid conflicts. - The current list is illustrative only; actual materials may be added, removed, or remapped as the library evolves.</p>"},{"location":"shaders/material/volume_material_system/#code_2","title":"\ud83d\udcbb Code","text":"\ud83d\udcc4 vol_mat_library.glsl <pre><code>#ifndef VOLUME_MATERIAL_LIBRARY_GLSL\n#define VOLUME_MATERIAL_LIBRARY_GLSL\n\n// ------------------------------------------\n// Common Volumetric Material Types\n// ------------------------------------------\n#define VOL_CLOUD_WHITE       1\n#define VOL_CLOUD_STORMY      2\n#define VOL_FOG_GRAY          3\n#define VOL_FIRE_ORANGE       4\n#define VOL_SMOKE_BLACK       5\n#define VOL_MAGIC_PURPLE      6\n\n// ------------------------------------------\n// Scene-Specific Volume Materials (start at 100)\n// ------------------------------------------\n#define VOL_PLASMA_STREAM     100\n#define VOL_NEBULA_GALAXY     101\n#define VOL_HAZE_GREEN        102\n\n// Get volume material from ID\nVolMaterialParams getVolMaterialByID(int id) {\n    VolMaterialParams mat = makeDefaultVolumeMaterial();\n\n    // ---------- Common Volume Types ----------\n    if (id == VOL_CLOUD_WHITE) {\n        mat = makeCloud(vec3(1.0));\n    }\n    else if (id == VOL_CLOUD_STORMY) {\n        mat = makeCloud(vec3(0.8, 0.85, 0.9));\n        mat.anisotropy = 0.7;\n        mat.absorptionCoeff = 0.3;\n    }\n    else if (id == VOL_FOG_GRAY) {\n        mat = makeFog(vec3(0.6));\n    }\n    else if (id == VOL_FIRE_ORANGE) {\n        mat = makeFlame(vec3(1.0, 0.4, 0.1));\n    }\n    else if (id == VOL_SMOKE_BLACK) {\n        mat = makeSmoke(vec3(0.1));\n    }\n    else if (id == VOL_MAGIC_PURPLE) {\n        mat = makeMagicMaterial(vec3(0.6, 0.2, 0.8));\n    }\n\n    // ---------- Scene-Specific Materials ----------\n    else if (id == VOL_PLASMA_STREAM) {\n        mat.baseColor = vec3(0.5, 1.0, 1.0);\n        mat.emissionStrength = 8.0;\n        mat.anisotropy = 0.0;\n        mat.densityScale = 0.3;\n    }\n    else if (id == VOL_NEBULA_GALAXY) {\n        mat.baseColor = vec3(0.9, 0.3, 1.0);\n        mat.emissionStrength = 2.0;\n        mat.scatteringCoeff = 0.4;\n        mat.absorptionCoeff = 0.1;\n        mat.noiseStrength = 0.5;\n    }\n    else if (id == VOL_HAZE_GREEN) {\n        mat = makeFog(vec3(0.2, 0.6, 0.3));\n        mat.densityScale = 0.7;\n    }\n\n    return mat;\n}\n\n#endif\n</code></pre> <p>Usage: <code>#include \"materials/volume_material/vol_mat_library.glsl\"</code></p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/1d_noise/","title":"\ud83e\udde9 1D Noise Shader (with 1D FBM)","text":"<ul> <li>Category: Noise  </li> <li>Author: Morgan McGuire (morgan3d)  </li> <li>License: BSD License \u2014 reuse permitted  </li> <li>Shader Type: 1D Value Noise + Fractal FBM  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iResolution</code></li> </ul>"},{"location":"shaders/noise/1d_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/1d_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader implements 1D interpolated value noise and FBM (Fractal Brownian Motion) using a classic hash-based method from Morgan McGuire. It is optimized to reduce periodicity and works well for both positive and negative domains.</p> <p>It includes:</p> <ul> <li><code>hash(float)</code> \u2014 precision-adjusted float hash function  </li> <li><code>noise(float)</code> \u2014 classic 1D value noise  </li> <li><code>fbm(float)</code> \u2014 layered 1D noise over multiple octaves  </li> <li><code>mainImage()</code> \u2014 renders a horizontal waveform based on <code>fbm(x)</code>, animated over time</li> </ul>"},{"location":"shaders/noise/1d_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>NUM_NOISE_OCTAVES</code> Number of FBM octaves <code>#define</code> <code>5</code> <code>iTime</code> Time input for animation <code>float</code> uniform <code>iResolution</code> Screen resolution <code>vec2</code> uniform"},{"location":"shaders/noise/1d_noise/#full-shader-code","title":"\ud83d\udcbb Full Shader Code","text":"<p>```glsl // 1D noise // By Morgan McGuire @morgan3d, http://graphicscodex.com // Reuse permitted under the BSD license.</p> <p>// All noise functions are designed for values on integer scale. // They are tuned to avoid visible periodicity for both positive and // negative coordinates within a few orders of magnitude.</p>"},{"location":"shaders/noise/1d_noise/#define-noise-fbm","title":"define NOISE fbm","text":""},{"location":"shaders/noise/1d_noise/#define-num_noise_octaves-5","title":"define NUM_NOISE_OCTAVES 5","text":"<p>float hash(float p) {     p = fract(p * 0.011);     p = p + 7.5;     p = p + p;     return fract(p); }</p> <p>float noise(float x) {     float i = floor(x);     float f = fract(x);     float u = f * f * (3.0 - 2.0 * f);     return mix(hash(i), hash(i + 1.0), u); }</p> <p>float fbm(float x) {     float v = 0.0;     float a = 0.5;     float shift = float(100);     for (int i = 0; i &lt; NUM_NOISE_OCTAVES; ++i) {         v += a * noise(x);         x = x * 2.0 + shift;         a *= 0.5;     }     return v; }</p> <p>void mainImage(out vec4 fragColor, in vec2 fragCoord) {     float v = 0.0;     float coord = fragCoord.x * 0.05 + iTime * 5.0 - 10.0;     float height = NOISE(coord) * iResolution.y / 2.0;     v = clamp((height - fragCoord.y + iResolution.y / 2.0) / (iResolution.y * 0.02), 0.0, 1.0);     fragColor.rgb = pow(v, 0.35) * 1.3 * normalize(vec3(0.5, fragCoord.xy / iResolution.xy)) + vec3(v * 0.25); }</p>"},{"location":"shaders/noise/2d_noise/","title":"\ud83e\udde9 2D Noise Shader with FBM","text":"<ul> <li>Category: Noise  </li> <li>Shader Type: 2D Value Noise + Fractal Brownian Motion  </li> <li>Author: Based on Morgan McGuire's noise core (BSD license)  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iResolution</code></li> </ul>"},{"location":"shaders/noise/2d_noise/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>FBM with rotation helps eliminate visible tiling and axis-aligned artifacts.  </li> <li><code>NOISE</code> macro allows easy switching between single-octave and multi-octave variants.  </li> <li>Useful for cloud textures, stylized terrain, fire, or organic materials.</li> </ul>"},{"location":"shaders/noise/2d_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/2d_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader visualizes smooth procedural textures using hash-based value noise and FBM (Fractal Brownian Motion).  </p> <p>Key features:</p> <ul> <li><code>hash(float)</code> / <code>hash(vec2)</code> \u2014 pseudo-random value generation  </li> <li><code>noise(float)</code> / <code>noise(vec2)</code> \u2014 smooth interpolated value noise  </li> <li><code>fbm(float)</code> / <code>fbm(vec2)</code> \u2014 multi-octave fractal accumulation  </li> <li>Time-based offsetting + rotation to animate and decorrelate patterns</li> </ul> <p>The result is a vibrant, evolving noise field rendered in color.</p>"},{"location":"shaders/noise/2d_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>iTime</code> Time for animation <code>float</code> uniform <code>iResolution</code> Screen resolution <code>vec2</code> uniform <code>fragCoord</code> Pixel coordinate <code>vec2</code> from mainImage <code>NUM_NOISE_OCTAVES</code> Octave count for FBM <code>int</code> 5 <code>NOISE</code> Macro to toggle FBM vs base noise macro <code>#define NOISE fbm</code>"},{"location":"shaders/noise/2d_noise/#full-shader-code","title":"\ud83d\udcbb Full Shader Code","text":"<p><pre><code>// ==========================================\n// Shader: Procedural Noise with FBM\n// Category: Noise Generation\n// Description: Generates smooth procedural textures using hash-based noise and fractal Brownian motion (FBM).\n// Screenshot: screenshots/noise/2d noise.png\n// ==========================================\n\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n\nfloat hash(float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(float x) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i &lt; NUM_NOISE_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i &lt; NUM_NOISE_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = fragCoord.xy * 0.1 - vec2(iTime * 5.0, iResolution.y / 2.0);\n    float v = NOISE(coord);\n    fragColor.rgb = pow(v, 0.35) * 1.3 * normalize(vec3(0.5, fragCoord.xy / iResolution.xy)) + vec3(v * 0.25);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/3d_noise/","title":"\ud83e\udde9 3D Noise Shader Functions","text":"<ul> <li>Category: Noise  </li> <li>Author: Xuetong Fu  </li> <li>Shader Type: 3D procedural noise + texture sampling  </li> <li>Input Requirements: <code>vec3</code>, <code>sampler3D</code>, <code>sampler2D</code>, <code>scales[]</code>, <code>iTime</code></li> </ul>"},{"location":"shaders/noise/3d_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/3d_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This module defines several 3D noise generation methods using both 3D textures and simulated 3D sampling from 2D textures. These techniques are foundational for:</p> <ul> <li>Volumetric cloud rendering  </li> <li>Terrain and density field generation  </li> <li>Procedural texture effects  </li> </ul> <p>It also provides an FBM-based noise method that allows for octave scaling and temporal evolution.</p>"},{"location":"shaders/noise/3d_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>x</code>, <code>p</code> 3D sampling position <code>vec3</code> <code>vec3(x, y, z)</code> <code>texture3DInput</code> Input 3D texture <code>sampler3D</code> <code>texture3DInput</code> <code>texture2DInput</code> Input 2D texture <code>sampler2D</code> <code>texture2DInput</code> <code>oct</code> Number of FBM octaves <code>int</code> <code>5</code> <code>scales[]</code> Frequency scaling per octave <code>float[8]</code> <code>[2.0, 2.3, 2.7, ...]</code> <code>iTime</code> Animation time (for dynamic FBM) <code>float</code> <code>3.14</code>"},{"location":"shaders/noise/3d_noise/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>uniform sampler3D texture3DInput;\nuniform sampler2D texture2DInput;\nuniform float scales[8];\nuniform float iTime;\n\n// Sample noise from a 3D texture (trilinear interpolation)\nfloat texture3DInterNoise(in vec3 x, sampler3D texture3DInput) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    x = p + f;\n    return textureLod(texture3DInput, (x + 0.5) / 32.0, 0.0).x * 2.0 - 1.0;\n}\n\n// Simulated 3D noise by sampling 2D texture, using layered offsets\nfloat dis3DSampling2DNoise(in vec3 x, sampler2D texture2DInput) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 239.0) * p.z) + f.xy;\n    vec2 rg = textureLod(texture2DInput, (uv + 0.5) / 256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;\n}\n\n// Bilinear fetch and Z interpolation from texelFetch on 2D\nfloat sample3Dfrom2DNoise(in vec3 x, sampler2D texture2DInput) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    ivec3 q = ivec3(p);\n    ivec2 uv = q.xy + ivec2(37, 239) * q.z;\n    vec2 rg = mix(\n        mix(texelFetch(texture2DInput, (uv) &amp; 255, 0),\n            texelFetch(texture2DInput, (uv + ivec2(1, 0)) &amp; 255, 0), f.x),\n        mix(texelFetch(texture2DInput, (uv + ivec2(0, 1)) &amp; 255, 0),\n            texelFetch(texture2DInput, (uv + ivec2(1, 1)) &amp; 255, 0), f.x),\n        f.y).yx;\n    return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;  \n}\n\n// Time-varying FBM with octave scaling (uses external noise())\nfloat fbm3D(in vec3 p, int oct) {\n    if (oct &gt; 8) return 0.0;\n\n    vec3 q = p - vec3(0.0, 0.1, 1.0) * iTime; \n    float g = 0.5 + 0.5 * noise(q * 0.3);\n    float f = 0.5 * noise(q);\n    float amp = 0.5;\n\n    for (int i = 1; i &lt; oct; i++) {\n        f += amp * noise(q);\n        q *= scales[i - 1];\n        amp *= 0.5;\n    }\n\n    f += amp * noise(q);\n    f = mix(f * 0.1 - 0.5, f, g * g);\n    return 1.5 * f - 0.5 - p.y;\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/3d_noise/#example-use","title":"Example Use","text":"<pre><code>// noise function from 3D_noise.glsl\nvec2 GetGradient(vec2 intPos, float t) {\n\n    // Uncomment for calculated rand\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n\n    // Texture-based rand (a bit faster on my GPU)\n    //float rand = texture(iChannel0, intPos / 64.0).r;\n\n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n// using Pseudo3dNoise()\nfloat fbm3D(in vec3 p, int oct)\n{\n    if (oct &gt; 8) return 0.0;\n\n    vec3 q = p - vec3(0.0, 0.1, 1.0) * iTime; \n    float g = 0.5 + 0.5 * Pseudo3dNoise(q * 0.3);\n    float f = 0.5 * Pseudo3dNoise(q);\n    float amp = 0.5;\n\n    for(int i = 1; i &lt; oct; i++){\n        f += amp * Pseudo3dNoise(q);\n        q *= scales[i-1];\n        amp *= 0.5;\n    }\n\n    f += amp * Pseudo3dNoise(q);\n    f = mix(f * 0.1 - 0.5, f, g * g);\n    return 1.5 * f - 0.5 - p.y;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [0,1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Map to [-1,1] and fix aspect ratio\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x / iResolution.y;\n\n    // Create 3D position by adding time as Z\n    vec3 p = vec3(xy * 2.0, iTime * 0.2);\n\n    // Evaluate 3D FBM noise with 6 octaves\n    float f = fbm3D(p, 6);\n\n    // Convert to grayscale color\n    vec3 color = vec3(f);\n\n    fragColor = vec4(color, 1.0);\n}\n</code></pre>"},{"location":"shaders/noise/3d_perlin_noise/","title":"\ud83e\udde9 3D Perlin Gradient Noise Shader","text":"<ul> <li>Category: Noise  </li> <li>Shader Type: Pseudo 3D Gradient Noise (Perlin-style)  </li> <li>Input Requirements: <code>vec3 pos (xy + time)</code>, <code>fragCoord</code>, <code>iTime</code>, <code>iResolution</code> </li> <li>Output: Animated grayscale gradient noise</li> </ul>"},{"location":"shaders/noise/3d_perlin_noise/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This is a 2D grid gradient noise shader using time as the Z dimension (pseudo-3D).</li> <li>Gradient direction is randomized via <code>sin(dot(...))</code> without lookup textures.</li> <li>Good for dynamic flow fields, animated bump maps, stylized fluid noise.</li> </ul>"},{"location":"shaders/noise/3d_perlin_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/3d_perlin_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader simulates Perlin-style gradient noise using:</p> <ul> <li>A 2D grid of dynamically rotated gradient vectors  </li> <li>Time-dependent gradient rotation for pseudo-3D behavior  </li> <li>Smooth interpolation with Hermite blending (<code>f * f * (3 - 2f)</code>)</li> </ul> <p>The result is a time-varying field of smooth noise between <code>[-1.0, 1.0]</code>, visualized as grayscale.</p>"},{"location":"shaders/noise/3d_perlin_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iTime</code> Global time (used as z in 3D input) <code>float</code> uniform <code>iResolution</code> Viewport resolution <code>vec2</code> uniform"},{"location":"shaders/noise/3d_perlin_noise/#full-shader-code","title":"\ud83d\udcbb Full Shader Code","text":"<p><pre><code>// ==========================================\n// Shader: Perlin-3D Gradient Noise Shader\n// Category: Noise\n// Description: Generates time-varying 2D noise with pseudo-3D gradient noise using dynamic gradients.\n// Uses Perlin-style gradient noise with time-animated gradients.\n// Screenshot: screenshots/noise/3d perlin noise.png\n// ==========================================\n\nvec2 GetGradient(vec2 intPos, float t) {\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n\n    return noiseVal / 0.7; // normalize to [-1, 1]\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float noiseVal = 0.5 + 0.5 * Pseudo3dNoise(vec3(uv * 10.0, iTime));\n    fragColor.rgb = vec3(noiseVal);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/Noise_System/","title":"Noise System Shader by Saeed Shamseldin","text":""},{"location":"shaders/noise/Noise_System/#overview","title":"Overview","text":"<p>The noise system in this shader provides procedural pattern generation for textures, terrain, and effects. It includes some noise algorithms that integrate seamlessly with the SDF geometry and lighting systems to create organic, dynamic visuals.</p>"},{"location":"shaders/noise/Noise_System/#example-noise-function","title":"Example Noise Function","text":""},{"location":"shaders/noise/Noise_System/#fractal-brownian-motion-fbmpseudo3d","title":"Fractal Brownian Motion (fbmPseudo3D)","text":"<pre><code>void fbmPseudo3D(vec3 p, int octaves, out float result) {\n    result = 0.0;\n    float amp = 0.5, freq = 1.0;\n    for (int i = 0; i &lt; octaves; ++i) {\n        float noise;\n        Pseudo3dNoise(p * freq, noise);\n        result += amp * noise;\n        freq *= 2.0; amp *= 0.5; // Higher frequency, lower amplitude\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: Adds detail by layering noise at multiple frequencies.</p> </li> <li> <p>Parameters:</p> <ul> <li>octaves: Number of layers (typically 3\u20136).</li> <li>p: Input coordinate.</li> </ul> </li> </ul>"},{"location":"shaders/noise/Noise_System/#integration-with-other-systems","title":"Integration with Other Systems","text":""},{"location":"shaders/noise/Noise_System/#raymarching-sdf-perturbation","title":"Raymarching (SDF Perturbation)","text":"<p>Noise modifies SDF distances to create natural imperfections:</p>"},{"location":"shaders/noise/Noise_System/#float-d-evaluatescenep-fbmpseudo3dp-3-03-adds-surface-detail","title":"<pre><code>float d = evaluateScene(p) + fbmPseudo3D(p, 3) * 0.3; // Adds surface detail\n</code></pre>","text":"<p>You can find different noise functions in the noise shaders</p>"},{"location":"shaders/noise/cell_noise/","title":"\ud83e\udde9 Voronoi Cell Noise Visualizer","text":"<ul> <li>Category: Noise  </li> <li>Author: Xunyu Zhang  </li> <li>Shader Type: 2D Voronoi / cell noise  </li> <li>Input Requirements: <code>vec2</code>, <code>float</code>, <code>iResolution</code></li> </ul>"},{"location":"shaders/noise/cell_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/cell_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader generates a Voronoi cell-based noise pattern in 2D space. Each cell is defined by a pseudorandom feature point, and the pattern can be distorted to produce more organic or irregular results.</p> <p>The function returns:</p> <ul> <li><code>color ID</code>: A pseudo-random value per cell  </li> <li><code>border distance</code>: Distance to the nearest cell border (useful for outlines, stylization)</li> </ul>"},{"location":"shaders/noise/cell_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>pos</code> Input position for noise space <code>vec2</code> any <code>vec2(x, y)</code> <code>distortion</code> Controls shape irregularity of the cells <code>float</code> [0.0, 1.0] <code>1.0</code> <code>iResolution</code> Rendering resolution <code>vec2</code> screen size <code>vec2(800, 600)</code>"},{"location":"shaders/noise/cell_noise/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<pre><code>vec2 rand2(vec2 p)\n{\n    vec2 q = vec2(dot(p, vec2(120.0, 300.0)), dot(p, vec2(270.0, 401.0)));\n    return fract(sin(q) * 46111.1111);\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p, vec2(445.5, 360.535))) * 812787.111);\n}\n\nvec2 voronoi(in vec2 pos, float distortion)\n{\n    vec2 cell = floor(pos);\n    vec2 cellOffset = fract(pos);\n    float borderDist = 8.0;\n    float color;\n\n    for (int x = -1; x &lt;= 1; x++)\n    {\n        for (int y = -1; y &lt;= 1; y++)\n        {\n            vec2 samplePos = vec2(float(y), float(x));\n            vec2 center = rand2(cell + samplePos) * distortion;\n            vec2 r = samplePos - cellOffset + center;\n            float d = dot(r, r);\n            float col = rand(cell + samplePos);\n\n            if (d &lt; borderDist)\n            {\n                borderDist = d;\n                color = col;\n            }\n        }\n    }\n\n    borderDist = 8.0;\n    for (int j = -1; j &lt;= 1; j++)\n    {\n        for (int i = -1; i &lt;= 1; i++)\n        {\n            vec2 samplePos = vec2(float(i), float(j));\n            vec2 center = rand2(cell + samplePos) * distortion;\n            vec2 r = samplePos + center - cellOffset;\n\n            if (dot(r, r) &gt; 0.000001)\n            {\n                borderDist = min(borderDist, dot(0.5 * r, normalize(r)));\n            }\n        }\n    }\n    return vec2(color, borderDist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xx;\n    vec2 noise = voronoi(8.0 * uv, 1.0);\n    fragColor = vec4(noise.y, noise.y, noise.x, 1.0);\n}\n</code></pre>"},{"location":"shaders/noise/fbm/","title":"\ud83e\udde9 Fractal Brownian Motion (FBM) Shader","text":"<ul> <li>Category: Noise  </li> <li>Author: Xunyu Zhang  </li> <li>Shader Type: Fractal / Multi-octave noise  </li> <li>Input Requirements: <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>noise()</code>, <code>Pseudo3dNoise()</code>, <code>n31()</code></li> </ul>"},{"location":"shaders/noise/fbm/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/fbm/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>Fractal Brownian Motion (FBM) combines multiple layers (octaves) of noise to produce rich, natural-looking patterns.</p> <p>This module provides several FBM variants:</p> <ul> <li><code>fbm(float, int)</code> \u2013 1D FBM using scalar value noise  </li> <li><code>fbm(vec2, int)</code> \u2013 2D FBM with rotation to reduce artifacts  </li> <li><code>fbmPseudo3D(vec3, int)</code> \u2013 animated pseudo-3D FBM (e.g., for time-evolving textures)  </li> <li><code>fbm_n31(vec3, int)</code> \u2013 FBM built from Shane\u2019s <code>n31()</code> 3D value noise</li> </ul>"},{"location":"shaders/noise/fbm/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>x</code> 1D input coordinate <code>float</code> <code>fbm(0.5, 4)</code> <code>x</code> 2D input coordinate <code>vec2</code> <code>fbm(uv, 5)</code> <code>p</code> 3D position + time (for animation) <code>vec3</code> <code>fbmPseudo3D(vec3(x,y,t), 5)</code> <code>octaves</code> Number of layers to blend <code>int</code> <code>4</code>, <code>6</code>, etc."},{"location":"shaders/noise/fbm/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>#ifndef FBM_GLSL\n#define FBM_GLSL\n\n#include \"noise.glsl\"\n\n// 1D FBM\nfloat fbm(float x, int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = 100.0;\n    for (int i = 0; i &lt; octaves; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D FBM\nfloat fbm(vec2 x, int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i &lt; octaves; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 3D FBM using Pseudo3dNoise\nfloat fbmPseudo3D(vec3 p, int octaves) {\n    float result = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for (int i = 0; i &lt; octaves; ++i) {\n        result += amplitude * Pseudo3dNoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return result;\n}\n\n// 3D FBM using n31 value noise\nfloat fbm_n31(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i &lt; octaves; ++i) {\n        value += amplitude * n31(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n#endif\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/fbm/#example-use","title":"Example Use","text":"<pre><code>void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [0,1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Center and scale UV coordinates for better detail visibility\n    vec2 pos = (uv - 0.5) * 4.0;\n\n    // Add time-based animation offset\n    pos += vec2(iTime * 0.1, 0.0);\n\n    // Compute 2D fractal Brownian motion (FBM) noise\n    float f = fbm(pos, 6);\n\n    // Map FBM value to grayscale color\n    vec3 color = vec3(f);\n\n    fragColor = vec4(color, 1.0);\n}\n</code></pre>"},{"location":"shaders/noise/grayScale_noise/","title":"\ud83e\udde9 Grayscale Noise Shader","text":"<ul> <li>Category: Noise  </li> <li>Author: Saeed Shamseldin  </li> <li>Shader Type: 2D static noise  </li> <li>Input Requirements: <code>vec2</code>, <code>iTime</code>, <code>iResolution</code></li> </ul>"},{"location":"shaders/noise/grayScale_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/grayScale_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader generates animated grayscale noise using a simple hash-based method. Each pixel value is calculated by hashing its UV position with a <code>sin + dot</code> based pseudorandom function.</p> <p>By multiplying UV with <code>sin(iTime)</code>, the noise becomes time-varying and animated.</p>"},{"location":"shaders/noise/grayScale_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>fragCoord</code> Fragment position in screen space <code>vec2</code> pixel size <code>vec2(400, 300)</code> <code>iResolution</code> Screen resolution <code>vec2</code> any <code>vec2(800, 600)</code> <code>iTime</code> Global animation time <code>float</code> <code>\u2265 0.0</code> <code>3.14</code>"},{"location":"shaders/noise/grayScale_noise/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<pre><code>// Simple 2D noise function\nfloat noise2d(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(1.0, 73.0))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize UV coordinates to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Animate UV with time-based warping\n    uv = uv * sin(iTime);\n\n    // Convert noise value to grayscale\n    vec3 col = vec3(noise2d(uv));\n\n    fragColor = vec4(col, 1.0);\n}\n</code></pre>"},{"location":"shaders/noise/hash/","title":"\ud83e\udde9 Hash Utility Functions","text":"<ul> <li>Category: Utility  </li> <li>Shader Type: Hash &amp; Random Number Generators  </li> <li>Author: Xunyu Zhang  </li> <li>Used In: All procedural noise functions (value, gradient, voronoi, FBM, etc.)</li> </ul>"},{"location":"shaders/noise/hash/#description","title":"\ud83e\udde0 Description","text":"<p>This module provides pseudo-random hash functions used throughout the procedural noise system. The output is deterministic but appears random, suitable for:</p> <ul> <li>Value noise  </li> <li>Gradient direction selection  </li> <li>Voronoi jittering  </li> <li>Texture-based random field generation</li> </ul> <p>All outputs are in [0, 1] or [0, 1]^n range. No global state or uniform random is required.</p>"},{"location":"shaders/noise/hash/#provided-functions","title":"\ud83d\udd11 Provided Functions","text":"Function Input Type Output Type Description <code>hash(float)</code> <code>float</code> <code>float</code> Scalar hash for 1D noise <code>hash(vec2)</code> <code>vec2</code> <code>float</code> Grid-based scalar hash <code>hash44</code> <code>vec4</code> <code>vec4</code> High-quality 4D hash (Dave Hoskins method) <code>hash22</code> <code>vec2</code> <code>vec2</code> 2D vector hash with less symmetry <code>rand</code> <code>vec2</code> <code>float</code> Sinusoidal-based pseudo-random scalar <code>rand2</code> <code>vec2</code> <code>vec2</code> 2D pseudo-random vector (used in Voronoi)"},{"location":"shaders/noise/hash/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<p><pre><code>// Hash function for float values\n// Input: \n//   p - float : input value\n// Output:\n//   float : pseudo-random value in range [0, 1]\nfloat hash(float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// Hash function for 2D vectors\n// Input:\n//   p - vec2 : input position\n// Output:\n//   float : pseudo-random value in range [0, 1]\nfloat hash(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// ------------------------------------------------------------\n// 4D Hash by Dave Hoskins \u2013 High-quality, no trig\n// Source: Ruimin Ma / Shane / Dave Hoskins\n// ------------------------------------------------------------\nvec4 hash44(vec4 p) {\n    p = fract(p * vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p += dot(p, p.wzxy + 33.33);\n    return fract((p.xxyz + p.yzzw) * p.zywx);\n}\n\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x + p.y));\n}\n\n// 2D \u2192 1D pseudo-random scalar\n// Input: vec2 p \u2014 grid position\n// Output: float \u2014 random scalar in [0,1]\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(445.5, 360.535))) * 812787.111);\n}\n\n// 2D \u2192 2D pseudo-random vector generator\n// Input: vec2 p \u2014 grid position\n// Output: vec2 \u2014 random vector in [0,1]^2\nvec2 rand2(vec2 p) {\n    vec2 q = vec2(dot(p, vec2(120.0, 300.0)), dot(p, vec2(270.0, 401.0)));\n    return fract(sin(q) * 46111.1111);\n}\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/hash/#example-use","title":"Example Use","text":"<pre><code>void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.0;                  // tile to show cells\n\n    vec2 cell = floor(uv);\n    vec2 local = fract(uv);\n\n    // random offset for current cell\n    vec2 randOffset = rand2(cell);\n\n    // distance to random center in current cell\n    float d = distance(local, randOffset);\n\n    // color = based on distance to random center (circle visual)\n    float brightness = smoothstep(0.1, 0.0, d);\n\n    // random color per cell via rand()\n    float cellColor = rand(cell);\n\n    fragColor = vec4(vec3(cellColor * brightness), 1.0);\n}\n</code></pre>"},{"location":"shaders/noise/noise/","title":"\ud83e\udde9 Noise Shader Collection","text":"<ul> <li>Category: Noise</li> <li>Author: Xunyu Zhang</li> <li>Shader Type: noise functions</li> <li>Input Requirements: <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>time</code></li> </ul>"},{"location":"shaders/noise/noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader module combines multiple fundamental noise generation methods into a single file. It depends on <code>hash.glsl</code> and provides both classic and advanced procedural noise techniques:</p> <ul> <li><code>noise(float)</code> \u2014 1D interpolated value noise  </li> <li><code>noise(vec2)</code> \u2014 2D grid-based value noise  </li> <li><code>Pseudo3dNoise(vec3)</code> \u2014 2D gradient noise animated over time (pseudo-3D)  </li> <li><code>n31(vec3)</code> \u2014 3D \u2192 1D value noise using Shane\u2019s hash44 technique  </li> <li><code>voronoi(vec2, float)</code> \u2014 2D Voronoi cell noise with adjustable distortion</li> </ul> <p>These functions support animation, spatial structure, and fractal combination.</p>"},{"location":"shaders/noise/noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>x</code> Input for 1D value noise <code>float</code> \u2013 <code>0.5</code> <code>uv</code> Input for 2D value noise or voronoi <code>vec2</code> UV range <code>vec2(0.3)</code> <code>pos</code> Input for 3D value or pseudo noise <code>vec3</code> \u2013 <code>vec3(x,y,t)</code> <code>distortion</code> Voronoi distortion factor <code>float</code> <code>[0.0, 1.0]</code> <code>0.8</code>"},{"location":"shaders/noise/noise/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<pre><code>#include \"shaders/noise/noise.glsl\"\n\nfloat n1 = noise(uv);                    // 2D value noise\nfloat n2 = Pseudo3dNoise(vec3(uv, t));   // animated pseudo-3D noise\nfloat n3 = n31(vec3(x, y, z));           // 3D-to-1D value noise\nvec2 v  = voronoi(uv, 0.5);              // Voronoi result: (colorID, borderDist)\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/simplex_noise/","title":"\ud83e\udde9 Simplex Noise Shader","text":"<ul> <li>Category: Noise  </li> <li>Author: Xunyu Zhang  </li> <li>Shader Type: simplex noise functions  </li> <li>Input Requirements: <code>vec2</code>, <code>vec3</code></li> </ul>"},{"location":"shaders/noise/simplex_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/simplex_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This module implements 2D and 3D Simplex noise, a gradient noise technique developed by Ken Perlin. Compared to classic value noise, Simplex noise has:</p> <ul> <li>Better visual isotropy  </li> <li>Lower computational cost for higher dimensions  </li> <li>Fewer directional artifacts</li> </ul> <p>This implementation is periodic, tileable, and suitable for both surface texturing and procedural animation.</p>"},{"location":"shaders/noise/simplex_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>uv</code> Input position for 2D noise <code>vec2</code> UV space <code>vec2(0.3)</code> <code>pos3</code> Input position for 3D noise <code>vec3</code> 3D space <code>vec3(x,y,z)</code>"},{"location":"shaders/noise/simplex_noise/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":"<p><pre><code>#include \"shaders/noise/simplex_noise.glsl\"\n\nfloat s2 = simplexNoise(uv);        // 2D simplex noise\nfloat s3 = simplexNoise(pos3);      // 3D simplex noise\n</code></pre> \ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/noise/stylized_glow/","title":"\ud83e\udde9 Glowing Star Overlay Shader","text":"<ul> <li>Category: Noise / Emissive / Decorative  </li> <li>Author: Wanzhang He </li> <li>Shader Type: screen-space overlay  </li> <li>Input Requirements: <code>vec2 uv</code>, <code>iTime</code>, <code>iResolution</code></li> </ul>"},{"location":"shaders/noise/stylized_glow/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/stylized_glow/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader creates a stylized center-based overlay, combining:</p> <ul> <li>A soft glowing radial gradient</li> <li>A 5-pointed star pattern based on angular modulation  </li> <li>Dynamic animation using <code>iTime</code></li> </ul> <p>It operates purely in screen space using normalized coordinates, making it suitable for HUDs, intros, or visual highlights.</p>"},{"location":"shaders/noise/stylized_glow/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>uv</code> Normalized screen coordinates centered at (0,0) <code>vec2</code> <code>[-1, 1]</code> <code>vec2(0.1, -0.2)</code> <code>iTime</code> Global animation timer (Shadertoy style) <code>float</code> <code>\u2265 0.0</code> <code>1.57</code> <code>iResolution</code> Output resolution <code>vec2</code> screen size <code>vec2(800,600)</code>"},{"location":"shaders/noise/stylized_glow/#shader-code-explanation","title":"\ud83d\udcbb Shader Code &amp; Explanation","text":"<pre><code>#define PI 3.14159265359\n\nvec4 computeNoiseOverlay(vec2 uv) {\n    float P = PI / 5.0;\n\n    // Angular star shape function (5-pointed)\n    float starVal = (1.0 / P) * (P - abs(mod(atan(uv.x, uv.y) + PI, 2.0 * P) - P)));\n\n    // Star color region\n    vec4 starColor = (distance(uv, vec2(0.0)) &lt; 0.06 - (starVal * 0.03))\n        ? vec4(2.8, 1.0, 0.0, 1.0)\n        : vec4(0.0);\n\n    // Time-modulated glowing ring\n    float glowFactor = max(0.0, 1.0 - distance(uv * 4.0, vec2(0.0)));\n    vec4 glow = vec4(0.6, 0.2, 0.0, 1.0) * glowFactor * 4.0 * (0.2 + abs(sin(iTime)) * 0.8);\n\n    return glow + starColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;  // maintain aspect ratio\n\n    vec4 overlay = computeNoiseOverlay(uv);\n    fragColor = overlay;\n}\n</code></pre>"},{"location":"shaders/noise/tie_fighter_noise/","title":"\ud83e\udde9 TIE Fighter Noise Shader","text":"<ul> <li>Category: Noise  </li> <li>Author: Ruimin Ma  </li> <li>Shader Type: utility / hash / value noise  </li> <li>Input Requirements: <code>vec3</code>, <code>vec4</code></li> </ul>"},{"location":"shaders/noise/tie_fighter_noise/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/noise/tie_fighter_noise/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader module provides compact, high-performance hash and noise utilities used in the TIE\u2011Fighter shader suite.</p> <p>It includes two core components:</p> <ul> <li><code>hash44(vec4)</code> \u2014 a 4D hash function by Dave Hoskins  </li> <li><code>n31(vec3)</code> \u2014 a 3D-to-1D value noise by Shane  </li> </ul> <p>These functions are standalone, trig-free, and optimized for efficiency and quality in GPU procedural generation.</p>"},{"location":"shaders/noise/tie_fighter_noise/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Range Example <code>p</code> Input vector (vec3 or vec4) <code>vec3</code> / <code>vec4</code> any <code>vec3(x,y,z)</code> / <code>vec4(x,y,z,w)</code>"},{"location":"shaders/noise/tie_fighter_noise/#shader-code-explanation","title":"\ud83d\udcbb Shader Code &amp; Explanation","text":"<pre><code>#ifndef TF_NOISE_UTILS_GLSL\n#define TF_NOISE_UTILS_GLSL\n\n// 1. 4\u2011D Hash \u2013 Dave Hoskins\nvec4 hash44(vec4 p)\n{\n    p = fract(p * vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p += dot(p, p.wzxy + 33.33);\n    return fract((p.xxyz + p.yzzw) * p.zywx);\n}\n\n// 2. 3\u2011D \u2192 1\u2011D Value Noise \u2013 Shane\nfloat n31(vec3 p)\n{\n    const vec3 S = vec3(7.0, 157.0, 113.0); // pairwise-prime steps\n    vec3 ip = floor(p);     // lattice cell\n    p = fract(p);           // local position\n\n    // Hermite interpolation\n    p = p * p * (3.0 - 2.0 * p);\n\n    // Hash 4 cube corners and interpolate\n    vec4 h = vec4(0.0, S.yz, S.y + S.z) + dot(ip, S);\n    h = mix(hash44(h), hash44(h + S.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n#endif // TF_NOISE_UTILS_GLSL\n</code></pre>"},{"location":"shaders/rendering/Heightfield_Ray_Intersection/","title":"Heightfield Raycast","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Height-based terrain raymarcher</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>ro</code>: Ray origin (camera position)</p> <p><code>rd</code>: Ray direction (normalized)</p> <p><code>tmin</code>: Starting distance along the ray</p> <p><code>tmax</code>: Maximum raymarch distance</p>"},{"location":"shaders/rendering/Heightfield_Ray_Intersection/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Heightfield_Ray_Intersection/#1heightfield_raycastvec3-ro-vec3-rd-float-tmin-float-tmax","title":"1.<code>heightfield_raycast(vec3 ro, vec3 rd, float tmin, float tmax)</code>","text":"<p>This function iteratively finds the intersection of a ray with a single-valued terrain heightfield defined by <code>terrainM(xz)</code>.</p> <ol> <li>Initialize raymarching:</li> </ol> <pre><code>float t = tmin;\n</code></pre> <ol> <li>Iteratively refine intersection:</li> </ol> <p>For up to 300 steps:</p> <ul> <li>Compute current position:</li> </ul> \\[ \\mathbf{p} = \\mathbf{ro} + t \\cdot \\mathbf{rd} \\] <ul> <li>Compute height difference:</li> </ul> \\[ h = p_y - \\text{terrainM}(p_{xz}) \\] <ul> <li>Convergence check:</li> </ul> \\[ |h| &lt; 0.0015 \\cdot t \\quad \\text{or} \\quad t &gt; t_{\\text{max}} \\] <ul> <li>Advance step:</li> </ul> \\[ t \\leftarrow t + 0.4 \\cdot h \\] <ol> <li> <p>Return <code>t</code> as the hit distance:</p> </li> <li> <p>If \\($$ t \\geq t_{\\text{max}} $$\\): the ray missed the terrain.</p> </li> <li>If \\( $$t &lt; t_{\\text{max}} $$\\): the ray hit the surface.</li> </ol> <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>ro</code> Ray origin (camera position in world space) \u2014 Starting point of ray <code>rd</code> Ray direction (normalized) \u2014 Direction of marching <code>tmin</code> Near-plane or terrain entry distance \u2014 Used to index into <code>iChannel1</code> <code>tmax</code> Maximum tracing distance (e.g. far-plane) \u2014 Defines bounding volume for the search output Distance to terrain intersection (or \u2265 tmax) \u2014 Used to test hit vs miss"},{"location":"shaders/rendering/Heightfield_Ray_Intersection/#code","title":"\ud83d\udcbb Code","text":"<p><code>heightfield_raycast</code> finds the first intersection point between a ray and a terrain defined by a height function <code>terrainM(xz)</code>. It uses iterative refinement with adaptive steps and returns the distance along the ray to the hit point.</p> <pre><code>float heightfield_raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float t = tmin;                       // start from tmin\n\n    for (int i = 0; i &lt; 300; i++)\n    {\n        vec3 pos = ro + t * rd;           // current position along the ray\n        float h   = pos.y - terrainM(pos.xz);\n                                           // h = current point altitude \u2212 terrain height at (x, z)\n        // if |h| &lt; 0.0015 * t or t &gt; tmax, stop\n        if (abs(h) &lt; (0.0015 * t) || t &gt; tmax)\n            break;\n\n        // otherwise advance by 0.4 * h\n        t += 0.4 * h;\n    }\n\n    return t;\n}\n/*\nUsage example (inside a render function):\n\nfloat terrainM(vec2 xz) {\n    // ... user-defined height field ...\n}\n\nvec4 render(in vec3 ro, in vec3 rd)\n{\n    // 1. Determine ray\u2013terrain bounding distance\n    float tmin = 1.0;\n    float tmax = FAR_DISTANCE; // some large value or computed from sky plane intersection\n\n    // 2. Call heightfield_raycast to get hit distance\n    float t = heightfield_raycast(ro, rd, tmin, tmax);\n\n    vec3 color;\n    if (t &gt;= tmax) {\n        // no hit \u2192 render sky\n        color = skyColour(rd);\n    } else {\n        // hit at t &lt; tmax \u2192 render terrain surface\n        vec3 pos = ro + rd * t;             // intersection point\n        vec3 nor = calcNormalHF(pos);       // compute normal from height field\n        color = shadeTerrain(pos, nor, rd); // lighting/material for terrain\n    }\n\n    return vec4(color, 1.0);\n}\n*/\n</code></pre>"},{"location":"shaders/rendering/Oriented_Box_Intersection/","title":"Oriented Box Intersection","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Oriented bounding box ray intersection</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>ro</code>: Ray origin in world space</p> <p><code>rd</code>: Ray direction (normalized)</p> <p><code>boxPos</code>: Center position of the box</p> <p><code>halfSize</code>: Half-extents in local x/y/z</p> <p><code>rot</code>: Box rotation matrix (local \u2192 world)</p>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Oriented_Box_Intersection/#1rm_tracebox","title":"1.<code>rm_traceBox(...)</code>","text":"<p>This function performs an analytic intersection between a ray and a rotated box using six face tests.</p>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#1-each-face-is-treated-as-a-rotated-quad","title":"1. Each face is treated as a rotated quad:","text":"<p>The function calls <code>rm_traceQuad(...)</code> for all 6 faces:</p> <ul> <li>2 front/back (Z)  </li> <li>2 left/right (X)  </li> <li>2 top/bottom (Y)</li> </ul>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#2-intersect-ray-with-each-face","title":"2. Intersect ray with each face:","text":"<p>For a face at position p with normal n, compute:</p> \\[ t = \\frac{(\\mathbf{p} - \\mathbf{ro}) \\cdot \\mathbf{n}}{\\mathbf{rd} \\cdot \\mathbf{n}} \\] <p>Then project the hit point into the local box space and verify it lies within the rectangle.</p>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#3-find-earliest-valid-hit-time-tenter","title":"3. Find earliest valid hit time (<code>tEnter</code>):","text":"\\[ t_{\\text{enter}} = \\min \\{ t_0, t_1, ..., t_5 \\} \\quad \\text{(where } t_i \\geq 0\\text{)} \\] <p>If all intersections are negative, return <code>vec2(-1.0)</code> for a miss.</p>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#4-find-earliest-valid-exit-texit-tenter","title":"4. Find earliest valid exit (<code>tExit</code>) \u2260 <code>tEnter</code>:","text":"<p>Scan remaining faces to get the nearest valid exit distance greater than <code>tEnter</code>.</p>"},{"location":"shaders/rendering/Oriented_Box_Intersection/#5-return-the-result","title":"5. Return the result:","text":"<pre><code>return vec2(tEnter, tExit);\n</code></pre> <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>ro</code> Ray origin (camera position in world space) \u2014 Starting point of ray <code>rd</code> Ray direction (normalized) \u2014 Direction of marching <code>boxPos</code> Center of the box in world space \u2014 Midpoint of box volume <code>halfSize</code> Half extents of the box in local space \u2014 Dimensions along x, y, z directions <code>rot</code> Rotation matrix from local box space to world \u2014 Use <code>rm_rotX/Y/Z()</code> to build it output <code>vec2(tEnter, tExit)</code> or <code>vec2(-1.0)</code> if missed \u2014 tEnter &lt; 0.0 \u2192 miss; else [entry, exit] ray segment inside"},{"location":"shaders/rendering/Oriented_Box_Intersection/#code","title":"\ud83d\udcbb Code","text":"<p><code>rm_traceBox</code> tests whether a ray intersects a rotated box (OBB) and returns the entry and exit distances along the ray. It uses face-by-face analytical tests for robust culling and sub-segment restriction of more expensive ray evaluations.</p> <pre><code>#ifndef RAY_BOX_INTERSECT_GLSL\n#define RAY_BOX_INTERSECT_GLSL\n\n/* \n   full example combined with existing RayMarch + GetNormal helpers\n   -------------------------------------------------------------------------\n       // provided in our project:\n       //   bool  RayMarch(vec3 ro, vec3 rd, out float dist);\n       //   vec3  GetNormal(vec3 p);\n\n       // (1) cull with OBB\n       vec2 hit = rm_traceBox(ro, rd, u_BoxPos, u_HalfSize, u_BoxRot);\n       if (hit.x &gt;= 0.0)                     // ray crosses the box\n       {\n           // (2) march *inside* the box only\n           vec3  marchOrigin = ro + rd * hit.x;      // start on entry face\n           float boxSegment  = hit.y - hit.x;        // allowed travel\n\n           float distInside;                         // distance marched\n           bool  surfaceHit = RayMarch(marchOrigin, rd, distInside);\n\n           if (surfaceHit &amp;&amp; distInside &lt;= boxSegment)\n           {\n               // (3) shading\n               vec3 hitPos = marchOrigin + rd * distInside;\n               vec3 n      = GetNormal(hitPos);\n               vec3 color  = ShadeLambert(n, baseColor, lightDir);\n               // ...\n           }\n       }\n\n   ------------------------------------------------------------------------- */\n\n// PI constants --------------------------------------------------------------\nconst float PI  = 3.141592653589793;\nconst float PI2 = 1.5707963267948966;   // PI / 2\n\n// rotation helpers (row\u2011major 3\u00d73) -----------------------------------------\nmat3 rm_rotX(float a){\n    float s = sin(a), c = cos(a);\n    return mat3( 1.0, 0.0, 0.0,\n                 0.0,   c,  -s,\n                 0.0,   s,   c);\n}\nmat3 rm_rotY(float a){\n    float s = sin(a), c = cos(a);\n    return mat3(   c, 0.0,   s,\n                 0.0, 1.0, 0.0,\n                  -s, 0.0,   c);\n}\nmat3 rm_rotZ(float a){\n    float s = sin(a), c = cos(a);\n    return mat3(   c,  -s, 0.0,\n                   s,   c, 0.0,\n                 0.0, 0.0, 1.0);\n}\n\n/* ---------------------------------------------------------------------------\n   rm_traceQuad  \u2013 analytic ray / rectangle intersection (internal)\n   ---------------------------------------------------------------------------\n   ro(vec3)      : ray origin (world space)\n   rd(vec3)      : *normalised* ray direction\n   quadPos(vec3) : centre of the quad (world space)\n   halfSize(vec2): half\u2011extent in local X &amp; Y\n   rot(mat3)     : local \u2192 world rotation\n   pivot(vec3)   : \u00b1halfSize.z, distinguishes the two faces\n\n   returns: t along the ray (&lt;0.0 = miss)                                           */\nfloat rm_traceQuad(in vec3 ro, in vec3 rd,\n                   in vec3 quadPos,\n                   in vec2 halfSize,\n                   in mat3 rot,\n                   in vec3 pivot)\n{\n    vec3 planePos = quadPos + rot * pivot;\n    vec3 planeN   = rot * vec3(0.0, 0.0, -1.0);\n\n    float denom = dot(rd, planeN);\n    if (abs(denom) &lt; 1e-5) return -1.0;           // ray \u2016 plane\n\n    float t = dot(planePos - ro, planeN) / denom;\n    if (t &lt; 0.0) return -1.0;                     // plane behind origin\n\n    // bounds check in quad local space\n    vec3 hitP = transpose(rot) * (ro + rd * t - quadPos);\n    if (abs(hitP.x) &gt; halfSize.x || abs(hitP.y) &gt; halfSize.y) return -1.0;\n\n    return t;\n}\n\n// positive\u2011only min helper ---------------------------------------------------\nfloat rm_pmin(float a, float b){\n    return (a &gt;= 0.0 &amp;&amp; b &gt;= 0.0) ? min(a, b) :\n           (a &gt;= 0.0)             ? a         :\n                                     b;\n}\n\n/* ---------------------------------------------------------------------------\n   rm_traceBox \u2013 PUBLIC API\n   ---------------------------------------------------------------------------\n   ro(vec3)      : ray origin (world space)\n   rd(vec3)      : *normalised* ray direction\n   boxPos(vec3)  : box centre (world space)\n   halfSize(vec3): half\u2011extents in local/model space\n   rot(mat3)     : model \u2192 world rotation\n\n   returns vec2(tEnter, tExit)\n           tEnter &lt; 0.0  \u2192 miss\n           otherwise     \u2192 ray inside box for t \u2208 [tEnter, tExit]               */\nvec2 rm_traceBox(in vec3 ro, in vec3 rd,\n                 in vec3 boxPos,\n                 in vec3 halfSize,\n                 in mat3 rot)\n{\n    vec4 piv = vec4(halfSize, 0.0);\n\n    float t0 = rm_traceQuad(ro, rd, boxPos,       halfSize.xy,       rot,             piv.wwz);\n    float t1 = rm_traceQuad(ro, rd, boxPos,       halfSize.xy,       rot,            -piv.wwz);\n\n    float t2 = rm_traceQuad(ro, rd, boxPos, halfSize.zy, rot * rm_rotY(PI2),  piv.wwx);\n    float t3 = rm_traceQuad(ro, rd, boxPos, halfSize.zy, rot * rm_rotY(PI2), -piv.wwx);\n\n    float t4 = rm_traceQuad(ro, rd, boxPos, halfSize.xz, rot * rm_rotX(PI2), -piv.wwy);\n    float t5 = rm_traceQuad(ro, rd, boxPos, halfSize.xz, rot * rm_rotX(PI2),  piv.wwy);\n\n    float tEnter = rm_pmin(rm_pmin(t0, t1),\n                           rm_pmin(rm_pmin(t2, t3), rm_pmin(t4, t5)));\n    if (tEnter &lt; 0.0) return vec2(-1.0);\n\n    float tExit = 1e30;\n    if (t0 &gt; 0.0 &amp;&amp; t0 != tEnter) tExit = min(tExit, t0);\n    if (t1 &gt; 0.0 &amp;&amp; t1 != tEnter) tExit = min(tExit, t1);\n    if (t2 &gt; 0.0 &amp;&amp; t2 != tEnter) tExit = min(tExit, t2);\n    if (t3 &gt; 0.0 &amp;&amp; t3 != tEnter) tExit = min(tExit, t3);\n    if (t4 &gt; 0.0 &amp;&amp; t4 != tEnter) tExit = min(tExit, t4);\n    if (t5 &gt; 0.0 &amp;&amp; t5 != tEnter) tExit = min(tExit, t5);\n\n    return vec2(tEnter, tExit);\n}\n\n#endif // RAY_BOX_INTERSECT_GLSL\n</code></pre>"},{"location":"shaders/rendering/Ray_Marching/","title":"Ray Marching Function","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Signed Distance Function based ray traversal</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>ro</code>: world-space ray origin (camera position)</p> <p><code>rd</code>: normalized ray direction</p>"},{"location":"shaders/rendering/Ray_Marching/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Ray_Marching/#1-raymarchvec3-ro-vec3-rd-out-float-dist","title":"1. <code>RayMarch(vec3 ro, vec3 rd, out float dist)</code>","text":"<p>Performs ray marching using Signed Distance Fields (SDF):</p> <ul> <li>Step forward along the ray up to a maximum number of steps (<code>MAX_STEPS</code>).</li> <li>At each step:</li> <li>Compute the distance from the current point to the closest surface using the <code>scene()</code> function.</li> <li>If the distance is less than a small threshold (<code>SURF_DIST</code>), consider the surface hit and return <code>true</code>.</li> <li>Otherwise, march forward by that distance.</li> <li>If the total marched distance exceeds <code>MAX_DIST</code>, assume no intersection and return <code>false</code>.</li> </ul> <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>MAX_STEPS</code> Step up to MAX_STEPS(100) times. If it hasn't hit the object yet, give up constant Global Parameters <code>MAX_DIST</code> If the light travels a total distance of more than 100 units, it is also considered not to have touched the object. constant Global Parameters <code>SURF_DIST</code> If the current distance from the surface of the object is less than SURF_DIST(0.01), it is considered to have touched the surface. constant Global Parameters <code>ro</code> Ray origin (camera position) \u2014 world-space camera position <code>rd</code> Ray direction (normalized) \u2014 normalized, from camera to object <code>bool</code> true  = surface hit, false = background \u2014 Output parameter <code>dist</code> Output distance along ray to surface 0.0 - MAX_DIST Output parameter"},{"location":"shaders/rendering/Ray_Marching/#code","title":"\ud83d\udcbb Code","text":"<p>RayMarch performs sphere tracing by repeatedly sampling the Signed Distance Field (SDF) along a ray. It returns whether the ray hits a surface and the distance traveled to reach it.</p> <pre><code>#define MAX_STEPS 100 // Step up to 100 times. If it hasn't hit the object yet, give up\n#define MAX_DIST 100.0 // If the light travels a total distance of more than 100 units, it is also considered not to have touched the object.\n#define SURF_DIST 0.01 //If the current distance from the surface of the object is less than 0.01, it is considered to have touched the surface.\n\nbool RayMarch(vec3 ro, vec3 rd, out float dist) \n{\n    float dist = 0.0;                       \n    for (int i = 0; i &lt; MAX_STEPS; i++) \n    { \n        vec3 currentPos  = ro + rd * dist;           \n        float distToSDF = scene(currentPos);              /* !!! Make sure the SDF for your object is provided through a global function named scene !!! */                         \n        if (distToSDF &lt; SURF_DIST) return true;\n        dist = dist + distToSDF;\n        if (dist &gt; MAX_DIST) break;\n    }\n    return false;                            \n}\n/*\nusage example:\n\nfloat dist;\nbool hit = RayMarch(ro, rd, dist);\n\nvec3 color = vec3(0.0);\nif (hit) {\n    vec3 hitPos = ro + rd * dist;\n    vec3 n = Normal(hitPos);\n    color  = shadeLambert(n, baseColor, lightDir);\n}\n*/\n</code></pre>"},{"location":"shaders/rendering/Sphere_Intersection_Function/","title":"Sphere Intersection Function","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Analytic ray-sphere intersection</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>ro</code>: ray origin (world space)</p> <p><code>rd</code>: ray direction (normalized)</p> <p><code>center</code>: sphere center (world space)</p> <p><code>radius</code>: sphere radius</p>"},{"location":"shaders/rendering/Sphere_Intersection_Function/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Sphere_Intersection_Function/#1-spherevec3-ro-vec3-rd-vec3-center-float-radius","title":"1. <code>sphere(vec3 ro, vec3 rd, vec3 center, float radius)</code>","text":"<p>This function calculates the distance to the intersection point between a ray and a sphere using the standard quadratic formula:</p> <ol> <li> <p>The ray is translated so the sphere is centered at the origin.</p> </li> <li> <p>The intersection condition is derived from solving:</p> </li> </ol> <p>$$    \\left| \\mathbf{ro} + t \\cdot \\mathbf{rd} - \\mathbf{center} \\right|^2 = r^2    $$</p> <p>which expands to a quadratic equation in <code>t</code>:</p> <p>$$    t^2 + 2bt + c = 0    $$</p> <ol> <li> <p>The discriminant \\(d = b^2 - c\\) determines whether a real root (intersection) exists.</p> </li> <li> <p>If \\(d \\geq 0\\) and the closest root \\(t = -b - \\sqrt{d} \\geq 0\\), then the ray hits the sphere.</p> </li> <li> <p>Otherwise, return `-1.0` to indicate a miss.</p> </li> </ol> <p>This function returns the nearest positive hit distance <code>t</code> or <code>-1.0</code> if the ray misses the sphere.</p> <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>ro</code> Ray origin (camera position) \u2014 World-space coordinate <code>rd</code> Ray direction (normalized) \u2014 Must be normalized <code>center</code> Sphere center \u2014 World-space position <code>radius</code> Sphere radius <code>&gt;0</code> Positive radius required output Hit distance or <code>-1.0</code> for miss <code>&gt;0 or -1</code> Return <code>-1.0</code> if no intersection"},{"location":"shaders/rendering/Sphere_Intersection_Function/#code","title":"\ud83d\udcbb Code","text":"<p><code>sphere</code> analytically computes the intersection of a ray with a sphere by solving a quadratic equation. It returns the nearest positive hit distance or <code>-1.0</code> if there is no intersection.</p> <pre><code>float sphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    /* shift the ray so the sphere is at the origin */\n    vec3 rc = ro - center;                              // ray-to-centre vector\n\n    /* coefficients of the quadratic  t\u00b2 + 2\u00b7b\u00b7t + c = 0  (a = 1 because |rd| = 1) */\n    float c = dot(rc, rc) - radius * radius;            // c = |rc|\u00b2 \u2212 r\u00b2\n    float b = dot(rd, rc);                              // b = rd\u00b7rc\n\n    /* discriminant  d = b\u00b2 \u2212 c  */\n    float d = b*b - c;\n\n    /* nearest root  t = \u2212b \u2212 \u221ad   (if d &lt; 0 \u2192 imaginary roots) */\n    float t  = -b - sqrt(abs(d));\n\n    /* hit test:\n         step(0, min(t,d)) \u2192 1  when  d \u2265 0  *and*  t \u2265 0\n                              0  otherwise                       */\n    float st = step(0.0, min(t, d));\n\n    /* mix( missValue , hitValue , st ) */\n    return mix(-1.0, t, st);                             // \u20131.0 = miss\n}\n\n/*\nusage example:\n    float dist = sphere(ro, rd, p, 1.0); \n    vec3 normal = normalize(p - (ro+rd*dist));\n*/\n</code></pre>"},{"location":"shaders/rendering/Surface_Normal_Estimation/","title":"Surface Normal Estimation","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Tetrahedral adaptive SDF normal estimation</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>p</code>: 3D world-space position at which to estimate the surface normal</p>"},{"location":"shaders/rendering/Surface_Normal_Estimation/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Surface_Normal_Estimation/#1-getnormalvec3-p","title":"1. <code>GetNormal(vec3 p)</code>","text":"<p>Estimates the surface normal at a given point <code>p</code> by computing the gradient of the Signed Distance Field (SDF) using central differences:</p> <ul> <li>Defines a small epsilon offset <code>eps = 0.001</code>.</li> <li>For each axis (x, y, z), it evaluates the SDF at slightly perturbed positions forward and backward.</li> <li>The difference between these values along each axis approximates the partial derivative.</li> <li>The resulting gradient vector is normalized to produce a unit-length surface normal pointing outward from the surface.</li> </ul>"},{"location":"shaders/rendering/Surface_Normal_Estimation/#formula","title":"Formula:","text":"<p>Let <code>Scene(p)</code> be the Signed Distance Field function, and <code>p = (x, y, z)</code>. The surface normal vector <code>n</code> is approximated using central differences: $$ \\mathbf{n} \\approx \\frac{1}{2\\epsilon} \\begin{pmatrix} \\text{Scene}(x+\\epsilon, y, z) - \\text{Scene}(x-\\epsilon, y, z) \\ \\text{Scene}(x, y+\\epsilon, z) - \\text{Scene}(x, y-\\epsilon, z) \\ \\text{Scene}(x, y, z+\\epsilon) - \\text{Scene}(x, y, z-\\epsilon) \\end{pmatrix} $$</p> <p>Then normalized to obtain the unit normal vector:</p> \\[ \\hat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|} \\] <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>p</code> World-space position to estimate normal Usually the surface hit point <code>eps</code> Step size for central differencing constant(0.01)"},{"location":"shaders/rendering/Surface_Normal_Estimation/#code","title":"\ud83d\udcbb Code","text":"<p><code>GetNormal</code> computes an approximate surface normal at a given point <code>p</code> by evaluating the gradient of the Signed Distance Field using central differences.</p> <pre><code>vec3 GetNormal(vec3 p) {\n    float eps = 0.001;\n    vec2 h = vec2(eps, 0);\n    float dx = Scene(p + vec3(h.x, h.y, h.y)) - Scene(p - vec3(h.x, h.y, h.y));\n    float dy = Scene(p + vec3(h.y, h.x, h.y)) - Scene(p - vec3(h.y, h.x, h.y));\n    float dz = Scene(p + vec3(h.y, h.y, h.x)) - Scene(p - vec3(h.y, h.y, h.x));\n    return normalize(vec3(dx, dy, dz));\n}\n</code></pre>"},{"location":"shaders/rendering/Tetrahedral_adaptive_SDF_normal_estimation/","title":"Surface Normal Estimation(advanced)","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Tetrahedral adaptive SDF normal estimation</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>pos</code>: World-space surface hit position</p> <p><code>ray</code>: Incident ray direction (normalized)</p> <p><code>t</code>: Hit distance from camera to surface</p>"},{"location":"shaders/rendering/Tetrahedral_adaptive_SDF_normal_estimation/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/Tetrahedral_adaptive_SDF_normal_estimation/#1-calcnormalvec3-pos-vec3-ray-float-t","title":"1. <code>calcNormal(vec3 pos, vec3 ray, float t)</code>","text":"<p>This function computes a surface normal by sampling the Signed Distance Field (SDF) at four off-axis positions around the hit point:</p> <ol> <li>Compute a sampling pitch that grows with the hit distance:</li> </ol> <pre><code>float pitch = 0.5 * t / iResolution.x;\npitch = max(pitch, 0.005);\n</code></pre> <ol> <li>Define a tetrahedral stencil of four offset directions using pitch:</li> </ol> <pre><code>vec3 p0 = pos + vec3(-pitch, -pitch, -pitch);\nvec3 p1 = pos + vec3(-pitch, +pitch, +pitch);\nvec3 p2 = pos + vec3(+pitch, -pitch, +pitch);\nvec3 p3 = pos + vec3(+pitch, +pitch, -pitch);\n</code></pre> <ol> <li>Sample SDF values at these four positions:</li> </ol> <pre><code>float f0 = map(p0).x;\nfloat f1 = map(p1).x;\nfloat f2 = map(p2).x;\nfloat f3 = map(p3).x;\n</code></pre> <ol> <li>Compute weighted gradient using the tetrahedral stencil:</li> </ol> \\[ \\mathbf{g} = f_0 \\cdot \\mathbf{p}_0 + f_1 \\cdot \\mathbf{p}_1 + f_2 \\cdot \\mathbf{p}_2 + f_3 \\cdot \\mathbf{p}_3 - (f_0 + f_1 + f_2 + f_3) \\cdot \\mathbf{pos} \\] <p>This formula estimates the SDF gradient vector from the weighted sample positions and values.</p> <ol> <li>Remove the backward-facing component in the direction of the view ray:</li> </ol> \\[ \\mathbf{g} = \\mathbf{g} - \\max(0, \\mathbf{g} \\cdot \\mathbf{ray}) \\cdot \\mathbf{ray} \\] <p>This ensures that the normal doesn't point back toward the camera, which could cause shading artifacts.</p> <ol> <li>Normalize the result to produce the final unit surface normal:</li> </ol> \\[ \\hat{\\mathbf{n}} = \\frac{\\mathbf{g}}{\\|\\mathbf{g}\\|} \\] <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>pos</code> World-space hit position \u2014 SDF value at this point should be close to zero <code>ray</code> Incident ray direction (normalized) \u2014 Used to remove back-facing gradient component <code>t</code> Hit distance from camera to surface <code>&gt;0</code> Determines adaptive sampling pitch <code>pitch</code> Adaptive sample offset radius (derived from t) <code>&gt;0.005</code> Scales with distance; clamped to avoid undersampling"},{"location":"shaders/rendering/Tetrahedral_adaptive_SDF_normal_estimation/#code","title":"\ud83d\udcbb Code","text":"<p><code>calcNormal</code> estimates the surface normal at a hit point using a tetrahedral 4-sample stencil. The sampling radius adapts based on camera distance, improving sharpness close-up and reducing aliasing far away.</p> <pre><code>vec3 calcNormal( vec3 pos, vec3 ray, float t )\n{\n    float pitch = 0.5 * t / iResolution.x;\n    pitch = max(pitch, 0.005);\n\n    vec2 d = vec2(-1.0, 1.0) * pitch;\n\n    vec3 p0 = pos + d.xxx;\n    vec3 p1 = pos + d.xyy;\n    vec3 p2 = pos + d.yxy;\n    vec3 p3 = pos + d.yyx;\n\n    float f0 = map(p0).x;\n    float f1 = map(p1).x;\n    float f2 = map(p2).x;\n    float f3 = map(p3).x;\n\n    vec3 grad = p0*f0 + p1*f1 + p2*f2 + p3*f3\n              - pos*(f0 + f1 + f2 + f3);\n\n    grad -= max(0.0, dot(grad, ray)) * ray;\n\n    return normalize(grad);\n}\n</code></pre>"},{"location":"shaders/rendering/VolumetricRayMarch/","title":"VolumetricRayMarch","text":"<ul> <li> <p>Category: Rendering</p> </li> <li> <p>Author: Ruimin Ma</p> </li> <li> <p>Shader Type: Cloud-based volumetric integration using blue-noise dithering</p> </li> <li> <p>Input: </p> </li> </ul> <p><code>ro</code>: Ray origin (world-space camera position)</p> <p><code>rd</code>: Ray direction (normalized)</p> <p><code>px</code>: Pixel coordinates (used for blue-noise dither)</p>"},{"location":"shaders/rendering/VolumetricRayMarch/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/rendering/VolumetricRayMarch/#1volumetricraymarchvec3-ro-vec3-rd-ivec2-px","title":"1.<code>VolumetricRayMarch(vec3 ro, vec3 rd, ivec2 px)</code>","text":"<p>This function performs volumetric integration along a ray passing through a cloud slab between defined base and top altitudes:</p> <ol> <li>Compute ray entry/exit points with the cloud slab:</li> </ol> \\[ t_b = \\frac{\\text{CLOUD\\_BASE} - r_o.y}{r_d.y}, \\quad t_t = \\frac{\\text{CLOUD\\_TOP} - r_o.y}{r_d.y} \\] <p>The resulting integration segment \\($$[t_{\\min}, t_{\\max}]$$\\) is derived depending on whether the ray starts above, inside, or below the cloud layer.</p> <ol> <li>Apply blue-noise dithering to the initial sampling location:</li> </ol> <pre><code>float t = tmin + 0.1 * texelFetch(iChannel1, px &amp; 1023, 0).x;\n</code></pre> <p>This helps to eliminate visible banding patterns in the rendered cloud.</p> <ol> <li> <p>Iteratively sample along the ray using adaptive step sizes:</p> </li> <li> <p>Step size increases with distance:</p> </li> </ol> <pre><code>float dt = max(0.05, 0.02 * t);\n</code></pre> <ul> <li> <p>At each sample point:</p> </li> <li> <p>Evaluate density via <code>map(pos, oct)</code></p> </li> <li> <p>If <code>density &gt; 0.01</code>, accumulate color and opacity using premultiplied alpha:</p> \\[ \\alpha = \\min(\\text{clamp}(d, 0, 1) \\cdot 8 \\cdot dt,\\ 1) \\] \\[ \\text{color} += \\vec{c} \\cdot \\alpha \\cdot (1 - A_{\\text{sum}}) \\] </li> <li> <p>Early termination occurs when:</p> </li> <li>\\( $$t &gt; t_{\\max}$$ \\)</li> <li>or accumulated alpha exceeds <code>0.99</code></li> </ul> <ol> <li>Return premultiplied result:</li> </ol> <pre><code>return clamp(sum, 0.0, 1.0);\n</code></pre> <p>## \ud83c\udf9b\ufe0f Parameters</p> Name Description Range Notes <code>ro</code> Ray origin (camera position in world space) \u2014 Starting point of ray <code>rd</code> Ray direction (normalized) \u2014 Direction of marching <code>px</code> Pixel coordinates (for dithering via blue-noise texture) screen resolution Used to index into <code>iChannel1</code> <code>iChannel1</code> External uniform (1024\u00d71024 noise texture) \u2014 Used for stochastic jitter <code>CLOUD_BASE</code> Lower bound of cloud slab in Y typically &lt; 0 <code>CLOUD_TOP</code> Upper bound of cloud slab in Y typically &gt; 0"},{"location":"shaders/rendering/VolumetricRayMarch/#code","title":"\ud83d\udcbb Code","text":"<p><code>VolumetricRayMarch</code> simulates ray marching through a 3D cloud volume. It integrates density-based color and alpha along the ray path using adaptive steps and blue-noise dithering to avoid banding artifacts.</p> <pre><code>#define CLOUD_BASE -3.0\n#define CLOUD_TOP  0.6\nuniform sampler2D iChannel1;  /* !!!1024 \u00d7 1024 single-channel (R) blue-noise or white-noise texture provided by the engine.!!! */\n\nvec4 VolumeticRayMarch(vec3 ro, vec3 rd, ivec2 px) {\n    float tb = (CLOUD_BASE - ro.y) / rd.y; \n    float tt = (CLOUD_TOP  - ro.y) / rd.y;\n\n    float tmin, tmax; // integration segment\n    if (ro.y &gt; CLOUD_TOP)                   // camera above cloud\n    {                                   \n        if (tt &lt; 0.0) return vec4(0.0);\n        tmin = tt; tmax = tb;\n    } \n    else if (ro.y &lt; CLOUD_BASE)             // camera below cloud\n    {\n        if (tb &lt; 0.0) return vec4(0.0);\n        tmin = tb; tmax = tt;\n    } \n    else                                    // camera inside cloud slab\n    {\n        tmin = 0.0;\n        tmax = 60.0;\n        if (tt &gt; 0.0) tmax = min(tmax, tt);\n        if (tb &gt; 0.0) tmax = min(tmax, tb);\n    }\n    // Add blue-noise dither to the first sample position, helps break up banding artifacts\n    float t = tmin + 0.1 * texelFetch(iChannel1, px &amp; 1023, 0).x;\n    vec4 sum = vec4(0.0);  // accumulated RGBA (premultiplied)\n    const int oct = 5;       // FBM octave count (passed to map)\n\n    for (int i = 0; i &lt; 190; i++) {\n        // adaptive step size: finer when close, coarser when fa\n        float dt = max(0.05, 0.02 * t);\n        vec3 pos = ro + t * rd;\n        float den = map(pos, oct); /*!!! Density Function needed, Positive den \u2192 cloud/medium density\u2003\u2003Negative or zero \u2192 empty air!!!*/\n\n        if (den &gt; 0.01) {\n            float alpha = clamp(den, 0.0, 1.0);\n            vec4 col = vec4(vec3(alpha), alpha);\n            col.a = min(col.a * 8.0 * dt, 1.0);\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n\n        t += dt;\n        // exit when outside the cloud or nearly opaque\n        if (t &gt; tmax || sum.a &gt; 0.99) break;\n    }\n    // Clamp numeric drift and return premultiplied colour + alpha\n    return clamp(sum, 0.0, 1.0);\n}\n\n/*\nusage example:\n    float map(vec3 p, int oct)\n    ...\n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    {\n        ...\n        // volume pass\n        vec4 vol = VolumetricRayMarch(ro, rd, ivec2(fragCoord));\n\n        // sky background\n        vec3 sky = skyColour(rd);\n\n        // compositing (premultiplied)\n        vec3 col = mix(sky, vol.rgb, vol.a);\n\n        fragColor = vec4(col, 1.0);\n    } \n*/\n</code></pre>"},{"location":"shaders/scenes/Cloud_fbm/","title":"\ud83e\udde9 Volumetric FBM Cloud Shader","text":"<ul> <li>Category: Scene  </li> <li>Author: Wanzhang He  </li> <li>Shader Type: Procedural cloud via raymarching and 3D FBM  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iResolution</code>, <code>iTime</code> </li> <li>Output: Volumetric soft cloud rendered with 3D hash-based FBM</li> </ul>"},{"location":"shaders/scenes/Cloud_fbm/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This shader renders realistic volumetric clouds using hash-based 3D noise with fractal Brownian motion (FBM).</li> <li>Clouds are raymarched through a procedural density field, with height-dependent fade and soft edges.</li> <li>No textures are used \u2014 all detail is generated algorithmically.</li> <li>Ideal for sky rendering, backgrounds, or atmospheric simulations.</li> </ul>"},{"location":"shaders/scenes/Cloud_fbm/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/Cloud_fbm/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>The clouds are modeled via:</p> <ul> <li>Noise Field: Hash-based 3D value noise used for FBM</li> <li>FBM Perturbation: Time-driven offset and rotation of noise layers</li> <li>Height Fade: Density fades in a band between <code>MIN_HEIGHT</code> and <code>MAX_HEIGHT</code></li> <li>Raymarching: Iteratively samples along the ray to accumulate density</li> <li>Gamma Correction: Final color is tone-adjusted for display</li> </ul>"},{"location":"shaders/scenes/Cloud_fbm/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iResolution</code> Viewport resolution <code>vec2</code> uniform <code>iTime</code> Global time for animation <code>float</code> uniform <code>MIN_HEIGHT</code> Cloud base height <code>float</code> <code>5000.0</code> <code>MAX_HEIGHT</code> Cloud top height <code>float</code> <code>8000.0</code> <code>CLOUD_STEPS</code> Steps taken during raymarching <code>int</code> <code>24</code>"},{"location":"shaders/scenes/Cloud_fbm/#shader-code","title":"\ud83d\udcbb Shader Code","text":"<pre><code>float hash(vec3 p) {\n    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n000 = hash(i + vec3(0.0, 0.0, 0.0));\n    float n001 = hash(i + vec3(0.0, 0.0, 1.0));\n    float n010 = hash(i + vec3(0.0, 1.0, 0.0));\n    float n011 = hash(i + vec3(0.0, 1.0, 1.0));\n    float n100 = hash(i + vec3(1.0, 0.0, 0.0));\n    float n101 = hash(i + vec3(1.0, 0.0, 1.0));\n    float n110 = hash(i + vec3(1.0, 1.0, 0.0));\n    float n111 = hash(i + vec3(1.0, 1.0, 1.0));\n\n    return mix(\n        mix(mix(n000, n100, f.x), mix(n010, n110, f.x), f.y),\n        mix(mix(n001, n101, f.x), mix(n011, n111, f.x), f.y),\n        f.z);\n}\n\nfloat fnoise(vec3 p, float t) {\n    p.xy += 3.0 * sin(t * 0.002 + p.z * 0.001);\n    p.zx += 3.0 * cos(t * 0.002 + p.y * 0.001);\n\n    float a = t * 0.002;\n    float ca = cos(a), sa = sin(a);\n    mat3 rotY = mat3(ca,0,-sa, 0,1,0, sa,0,ca);\n    p = rotY * p;\n\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i &lt; 6; i++) {\n        f += amp * noise3(p);\n        p *= 2.02 + 0.02 * sin(float(i) + t * 0.005);\n        amp *= 0.5;\n    }\n    return f;\n}\n\nfloat cloud(vec3 p, float t) {\n    float h = p.y;\n    float heightFade = smoothstep(5000.0, 8000.0, h)\n                     * (1.0 - smoothstep(8000.0, 10000.0, h));\n    float d = fnoise(p * 0.0003, t);\n    d = smoothstep(0.4, 0.65, d);\n    return d * heightFade;\n}\n\nvec3 sampleCloudColor(vec3 rayOrigin, vec3 rayDir, float t) {\n    vec3 col = vec3(0.0);\n    for (int i = 0; i &lt; 24; ++i) {\n        float d = float(i) * 800.0;\n        vec3 p = rayOrigin + rayDir * d;\n        if (p.y &lt; 5000.0 || p.y &gt; 10000.0) continue;\n        float dens = cloud(p, t);\n        col += vec3(dens);\n    }\n    return col * 0.06;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float AR = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= AR;\n\n    vec3 rayOrigin = vec3(0.0, 100.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv, -1.5));\n\n    vec3 cloudColor = sampleCloudColor(rayOrigin, rayDir, iTime);\n    vec3 color = cloudColor;\n\n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}\n</code></pre>"},{"location":"shaders/scenes/SunAndHalo/","title":"\ud83e\udde9 Sun and Halo Shader","text":"<ul> <li>Category: Scene / Atmospheric Effect  </li> <li>Shader Type: Full-screen background environment  </li> <li>Input Requirements: <code>fragCoord</code>, <code>iMouse</code>, <code>iResolution</code> </li> <li>Output: HDR-tone-mapped sun disk and scattering halo over sky gradient</li> </ul>"},{"location":"shaders/scenes/SunAndHalo/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>Renders a realistic sun with halo using physically inspired falloff, Mie scattering, and zenith-based atmospheric absorption.</li> <li>The sun position is interactive via mouse input, with fallback defaults.</li> <li>Suitable for skyboxes, planet environments, or cinematic backgrounds.</li> <li>Implements Reinhard tone mapping for HDR-to-LDR conversion.</li> </ul>"},{"location":"shaders/scenes/SunAndHalo/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/SunAndHalo/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader models the optical appearance of the sun with a glowing halo, combined with sky absorption effects. It is built around:</p> <ul> <li>A sun disk intensity model using <code>smoothstep</code> and distance</li> <li>Mie scattering halo with elevation-sensitive sharpness</li> <li>Zenith-dependent atmospheric absorption</li> <li>HDR tone mapping to compress values for final output</li> <li>Gradient-based sky background from dark blue at top to light at horizon</li> </ul> <p>The result is a scene-level rendering of the sun and sky that reacts to camera view and sun height.</p>"},{"location":"shaders/scenes/SunAndHalo/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Type Example <code>fragCoord</code> Fragment/pixel coordinate <code>vec2</code> Built-in <code>iMouse</code> Controls sun position (xy normalized) <code>vec4</code> uniform <code>iResolution</code> Viewport resolution <code>vec3</code> uniform <code>fov</code> Field of view (70\u00b0 in radians) <code>float</code> tan(70\u00b0) \u2248 1.4"},{"location":"shaders/scenes/SunAndHalo/#full-shader-code","title":"\ud83d\udcbb Full Shader Code","text":"<pre><code>// ==========================================\n// Shader: Sun and Halo Shader\n// Category: Scene / Atmospheric Effect\n// Description: Computes a realistic sun disk with halo and atmospheric absorption.\n// Screenshot: screenshots/scenes/SunAndHalo.png\n// ==========================================\n\nconst float PI = 3.14159265358979323846;\nconst float density = 0.5;\nconst float zenithOffset = 0.48;\nconst vec3 skyColor = vec3(0.37, 0.55, 1.0); // base sky color\n\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.0035), 0.75)\n#define fov tan(radians(70.0))\n\nfloat getSunPoint(vec2 p, vec2 lp) {\n    return smoothstep(0.04 * (fov / 2.0), 0.026 * (fov / 2.0), distance(p, lp)) * 50.0;\n}\n\nfloat getMie(vec2 p, vec2 lp) {\n    float sharpness = lp.y &lt; 0.5 ? (lp.y + 0.5) * pow(0.05, 20.0) : 0.05;\n    float disk = clamp(1.0 - pow(distance(p, lp), sharpness), 0.0, 1.0);\n    return disk * disk * (3.0 - 2.0 * disk) * 0.25 * PI;\n}\n\nvec3 getSkyAbsorption(vec3 x, float y) {\n    vec3 absorption = x * y;\n    absorption = pow(absorption, 1.0 - (y + absorption) * 0.5) / x / y;\n    return absorption;\n}\n\nvec3 jodieReinhardTonemap(vec3 c) {\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 getAtmosphericSun(vec2 fragUV, vec2 lightUV) {\n    float zenithFactor = zenithDensity(fragUV.y);\n    float sunHeight = clamp(length(max(lightUV.y + 0.1 - zenithOffset, 0.0)), 0.0, 1.0);\n\n    vec3 skyAbsorption = getSkyAbsorption(skyColor, zenithFactor);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lightUV.y + 0.1));\n\n    vec3 sunCore = getSunPoint(fragUV, lightUV) * skyAbsorption;\n    vec3 mieHalo = getMie(fragUV, lightUV) * sunAbsorption;\n\n    vec3 totalSky = sunCore + mieHalo;\n    totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\n    return jodieReinhardTonemap(totalSky);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float AR = iResolution.x / iResolution.y;\n    vec2 uvMouse = iMouse.xy / iResolution.xy;\n    uvMouse.x *= AR;\n    if (uvMouse.y == 0.0) uvMouse.y = 0.7 - (0.05 * fov);\n    if (uvMouse.x == 0.0) uvMouse.x = 1.0 - (0.05 * fov);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= AR;\n\n    vec3 color = vec3(0.2, 0.3, 0.5) * (1.0 - uv.y);\n    vec3 sunColor = getAtmosphericSun(uv, uvMouse);\n    color += sunColor;\n\n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}\n</code></pre>"},{"location":"shaders/scenes/boat_flag/","title":"\ud83e\udde9Boat and Flag Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: raymarch (SDF-based geometry)</li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iMouse</code>, <code>iResolution</code></li> <li>Output: <code>fragColor</code> RGBA color</li> </ul>"},{"location":"shaders/scenes/boat_flag/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/boat_flag/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader renders a signed distance field (SDF) scene featuring a boat hull and flagpole using sphere tracing. The model is visualized with orbit camera controls and shaded using pseudo diffuse and rim lighting techniques.</p> Stage Function / Code Purpose Geometry SDF <code>evaluateShip()</code> Defines boat hull, pole, and flag via SDF primitives. Raymarcher <code>raymarch()</code> Traces view rays through SDF until a hit or max distance. Normal Estimate <code>estimateNormal()</code> Approximates surface normals using central differences. Shading Model inline in <code>mainImage()</code> Combines base color, pseudo diffuse, and rim lighting for stylized shading. <p>Result:  a clear SDF-based preview of a stylized boat with orbit camera control and emphasis on silhouette contours.</p>"},{"location":"shaders/scenes/boat_flag/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Range / Unit Default <code>iTime</code> Global time seconds \u2014 <code>iMouse.xy</code> Orbit camera yaw / pitch pixels\u00a0(0\u202f\u2013\u202f<code>iResolution</code>) (0,\u202f0) <code>iResolution</code> Viewport resolution pixels \u2014 <code>CAMERA_DIST</code> Camera radius from center float 7.0 <code>MODEL_ROT</code> Axis remapping for boat orientation mat3 rotates boat to +Z <p>To use this shader outside ShaderToy (e.g., in Unity or  Godot):</p> <ul> <li><code>iTime</code> \u2192 <code>_Time.y</code> in Unity / <code>TIME</code> in Godot</li> <li><code>iResolution</code> \u2192 screen resolution vector</li> <li><code>iChannel1</code> \u2192 supply your own blue-noise texture</li> <li><code>iMouse</code> \u2192 remap to your camera controller input</li> </ul> <p>Make sure to adjust the entry point from <code>mainImage(out vec4 fragColor, in vec2 fragCoord)</code> to match your rendering pipeline.</p>"},{"location":"shaders/scenes/boat_flag/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":""},{"location":"shaders/scenes/boat_flag/#1-boat-and-flag-sdf-construction","title":"1. Boat and Flag SDF Construction","text":"<p>Defines boat hull, waving flag, and pole using SDF operations.</p> <pre><code>vec2 evaluateShip(vec3 worldPos, float time) {\n    vec2 result = vec2(1e5, -1.0);\n\n    mat3 modelRot = mat3(\n        vec3(1,0,0),\n        vec3(0,0,1),\n        vec3(0,1,0)\n    );\n    vec3 localPos = worldPos * modelRot;\n\n    float cose = cos(localPos.y * 0.5);\n    float hull = sdfEllipsoidClamped(localPos, 0.48, vec3(cose * 0.75, 2.9, cose));\n    hull = abs(hull) - 0.15;\n    hull = max(hull, localPos.z - 1.0 + cos(localPos.y * 0.4) * 0.5);\n    hull = min(hull, max(length(localPos.xy - vec2(0, 2.6)) - 0.2, abs(localPos.z - 2.3) - 2.7));\n    hull *= 0.8;\n    result = vec2(hull, 3.0);\n\n    vec3 flagPos = localPos;\n    flagPos.y = abs(flagPos.y) - 3.2;\n    float flag = length(flagPos) - 0.2;\n    if (flag &lt; result.x) result = vec2(flag, 6.0);\n\n    vec3 polePos = localPos - vec3(\n        sin(localPos.z * localPos.y * 0.4 + time * 4.0) * max(0.0, localPos.y - 2.5) * 0.2,\n        3.6,\n        3.8\n    );\n    float pole = sdfBox(polePos, vec3(0.02, 1.0, 1.0)) * 0.7;\n    if (pole &lt; result.x) result = vec2(pole, 6.0);\n\n    return result;\n}\n</code></pre>"},{"location":"shaders/scenes/boat_flag/#2-raymarch-and-normal-estimation","title":"2. Raymarch and Normal Estimation","text":"<pre><code>vec2 raymarch(vec3 rayOrigin, vec3 rayDir) {\n    float totalDist = 0.0;\n    vec2 result = vec2(-1.0);\n    for (int i = 0; i &lt; MAX_STEPS; i++) {\n        vec3 currentPos = rayOrigin + rayDir * totalDist;\n        vec2 dist = sceneMap(currentPos);\n        if (dist.x &lt; SURF_DIST) {\n            result = vec2(totalDist, dist.y);\n            break;\n        }\n        if (totalDist &gt; MAX_DIST) break;\n        totalDist += dist.x;\n    }\n    return result;\n}\n</code></pre>"},{"location":"shaders/scenes/boat_flag/#full-code","title":"Full Code","text":"\ud83d\udcc4 BoatAndFlag.glsl <pre><code>// ---------- Raymarching Constants ----------\n#define MAX_STEPS 128\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n// ---------- SDF Primitives ----------\nfloat sdfBox(vec3 p, vec3 r) {\n    p = abs(p) - r;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sdfEllipsoidClamped(vec3 p, float radius, vec3 bounds) {\n    vec3 q = p - clamp(p, -bounds, bounds);\n    return length(q) - radius;\n}\n\n// ---------- Boat + Flag SDF Model ----------\nvec2 evaluateShip(vec3 worldPos, float time) {\n    vec2 result = vec2(1e5, -1.0);\n\n    mat3 modelRot = mat3(\n        vec3(1,0,0),\n        vec3(0,0,1),\n        vec3(0,1,0)\n    );\n    vec3 localPos = worldPos * modelRot;\n\n    float cose = cos(localPos.y * 0.5);\n    float hull = sdfEllipsoidClamped(localPos, 0.48, vec3(cose * 0.75, 2.9, cose));\n    hull = abs(hull) - 0.15;\n    hull = max(hull, localPos.z - 1.0 + cos(localPos.y * 0.4) * 0.5);\n    hull = min(hull, max(length(localPos.xy - vec2(0, 2.6)) - 0.2, abs(localPos.z - 2.3) - 2.7));\n    hull *= 0.8;\n    result = vec2(hull, 3.0);\n\n    vec3 flagPos = localPos;\n    flagPos.y = abs(flagPos.y) - 3.2;\n    float flag = length(flagPos) - 0.2;\n    if (flag &lt; result.x) result = vec2(flag, 6.0);\n\n    vec3 polePos = localPos - vec3(\n        sin(localPos.z * localPos.y * 0.4 + time * 4.0) * max(0.0, localPos.y - 2.5) * 0.2,\n        3.6,\n        3.8\n    );\n    float pole = sdfBox(polePos, vec3(0.02, 1.0, 1.0)) * 0.7;\n    if (pole &lt; result.x) result = vec2(pole, 6.0);\n\n    return result;\n}\n\n// ---------- Scene Distance Wrapper ----------\nvec2 sceneMap(vec3 p) {\n    return evaluateShip(p, iTime);\n}\n\n// ---------- Surface Normal Approximation ----------\nvec3 estimateNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneMap(p + e.xyy).x - sceneMap(p - e.xyy).x,\n        sceneMap(p + e.yxy).x - sceneMap(p - e.yxy).x,\n        sceneMap(p + e.yyx).x - sceneMap(p - e.yyx).x\n    ));\n}\n\n// ---------- Sphere Tracing Core ----------\nvec2 raymarch(vec3 rayOrigin, vec3 rayDir) {\n    float totalDist = 0.0;\n    vec2 result = vec2(-1.0);\n    for (int i = 0; i &lt; MAX_STEPS; i++) {\n        vec3 currentPos = rayOrigin + rayDir * totalDist;\n        vec2 dist = sceneMap(currentPos);\n        if (dist.x &lt; SURF_DIST) {\n            result = vec2(totalDist, dist.y);\n            break;\n        }\n        if (totalDist &gt; MAX_DIST) break;\n        totalDist += dist.x;\n    }\n    return result;\n}\n\n// ---------- Main Shader Entry ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Mouse-based orbit camera\n    vec2 m = (iMouse.xy == vec2(0.0)) ? vec2(0.25 * iResolution.x, 0.5 * iResolution.y) : iMouse.xy;\n    vec2 mouseNorm = m / iResolution.xy;\n\n    float yaw = 6.2831 * (mouseNorm.x - 0.5);\n    float pitch = 3.1416 * 0.4 * (mouseNorm.y - 0.5);\n\n    vec3 target = vec3(0.0, 1.5, 0.0);\n    float cameraDist = 7.0;\n    vec3 camPos = target + cameraDist * vec3(\n        cos(pitch) * sin(yaw),\n        sin(pitch),\n        cos(pitch) * cos(yaw)\n    );\n\n    vec3 viewDir = normalize(target - camPos);\n    vec3 right = normalize(cross(vec3(0, 1, 0), viewDir));\n    vec3 up = cross(viewDir, right);\n    mat3 cameraBasis = mat3(right, up, viewDir);\n    vec3 rayDir = cameraBasis * normalize(vec3(uv, 1.0));\n\n    // Light gray background\n    vec3 color = vec3(0.85);\n\n    // Shading logic\n    vec2 res = raymarch(camPos, rayDir);\n    if (res.x &gt; 0.0) {\n        vec3 hitPos = camPos + rayDir * res.x;\n        vec3 normal = estimateNormal(hitPos);\n\n        float rim = pow(1.0 - dot(normal, -rayDir), 4.0);\n        float pseudoDiffuse = 0.2 + 0.3 * dot(normal, vec3(0, 1, 0));\n\n        vec3 baseColor = vec3(0.3);\n        if (res.y == 6.0) baseColor = vec3(0.9, 0.2, 0.2); // flag\n        if (res.y == 3.0) baseColor = vec3(0.4, 0.3, 0.2); // boat\n\n        color = baseColor * pseudoDiffuse + vec3(1.0) * rim * 0.8;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/scenes/cloud_ground/","title":"\ud83e\udde9 Cloud and Ground Integration Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Volumetric cloud rendering integrated with surface lighting</li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iMouse</code>, <code>iResolution</code>, <code>iChannel0</code> (noise texture)</li> <li>Output: <code>fragColor</code> RGBA color (volumetric cloud with light occlusion and dynamic terrain shading)</li> </ul>"},{"location":"shaders/scenes/cloud_ground/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/cloud_ground/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This shader demonstrates modular integration of cloud volume rendering and terrain shading using prebuilt components. It blends:</p> <ul> <li>FBM-based volumetric clouds</li> <li>Phong-shaded terrain with cloud shadow</li> <li>Sky gradient background</li> </ul> <p>and uses reusable modules from the project to handle:</p> <ul> <li>Noise</li> <li>Cloud volume</li> <li>Volume lighting context</li> <li>Volume lighting functions</li> <li>Volume material system</li> <li>Material systems</li> <li>Lighting context</li> <li>Lighting functions</li> </ul>"},{"location":"shaders/scenes/cloud_ground/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":""},{"location":"shaders/scenes/cloud_ground/#cloud-configuration","title":"\u2601\ufe0f Cloud Configuration","text":"Name Value Description <code>planetRadius</code> <code>6360.0</code> Ground Y-position, defines sea/ground base <code>atmosphereTop</code> <code>6420.0</code> Scene top Y-position <code>mieScaleHeight</code> <code>1.2</code> Vertical decay factor for Mie scattering <code>rayleighScaleHeight</code> <code>8.0</code> Vertical decay factor for Rayleigh scattering <code>cloudBase</code> <code>2.0</code> Height above planet where cloud begins <code>cloudThickness</code> <code>8.0</code> Total vertical thickness of the cloud volume <code>CLOUD_BASE</code> <code>planetRadius + cloudBase</code> World height for cloud bottom <code>CLOUD_TOP</code> <code>planetRadius + cloudBase + cloudThickness</code> World height for cloud top <code>stepCount</code> <code>96.0</code> Total steps for volume integration <code>PI</code> <code>3.14159265359</code> Mathematical constant used in phase calculations and normalization"},{"location":"shaders/scenes/cloud_ground/#lighting-configuration","title":"\ud83d\udca1 Lighting Configuration","text":"Name Value Description <code>lightDir</code> <code>vec3(0.3, 0.5, 0.2)</code> Direction of the light <code>lightColor</code> <code>vec3(2.0, 2.2, 2.8)</code> Bright bluish daylight <code>ambient</code> Same as <code>lightColor</code> Used for both cloud and terrain"},{"location":"shaders/scenes/cloud_ground/#scene-bounds-camera","title":"\ud83c\udf0d Scene Bounds &amp; Camera","text":"Name Value Description <code>camPos</code> <code>vec3(0.0, CLOUD_BASE - 0.8, 0.0)</code> Below the cloud layer initially <code>boxMin</code> <code>vec3(-10.0, 0.0, -10.0)</code> Minimum bounds for any potential SDF geometry in the scene <code>boxMax</code> <code>vec3(10.0, 5.0, 10.0)</code> Maximum bounds for potential SDF geometry in the scene"},{"location":"shaders/scenes/cloud_ground/#shader-code-includes","title":"\ud83e\uddf1 Shader Code &amp; Includes","text":"<p>This shader imports or assumes the following headers:</p> <pre><code>#include \"noise/simplex_noise.glsl\"\n#include \"material/volume_material/vol_mat_params.glsl\"\n#include \"material/volume_material/vol_mat_presets.glsl\"\n#include \"lighting/volume_lighting/vol_lit_context.glsl\"\n#include \"lighting/volume_lighting/phase.glsl\"\n#include \"lighting/volume_lighting/vol_lit.glsl\"\n#include \"lighting/volume_lighting/vol_integration.glsl\"\n#include \"lighting/volume_lighting/vol_occlusion.glsl\"\n\n#include \"material/material/material_params.glsl\"\n#include \"material/material/material_presets.glsl\"\n#include \"lighting/surface_lighting/lighting_context.glsl\"\n#include \"lighting/surface_lighting/phong.glsl\"\n</code></pre>"},{"location":"shaders/scenes/cloud_ground/#main-entry","title":"Main Entry","text":"<pre><code>void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // === Camera Position ===\n    vec3 camPos = vec3(0.0, CLOUD_BASE -0.8, 0.0);\n\n    // === Camera Orientation from Mouse ===\n    vec2 m = (iMouse.xy == vec2(0.0)) ? vec2(0.5, 0.1) : iMouse.xy / iResolution.xy;\n    float yaw = 6.2831 * (m.x - 0.5);\n    float pitch = 1.5 * 3.1416 * (m.y - 0.5);\n\n    float cosPitch = cos(pitch);\n    vec3 forward = vec3(\n        cosPitch * sin(yaw),\n        sin(pitch),\n        cosPitch * cos(yaw)\n    );\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    mat3 camMat = mat3(right, up, forward);\n\n    // === Ray Setup ===\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDir = normalize(camMat * vec3(uv, 1.5));\n\n    // === Light &amp; Ambient Settings ===\n    vec3 lightDir = normalize(vec3(0.3, 0.5, 0.2));\n    vec3 lightColor = vec3(2.0, 2.2, 2.8);\n    vec3 ambient = lightColor;\n\n    // === Sky Background ===\n    vec3 baseSky = mix(vec3(0.690, 0.878, 0.902), vec3(0.529, 0.808, 0.922), smoothstep(0.0, 0.5, rayDir.y));\n\n    // === Ground Intersection and Lighting ===\n    float groundHeight = planetRadius;\n    float tGround = (groundHeight - camPos.y) / rayDir.y;\n    bool hitGround = rayDir.y &lt; -0.01 &amp;&amp; tGround &gt; 0.0;\n\n    vec3 groundColor = vec3(0.08, 0.35, 0.05);\n    if (hitGround) {\n        vec3 hitPos = camPos + tGround * rayDir;\n        vec3 normal = vec3(0.0, 1.0, 0.0);\n         // === Cloud Occlusion ===\n        float occlusion = computeCloudOcclusion(hitPos + normal * 0.1, lightDir);\n\n        // === Apply Shading ===\n        LightingContext ctx = createLightingContext(hitPos, normal, -rayDir, lightDir, lightColor, ambient);\n        MaterialParams mat = makePlastic(groundColor);\n        vec3 litColor = applyPhongLighting(ctx, mat);\n\n        // === Mix with occlusion shadow ===\n        vec3 shadowColor = vec3(0.05, 0.12, 0.04);\n        groundColor = mix(litColor, shadowColor, occlusion);\n\n        // === Optional: Tone Map ===\n        groundColor = groundColor / (groundColor + vec3(2.3, 1.5, 2.3));\n    }\n\n    // === Cloud Volume Rendering ===\n    VolMaterialParams cloudMat = makeCloud(vec3(1.0));\n    vec4 cloudCol = integrateCloud(camPos, rayDir, 80.0, 96.0, lightDir, lightColor, ambient, cloudMat);\n\n    // === Final Color Blending ===\n    vec3 finalColor = vec3(0.0);\n\n    bool toGround = rayDir.y &lt; -0.01;\n    bool toSky = rayDir.y &gt; 0.01;\n    bool hasCloud = (rayDir.y &gt; 0.01 &amp;&amp; camPos.y &lt; CLOUD_BASE &amp;&amp; camPos.y + rayDir.y * 1e4 &gt; CLOUD_BASE) || \n                    (rayDir.y &lt; -0.01 &amp;&amp; camPos.y &gt; CLOUD_TOP  &amp;&amp; camPos.y + rayDir.y * 1e4 &lt; CLOUD_TOP)  ||\n                    (camPos.y &gt;= CLOUD_BASE &amp;&amp; camPos.y &lt;= CLOUD_TOP); \n\n    if (toGround &amp;&amp; !hasCloud) {\n        finalColor = groundColor;\n    }\n    else if (toGround &amp;&amp; hasCloud) {\n        finalColor = mix(groundColor, cloudCol.rgb, cloudCol.a);\n    }\n    else if (toSky &amp;&amp; hasCloud) {\n        finalColor = mix(baseSky, cloudCol.rgb, cloudCol.a);\n    }\n    else {\n        finalColor = baseSky; \n    }\n\n    fragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n}\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/scenes/cloud_volume/","title":"\ud83e\udde9 Grayscale Volumetric Cloud Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Full\u2011screen volumetric raymarch (simplex\u2011FBM density)</li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iMouse</code>, <code>iResolution</code>, <code>iChannel1</code>\u00a0(blue\u2011noise)</li> <li>Output: <code>fragColor</code> RGBA color (grayscale cloud density in\u00a0RGB, alpha = integrated opacity)</li> </ul>"},{"location":"shaders/scenes/cloud_volume/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/cloud_volume/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>The shader renders a height\u2011bounded 3\u2011D cloud slab. A 5\u2011octave simplex\u2011FBM density field is sampled along view rays; opacity is accumulated with blue\u2011noise\u2011jittered step sizes to avoid banding. No lighting is applied and output is pure grayscale density (RGB\u202f=\u202f\u03b1).</p> Stage Function / Code Purpose Noise Source <code>snoise()</code> 3D simplex noise (Ashima Arts) is used as the base wave for FBM Density Field <code>map(p,\u202foct)</code> Generates up to 5 layers (octaves) of FBM noise, then applies a smooth vertical mask between CLOUD_BASE and CLOUD_TOP. Camera Rays inline in <code>mainImage()</code> Creates an orbit camera from mouse yaw/pitch; produces origin\u202f<code>ro</code> &amp; dir\u202f<code>rd</code> Blue\u2011Noise Jitter <code>texelFetch(iChannel1, px &amp; 1023, 0).x</code> Uses a 1024^2 blue\u2011noise texture to random\u2011offset the first march step, breaking regular sampling patterns Integrator <code>integrateDensity()</code> Marches up to 190 steps, accumulates front\u2011to\u2011back \u03b1 until exit or opacity\u202f\u2265\u202f1 <p>Result: smoothly drifting clouds with soft edges.</p>"},{"location":"shaders/scenes/cloud_volume/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Range / Unit Default <code>iTime</code> Global time seconds \u2014 <code>iMouse.xy</code> Orbit camera yaw / pitch pixels\u00a0(0\u202f\u2013\u202f<code>iResolution</code>) (0,\u202f0) <code>iResolution</code> Viewport resolution pixels \u2014 <code>iChannel1</code> Blue\u2011noise texture for step dithering <code>sampler2D</code> <code>vec4(0.0)</code> if unbound <code>CAM_POS</code> Camera start position <code>vec3</code> (0,\u202f\u20111,\u202f\u20116) <code>CLOUD_BASE / CLOUD_TOP</code> Cloud bounds float \u20113.0 / 0.6 <p>To use this shader outside ShaderToy (e.g., in Unity or  Godot):</p> <ul> <li><code>iTime</code> \u2192 <code>_Time.y</code> in Unity / <code>TIME</code> in Godot</li> <li><code>iResolution</code> \u2192 screen resolution vector</li> <li><code>iChannel1</code> \u2192 supply your own blue-noise texture</li> <li><code>iMouse</code> \u2192 remap to your camera controller input</li> </ul> <p>Make sure to adjust the entry point from <code>mainImage(out vec4 fragColor, in vec2 fragCoord)</code> to match your rendering pipeline.</p>"},{"location":"shaders/scenes/cloud_volume/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":""},{"location":"shaders/scenes/cloud_volume/#1-simplex-noise-generator","title":"1. Simplex Noise Generator","text":"<p>The <code>snoise()</code> function provides a 3D simplex noise implementation based on Ashima Arts\u2019 classic GLSL version. It uses skewed coordinate space and lattice permutations to evaluate smooth noise with low directional artifacts, ideal for volumetric fields. Internally, it computes contributions from the four nearest simplex corners using gradient vectors, attenuation masks, and normalization factors. This function serves as the foundational noise source for the FBM density field in the cloud shader.</p> <pre><code>// ---------- Simplex Noise Implementation ----------\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g, l.zxy);\n    vec3 i2 = max(g, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = 1.79284291400159 - 0.85373472095314 *\n        vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(\n        dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)\n    ), 0.0);\n    m *= m;\n\n    return 42.0 * dot(m * m, vec4(\n        dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\nfloat noise(vec3 x) {\n    return snoise(x);\n}\n</code></pre>"},{"location":"shaders/scenes/cloud_volume/#2-density-field-function","title":"2. Density\u202fField\u00a0Function","text":"<p>The <code>map()</code> function computes the cloud density at a point in 3D space. It first moves the point over time to create motion, then adds together up to 5 layers of simplex noise (FBM), each with higher frequency and lower strength. A second noise signal (<code>g</code>) helps make the shape less uniform. The result is multiplied by a smooth height-based mask between <code>CLOUD_BASE</code> and <code>CLOUD_TOP</code>, so the cloud fades softly at the top and bottom. At the end, it adjusts the density value with a scale and offset. This function returns a value that tells how \u201cfull\u201d the cloud is at that point, and is used during raymarching to build the final image.</p> <pre><code>// ---------- Density Function ----------\nfloat map(vec3 p, int oct) {\n    vec3 q = p - vec3(0.0, 0.1, 1.0) * iTime;\n\n    float g = 0.5 + 0.5 * noise(q * 0.3);\n    float f = 0.5 * noise(q); q *= 2.02;\n    if (oct &gt;= 2) f += 0.25   * noise(q); q *= 2.23;\n    if (oct &gt;= 3) f += 0.125  * noise(q); q *= 2.41;\n    if (oct &gt;= 4) f += 0.0625 * noise(q); q *= 2.62;\n    if (oct &gt;= 5) f += 0.03125 * noise(q);\n\n    float h = clamp((p.y - CLOUD_BASE) / (CLOUD_TOP - CLOUD_BASE), 0.0, 1.0);\n    float heightFalloff = smoothstep(0.0, 0.5, h) * (1.0 - smoothstep(0.5, 1.0, h));\n    f = mix(f * 0.1 - 0.5, f, g * g);\n    return (1.6 * f - 0.6 - p.y) * heightFalloff;\n}\n</code></pre>"},{"location":"shaders/scenes/cloud_volume/#3-raymarch-integrator","title":"3. Ray\u2011march Integrator","text":"<p>The <code>integrateDensity()</code> function performs volumetric raymarching through the cloud layer. It first computes the entry and exit points based on the camera ray and cloud height bounds. A small offset using blue-noise from <code>iChannel1</code> is added to the starting distance to reduce banding. Then, up to 190 steps are taken along the ray, adaptively sampling the density field via <code>map()</code>. When density is detected, alpha is computed and accumulated using front-to-back compositing. The function exits early if opacity becomes saturated, returning a grayscale color where RGB equals the accumulated alpha. <pre><code>// ---------- Volumetric Raymarch ----------\nvec4 integrateDensity(vec3 ro, vec3 rd, ivec2 px) {\n    float tb = (CLOUD_BASE - ro.y) / rd.y;\n    float tt = (CLOUD_TOP  - ro.y) / rd.y;\n\n    float tmin, tmax;\n    if (ro.y &gt; CLOUD_TOP) {\n        if (tt &lt; 0.0) return vec4(0.0);\n        tmin = tt; tmax = tb;\n    } else if (ro.y &lt; CLOUD_BASE) {\n        if (tb &lt; 0.0) return vec4(0.0);\n        tmin = tb; tmax = tt;\n    } else {\n        tmin = 0.0;\n        tmax = 60.0;\n        if (tt &gt; 0.0) tmax = min(tmax, tt);\n        if (tb &gt; 0.0) tmax = min(tmax, tb);\n    }\n\n    float t = tmin + 0.1 * texelFetch(iChannel1, px &amp; 1023, 0).x;\n    vec4 sum = vec4(0.0);\n    const int oct = 5;\n\n    for (int i = 0; i &lt; 190; i++) {\n        float dt = max(0.05, 0.02 * t);\n        vec3 pos = ro + t * rd;\n        float den = map(pos, oct);\n\n        if (den &gt; 0.01) {\n            float alpha = clamp(den, 0.0, 1.0);\n            vec4 col = vec4(vec3(alpha), alpha);\n            col.a = min(col.a * 8.0 * dt, 1.0);\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n\n        t += dt;\n        if (t &gt; tmax || sum.a &gt; 0.99) break;\n    }\n\n    return clamp(sum, 0.0, 1.0);\n}\n</code></pre></p>"},{"location":"shaders/scenes/cloud_volume/#full-code","title":"Full Code","text":"\ud83d\udcc4 CloudVolume.glsl <p>// ---------- Configuration Constants ----------</p> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/scenes/cloud_volume/#define-cam_pos-vec300-10-60","title":"define CAM_POS vec3(0.0, -1.0, -6.0)","text":""},{"location":"shaders/scenes/cloud_volume/#define-cloud_base-30","title":"define CLOUD_BASE -3.0","text":""},{"location":"shaders/scenes/cloud_volume/#define-cloud_top-06","title":"define CLOUD_TOP  0.6","text":"<p>const float PI = 3.14159265;</p> <p>// ---------- Simplex Noise Implementation ---------- vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }</p> <p>vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }</p> <p>float snoise(vec3 v) {     const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);     const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);</p> <pre><code>vec3 i = floor(v + dot(v, C.yyy));\nvec3 x0 = v - i + dot(i, C.xxx);\n\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min(g, l.zxy);\nvec3 i2 = max(g, l.zxy);\n\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy;\nvec3 x3 = x0 - D.yyy;\n\ni = mod289(i);\nvec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\nfloat n_ = 0.142857142857;\nvec3 ns = n_ * D.wyz - D.xzx;\n\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_);\n\nvec4 x = x_ * ns.x + ns.yyyy;\nvec4 y = y_ * ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\n\nvec4 b0 = vec4(x.xy, y.xy);\nvec4 b1 = vec4(x.zw, y.zw);\nvec4 s0 = floor(b0) * 2.0 + 1.0;\nvec4 s1 = floor(b1) * 2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\n\nvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\nvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\nvec3 p0 = vec3(a0.xy, h.x);\nvec3 p1 = vec3(a0.zw, h.y);\nvec3 p2 = vec3(a1.xy, h.z);\nvec3 p3 = vec3(a1.zw, h.w);\n\nvec4 norm = 1.79284291400159 - 0.85373472095314 *\n    vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\n\nvec4 m = max(0.6 - vec4(\n    dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)\n), 0.0);\nm *= m;\n\nreturn 42.0 * dot(m * m, vec4(\n    dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n</code></pre> <p>}</p> <p>float noise(vec3 x) {     return snoise(x); }</p> <p>// ---------- Density Function ---------- float map(vec3 p, int oct) {     vec3 q = p - vec3(0.0, 0.1, 1.0) * iTime;</p> <pre><code>float g = 0.5 + 0.5 * noise(q * 0.3);\nfloat f = 0.5 * noise(q); q *= 2.02;\nif (oct &gt;= 2) f += 0.25   * noise(q); q *= 2.23;\nif (oct &gt;= 3) f += 0.125  * noise(q); q *= 2.41;\nif (oct &gt;= 4) f += 0.0625 * noise(q); q *= 2.62;\nif (oct &gt;= 5) f += 0.03125 * noise(q);\n\nfloat h = clamp((p.y - CLOUD_BASE) / (CLOUD_TOP - CLOUD_BASE), 0.0, 1.0);\nfloat heightFalloff = smoothstep(0.0, 0.5, h) * (1.0 - smoothstep(0.5, 1.0, h));\nf = mix(f * 0.1 - 0.5, f, g * g);\nreturn (1.6 * f - 0.6 - p.y) * heightFalloff;\n</code></pre> <p>}</p> <p>// ---------- Camera Construction ---------- mat3 setCamera(vec3 ro, vec3 ta, float cr) {     vec3 cw = normalize(ta - ro);     vec3 cp = vec3(sin(cr), cos(cr), 0.0);     vec3 cu = normalize(cross(cw, cp));     vec3 cv = normalize(cross(cu, cw));     return mat3(cu, cv, cw); }</p> <p>// ---------- Volumetric Raymarch ---------- vec4 integrateDensity(vec3 ro, vec3 rd, ivec2 px) {     float tb = (CLOUD_BASE - ro.y) / rd.y;     float tt = (CLOUD_TOP  - ro.y) / rd.y;</p> <pre><code>float tmin, tmax;\nif (ro.y &gt; CLOUD_TOP) {\n    if (tt &lt; 0.0) return vec4(0.0);\n    tmin = tt; tmax = tb;\n} else if (ro.y &lt; CLOUD_BASE) {\n    if (tb &lt; 0.0) return vec4(0.0);\n    tmin = tb; tmax = tt;\n} else {\n    tmin = 0.0;\n    tmax = 60.0;\n    if (tt &gt; 0.0) tmax = min(tmax, tt);\n    if (tb &gt; 0.0) tmax = min(tmax, tb);\n}\n\nfloat t = tmin + 0.1 * texelFetch(iChannel1, px &amp; 1023, 0).x;\nvec4 sum = vec4(0.0);\nconst int oct = 5;\n\nfor (int i = 0; i &lt; 190; i++) {\n    float dt = max(0.05, 0.02 * t);\n    vec3 pos = ro + t * rd;\n    float den = map(pos, oct);\n\n    if (den &gt; 0.01) {\n        float alpha = clamp(den, 0.0, 1.0);\n        vec4 col = vec4(vec3(alpha), alpha);\n        col.a = min(col.a * 8.0 * dt, 1.0);\n        col.rgb *= col.a;\n        sum += col * (1.0 - sum.a);\n    }\n\n    t += dt;\n    if (t &gt; tmax || sum.a &gt; 0.99) break;\n}\n\nreturn clamp(sum, 0.0, 1.0);\n</code></pre> <p>}</p> <p>// ---------- Main Shader Entry ---------- void mainImage(out vec4 fragColor, in vec2 fragCoord) {     vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;     vec2 m = (iMouse.xy == vec2(0.0)) ? vec2(0.5) : iMouse.xy / iResolution.xy;</p> <pre><code>float yaw   = 2.0 * PI * (m.x - 0.5);\nfloat pitch = 1.5 * PI * (m.y - 0.5);\n\nfloat cosPitch = cos(pitch);\nvec3 forward = vec3(cosPitch * sin(yaw), sin(pitch), cosPitch * cos(yaw));\nvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\nvec3 up = normalize(cross(right, forward));\n\nvec3 ro = CAM_POS;\nvec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n\nfragColor = integrateDensity(ro, rd, ivec2(fragCoord - 0.5));\n</code></pre> <p>} ```</p>"},{"location":"shaders/scenes/cloud_water/","title":"\ud83e\udde9 Cloud and Water Integration Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: </li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iMouse</code>, <code>iResolution</code>, <code>iChannel0\u00a0(blue\u2011noise)</code></li> <li>Output: </li> </ul>"},{"location":"shaders/scenes/dolphin/","title":"Dolphin","text":"Dolphin Shader by Saeed Shamseldin"},{"location":"shaders/scenes/dolphin/#overview","title":"Overview","text":"<p>This GLSL shader creates an animated 3D dolphin model using signed distance fields (SDFs) and procedural animation techniques. The shader supports multiple dolphin instances with independent animations and movements.</p>"},{"location":"shaders/scenes/dolphin/#key-features","title":"Key Features","text":"<ul> <li> <p>Procedurally animated dolphin with smooth swimming motion</p> </li> <li> <p>Multiple dolphin instances (configurable count)</p> </li> <li> <p>Signed distance field rendering for smooth surfaces</p> </li> <li> <p>Detailed body shape with fins and tail</p> </li> <li> <p>Time-based animations for natural movement</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#constants","title":"Constants","text":"<ul> <li> <p>DOLPHIN_COUNT: Number of dolphin instances</p> </li> <li> <p>NO_OF_SEGMENTS: Number of spine segments for dolphin body</p> </li> <li> <p>F_NO_OF_SEGMENTS: Floating point version of segment count</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#dolphin-struct","title":"Dolphin Struct","text":"<pre><code>struct Dolphin {\n    vec3 position;      // Base position in world space\n    float timeOffset;   // Animation phase offset\n    float speed;        // Movement speed\n    vec3 direction;     // Movement direction\n};\n</code></pre>"},{"location":"shaders/scenes/dolphin/#core-functions","title":"Core Functions","text":""},{"location":"shaders/scenes/dolphin/#linesegmentdistancevec3-point-vec3-start-vec3-end","title":"<code>lineSegmentDistance(vec3 point, vec3 start, vec3 end)</code>","text":"<p>Calculates the shortest distance from a point to a line segment.</p>"},{"location":"shaders/scenes/dolphin/#parameters","title":"Parameters:","text":"<ul> <li> <p>point: 3D point to test</p> </li> <li> <p>start: Start of line segment</p> </li> <li> <p>end: End of line segment</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#returns","title":"Returns:","text":"<ul> <li><code>vec2</code>: x = squared distance, y = projection parameter along segment</li> </ul>"},{"location":"shaders/scenes/dolphin/#distancetoboxvec3-point-vec3-halfextent-float-radius","title":"<code>distanceToBox(vec3 point, vec3 halfExtent, float radius)</code>","text":"<p>Calculates distance to a rounded box.</p>"},{"location":"shaders/scenes/dolphin/#parameters_1","title":"Parameters:","text":"<ul> <li> <p>point: 3D point to test</p> </li> <li> <p>halfExtent: Half dimensions of the box</p> </li> <li> <p>radius: Corner rounding radius</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#smoothunionfloat-distance1-float-distance2-float-smoothfactor","title":"<code>smoothUnion(float distance1, float distance2, float smoothFactor)</code>","text":"<p>Smoothly blends two distance fields.</p>"},{"location":"shaders/scenes/dolphin/#dolphinanimationfloat-position-float-time-float-timeoffset","title":"<code>dolphinAnimation(float position, float time, float timeOffset)</code>","text":"<p>Generates animation parameters for dolphin segments.</p>"},{"location":"shaders/scenes/dolphin/#returns_1","title":"Returns:","text":"<ul> <li><code>vec2</code>: x = angle, y = thickness</li> </ul> <p><code>dolphinMovement(float time, float timeOffset, vec3 basePosition, float speed, vec3 direction)</code> Calculates dolphin's movement through space.</p> <p><code>dolphinDistance(vec3 point, Dolphin dolphin, float time)</code> Main distance function for the dolphin.</p>"},{"location":"shaders/scenes/dolphin/#returns_2","title":"Returns:","text":"<ul> <li><code>vec2</code>: x = signed distance, y = normalized position along body</li> </ul> <p><code>dolphinNormal(vec3 point, int dolphinIDX, float time)</code> Calculates surface normal at a point.</p> <p><code>getDolhpinColor(vec3 position, out vec3 color)</code> Determines dolphin's color at a given position.</p>"},{"location":"shaders/scenes/dolphin/#animation-system","title":"Animation System","text":"<p>The dolphin animation combines several wave functions to create natural swimming motion:</p> <ul> <li> <p>Body undulation using cosine waves</p> </li> <li> <p>Jumping behavior with vertical movement</p> </li> <li> <p>Independent fin and tail animations</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#technical-details","title":"Technical Details","text":"<ul> <li> <p>Uses signed distance fields for smooth surfaces</p> </li> <li> <p>Implements smooth blending between body parts</p> </li> <li> <p>Transforms points into local coordinate systems for fins and tail</p> </li> <li> <p>Uses segment-based approach for body construction</p> </li> </ul>"},{"location":"shaders/scenes/dolphin/#usage","title":"Usage","text":"<ol> <li> <p>Initialize dolphin instances in the <code>dolphins</code> array</p> </li> <li> <p>For each frame:</p> <ul> <li> <p>Calculate dolphin movement with <code>dolphinMovement</code></p> </li> <li> <p>Evaluate distance field with <code>dolphinDistance</code></p> </li> <li> <p>Calculate normals with <code>dolphinNormal</code> for lighting</p> </li> <li> <p>Apply coloring with <code>getDolhpinColor</code></p> </li> </ul> </li> </ol>"},{"location":"shaders/scenes/dolphin/#customization","title":"Customization","text":"<p>To modify the shader:</p> <ul> <li> <p>Adjust <code>DOLPHIN_COUNT</code> for more/less dolphins</p> </li> <li> <p>Change <code>NO_OF_SEGMENTS</code> for more/less body detail</p> </li> <li> <p>Modify animation parameters in <code>dolphinAnimation</code></p> </li> <li> <p>Adjust movement patterns in <code>dolphinMovement</code></p> </li> <li> <p>Change color calculations in <code>getDolhpinColor</code></p> </li> </ul> Show Code <pre><code>#define DOLPHIN_COUNT 2\n#define NO_OF_SEGMENTS 11\n#define F_NO_OF_SEGMENTS 11.0\n\n// dolphin global variables\nfloat jumping;\nfloat time;\nfloat segmentIdx = 0.0;\nvec3 ccd, ccp;\n\n// Dolphin struct to hold instance data\nstruct Dolphin {\n    vec3 position;\n    float timeOffset;\n    float speed;\n    vec3 direction;\n};\n\nDolphin dolphins[2];\n\n// This function gives you the shortest distance from a 2D point p to a finite line segment between a and b.\nvec2 lineSegmentDistance(vec3 point, vec3 start, vec3 end) {\n    // Calculate the vector from the start of the line segment to the point\n    vec3  startToPoint = point - start;\n    // Calculate the vector from the start of the line segment to the end\n    vec3  startToEnd = end - start;\n    // Calculate the projection of the point onto the line segment\n    float projection = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n    // Calculate the closest point on the line segment to the point\n    vec3 vecToClosestPoint = startToPoint - projection * startToEnd;\n    // Calculate the length of the vector to the closest point\n    return vec2(dot(vecToClosestPoint,vecToClosestPoint), projection);\n}\n\nfloat distanceToBox(vec3 point, vec3 halfExtent, float radius) {\n    // Calculate the distance from the point to the box\n    vec3 distanceToBox = abs(point) - halfExtent;\n    // Returns: Negative inside the rounded box, Zero on the surface, Positive outside.\n    return length(max(distanceToBox, 0.0)) - radius;\n}\n\n// Blends two distances smoothly, instead of taking the harsh minimum (min()), which gives a hard union in SDFs.\nfloat smoothUnion(float distance1, float distance2, float smoothFactor) {\n    // h decides how much to interpolate between distance2 and distance1\n    float h = clamp(0.5 + 0.5 * (distance2 - distance1) / smoothFactor, 0.0, 1.0);\n    return mix(distance2, distance1, h) - smoothFactor * h * (1.0 - h);\n}\n\n// Modified animation function with instance parameters\nvec2 dolphinAnimation(float position, float time, float timeOffset) {\n    float adjustedTime = time + timeOffset;\n    float angle1 = 0.9*(0.5+0.2*position)*cos(5.0*position - 3.0*adjustedTime + 6.2831/4.0);\n    float angle2 = 1.0*cos(3.5*position - 1.0*adjustedTime + 6.2831/4.0);\n    float jumping = 0.5 + 0.5*cos(-0.4+0.5*adjustedTime);\n    float finalAngle = mix(angle1, angle2, jumping);\n    float thickness = 0.4*cos(4.0*position - 1.0*adjustedTime)*(1.0-0.5*jumping);\n    return vec2(finalAngle, thickness);\n}\n\n// generates a 3D animation offset vector used to animate some aspect of the dolphin\n\n// Modified movement function with instance parameters\nvec3 dolphinMovement(float time, float timeOffset, vec3 basePosition, float speed, vec3 direction) {\n    float adjustedTime = time + timeOffset;\n    float jumping = 0.5 + 0.5*cos(-0.4+0.5*adjustedTime);\n\n    vec3 movement1 = vec3(0.0, sin(3.0*adjustedTime + 6.2831/4.0), 0.0);\n    vec3 movement2 = vec3(0.0, 1.5 + 2.5*cos(1.0*adjustedTime), 0.0);\n    vec3 finalMovement = mix(movement1, movement2, jumping);\n    finalMovement.y *= 0.5;\n    finalMovement.x += 0.1*sin(0.1 - 1.0*adjustedTime)*(1.0-jumping);\n\n    // Apply linear movement\n    vec3 worldOffset = vec3(0.0, 0.0, mod(-speed * time, 10.0) - 5.0);\n\n    return basePosition + finalMovement + worldOffset;\n}\n\n//returning: res.x: The signed distance from point p to the dolphin. res.y: A parameter h that stores a normalized position along the dolphin's body (used for further shaping/decorating).\nvec2 dolphinDistance(vec3 point, Dolphin dolphin, float time) {\n\n    // Initialize the result to a very large distance and an auxiliary value of 0. We'll minimize this value over the dolphin's body parts.\n    vec2 result = vec2( 1000.0, 0.0);\n    // Transform Point into Dolphin Local Space\n    // Initialize the start point for the dolphin's body\n    vec3 startPoint = dolphinMovement(time, dolphin.timeOffset, dolphin.position, dolphin.speed, dolphin.direction);\n\n    vec3 position1 = startPoint;\n    vec3 position2 = startPoint;\n    vec3 position3 = startPoint;\n    vec3 direction1 = vec3(0.0,0.0,0.0);\n    vec3 direction2 = vec3(0.0,0.0,0.0);\n    vec3 direction3 = vec3(0.0,0.0,0.0);\n    vec3 closestPoint = startPoint;\n    // Iterates through all the dolphin\u2019s spine segments (same concept as in dolphinSignedDistance)\n    for(int i=0; i&lt;NO_OF_SEGMENTS; i++)\n    {\n        // Compute Normalized Segment Index and Animation\n        float segmentPosition = float(i)/F_NO_OF_SEGMENTS;\n        vec2 segmentAnimation = dolphinAnimation(segmentPosition, time, dolphin.timeOffset);\n        // The length of segments\n        float segmentLength = 0.48; if( i==0 ) segmentLength=0.655;\n        // endPoint is the end point of the current segment. The orientation of the segment is controlled by angles (segmentAnimation.x, segmentAnimation.y). This creates a wavy, sinuous body as the dolphin swims.\n        vec3 endPoint = startPoint + segmentLength*normalize(vec3(sin(segmentAnimation.y), sin(segmentAnimation.x), cos(segmentAnimation.x)));\n        // Calculate the distance from the point to the line segment defined by startPoint and endPoint\n        vec2 dist = lineSegmentDistance(point, startPoint, endPoint);\n\n        if(dist.x &lt; result.x)\n        {\n            result = vec2(dist.x,segmentPosition+dist.y/F_NO_OF_SEGMENTS);\n            closestPoint = startPoint + dist.y*(endPoint-startPoint);\n            ccd = endPoint - startPoint; // This is the direction vector of the segment\n\n        }\n        // Store Specific Segment Info for Fins and Tail\n        if(i==3) \n        {position1 = startPoint; direction1 = endPoint-startPoint;}\n        if(i==4)\n        {position3 = startPoint; direction3 = endPoint-startPoint;}\n        if(i==(NO_OF_SEGMENTS-1))\n        {position2 = endPoint; direction2 = endPoint-startPoint;}\n        // Move Forward to Next Segment\n        startPoint = endPoint;\n    }\n       // Save Closest Point (This is the Target Line)\n        ccp = closestPoint;\n        // It lies in the range [0.0,1.0][0.0,1.0], where 0 is near the head and 1 is at the tail.\n        float bodyRadius = result.y;\n        // The radius of the dolphin's body at that point. This shapes the body to be thickest near the middle and tapering toward head and tail.\n        float radius = 0.05 + bodyRadius*(1.0-bodyRadius)*(1.0-bodyRadius)*2.7;\n        //This adds a bump in the radius near the front of the dolphin (around bodyRadius \u2248 0.04), which decays rapidly afterward.\n        radius += 7.0*max(0.0,bodyRadius-0.04)*exp(-30.0*max(0.0,bodyRadius-0.04)) * smoothstep(-0.1, 0.1, point.y-closestPoint.y);\n        // Reduces radius near the center line (point.y \u2248 closestPoint.y) and only in the front part (h &lt; 0.1).\n        radius -= 0.03*(smoothstep(0.0, 0.1, abs(point.y-closestPoint.y)))*(1.0-smoothstep(0.0,0.1,bodyRadius));\n        // Add Thickness Near the Head\n        radius += 0.05*clamp(1.0-3.0*bodyRadius,0.0,1.0);\n        radius += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(bodyRadius-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(point.y-closestPoint.y)));\n        // The true signed distance is the distance from point p to the spine (closestPoint) minus the radius at that location. Scaled by 0.75 to compress or adjust the final SDF\n        result.x = 0.75 * (distance(point, closestPoint) - radius); \n\n        // fin part\n        direction3 = normalize(direction3);\n        float k = sqrt(1.0 - direction3.y*direction3.y);\n        // Create a transformation matrix to align the local coordinate system with the dolphin's fin direction\n        mat3 ms = mat3(\n            direction3.z/k, -direction3.x*direction3.y/k, direction3.x,\n            0.0,            k,                            direction3.y,\n            -direction3.x/k, -direction3.y*direction3.z/k, direction3.z);\n        // Transform the point into the local coordinate system of the fin\n        vec3 ps = ms * (point - position3);\n        ps.z -= 0.1; // This is the offset for the fin\n        float distance5 = length(ps.yz) - 0.9;\n        distance5 = max(distance5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n        distance5 = max(distance5, distanceToBox(ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n        result.x = smoothUnion(result.x, distance5, 0.1);\n\n        // fin \n        direction1 = normalize(direction1);\n        k = sqrt(1.0 - direction1.y*direction1.y);\n        ms = mat3(\n            direction1.z/k, -direction1.x*direction1.y/k, direction1.x,\n            0.0, k, direction1.y,\n            -direction1.x/k, -direction1.y*direction1.z/k, direction1.z);\n\n        ps = point - position1;\n        ps = ms * ps;\n        ps.x = abs(ps.x);\n        float l = ps.x;\n        l = clamp((l-0.4)/0.5, 0.0, 1.0);\n        l = 4.0 * l * (1.0 - l);\n        l *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n        ps.xyz += vec3(-0.2,0.36,-0.2);\n        distance5 = length(ps.xz) - 0.8;\n        distance5 = max(distance5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n        distance5 = max(distance5, distanceToBox(ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n        result.x = smoothUnion(result.x, distance5, 0.12);\n\n        // tail part\n        direction2 = normalize(direction2);\n        mat2 mf = mat2(\n            direction2.z, direction2.y,\n            -direction2.y, direction2.z);\n        vec3 pf = point - position2 - direction2*0.25;\n        pf.yz = mf * pf.yz;\n        float distance4 = length(pf.xz) - 0.6;\n        distance4 = max(distance4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n        distance4 = max(distance4, distanceToBox(pf, vec3(1.0,0.005,1.0), 0.005 ) );\n        result.x = smoothUnion(result.x, distance4, 0.1);\n        // Return the signed distance and the auxiliary value\n        return result;\n}\n\nvec3 dolphinNormal(vec3 point, int dolphinIDX, float time) {\n    vec3 normal = vec3(0.0);\n    const float eps = 0.08; // Smaller epsilon for more accurate normals\n\n    for(int i = 0; i &lt; 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)&gt;&gt;1)&amp;1),((i&gt;&gt;1)&amp;1),(i&amp;1))-1.0);\n        vec2 dist = dolphinDistance(point + eps*e, dolphins[dolphinIDX], time);\n        normal += e * dist.x; // Use the distance field value\n    }\n\n    return normalize(normal);\n}\nvoid getDolhpinColor(vec3 position, out vec3 color){\n        vec3 material;\n        material.xyz = mix( vec3(0.3,0.38,0.46)*0.6, vec3(0.8,0.9,1.0), smoothstep(-0.05,0.05,position.y-segmentIdx*0.5+0.1) ); // Base color of the dolphin\n        material.xyz *= smoothstep( 0.0, 0.06, distance(vec3(abs(position.x),position.yz)*vec3(1.0,1.0,4.0),vec3(0.35,0.0,0.4)));  \n        material.xyz *= 1.0 - 0.75*(1.0-smoothstep( 0.0, 0.02, abs(position.y) ))*(1.0-smoothstep( 0.07, 0.11, segmentIdx ));\n        material.xyz *= 0.1*0.23*0.6;\n        color = material;\n        }\n</code></pre>"},{"location":"shaders/scenes/terrain_castle/","title":"\ud83e\udde9 Terrain and Castle Integration Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: </li> <li>Input Requirements: </li> <li>Output: </li> </ul>"},{"location":"shaders/scenes/water_surface/","title":"\ud83e\udde9 Procedural Water Surface Shader","text":"<ul> <li>Category: Scene</li> <li>Author: Xuetong Fu</li> <li>Shader Type: Animated water surface with hash noise and SDF raymarching</li> <li>Input Requirements: <code>fragCoord</code>, <code>iTime</code>, <code>iMouse</code>, <code>iResolution</code>, <code>iChannel0\u00a0(noise\u202ftexture)</code></li> <li>Output: <code>fragColor</code> RGBA color (animated water surface with highlights and depth-based fog)</li> </ul>"},{"location":"shaders/scenes/water_surface/#algorithm","title":"\ud83e\udde0 Algorithm","text":""},{"location":"shaders/scenes/water_surface/#core-concept","title":"\ud83d\udd37 Core Concept","text":"<p>This demo raymarches a signed\u2011distance field whose height is driven by multi\u2011octave hash noise to mimic waves.</p> Stage Function Purpose Wave Height <code>computeWave()</code> Generates multi\u2011octave hash\u2011noise shaped by a sine function, with time\u2011varying rotation to create wave patterns. Distance Field <code>evaluateDistanceField()</code> Wraps the signed height from <code>computeWave()</code> into a <code>vec2(dist, matID)</code> for raymarching (<code>matID = 5.0</code> marks water). Raymarching <code>traceWater()</code> Performs up to 128 steps of sphere tracing, stopping early if the distance to the surface is below a small threshold (\u03b5) or the ray exceeds the maximum depth. Normal Estimate computed directly in\u202f<code>mainImage()</code> Uses central differences in x and z over the wave height field (and a constant in y) to build the surface\u2010normal gradient. Detail &amp; Tint <code>sampleNoiseTexture()</code> Samples iChannel0 at four different texture scales to add small ripples and uses the aggregated value to blend between deep and bright water colors. Lighting Fresnel term + view fog Produces a Fresnel highlight\u202f\u2014<code>(1\u2011N\u00b7V)^5</code>\u2014 for edge\u2011on sparkle, then fades the water colour with a cubic exponential. <p>Result: A moving water surface with dark low waves, bright wave tops, and a camera that can orbit around it.</p>"},{"location":"shaders/scenes/water_surface/#parameters","title":"\ud83c\udf9b\ufe0f Parameters","text":"Name Description Range / Unit Default <code>iTime</code> Global time seconds \u2014 <code>iMouse.xy</code> Yaw / pitch for orbit camera pixels (0\u2013<code>iResolution</code>) (0,\u202f0) <code>iResolution</code> Viewport resolution pixels \u2014 <code>iChannel0</code> RG noise texture (uses <code>.r</code> only) sampler2D vec4(0.0) if unbound <code>CAMERA_POSITION</code> Start pos (world space) vec3 (0,2.5,8) <code>iterationCount</code> Octaves in <code>computeWave()</code> int\u00a0\u2265\u202f1 7 <p>To use this shader outside ShaderToy (e.g., in Unity or  Godot):</p> <ul> <li><code>iTime</code> \u2192 <code>_Time.y</code> in Unity / <code>TIME</code> in Godot</li> <li><code>iResolution</code> \u2192 screen resolution vector</li> <li><code>iChannel0</code> \u2192 supply your own 4-octave noise texture</li> <li><code>iMouse</code> \u2192 remap to your camera controller input</li> </ul> <p>Make sure to adjust the entry point from <code>mainImage(out vec4 fragColor, in vec2 fragCoord)</code> to match your rendering pipeline.</p>"},{"location":"shaders/scenes/water_surface/#shader-code-includes","title":"\ud83d\udcbb Shader Code &amp; Includes","text":""},{"location":"shaders/scenes/water_surface/#1-wave-height-field-function","title":"1. Wave Height Field Function","text":"<p>The <code>computeWave()</code> function generates a signed height field using multi-octave hash-based noise combined with time-varying rotation, simulating fractal waveforms. It returns positive values above the surface and negative below. The <code>evaluateDistanceField()</code> wraps this into a <code>vec2(dist, 0.5)</code>, enabling any 3D point to be evaluated as a signed distance to the water surface\u2014providing a compact SDF for efficient sphere tracing.</p> <pre><code>// ---------- Wave Generation ----------\nfloat computeWave(vec3 pos, int iterationCount, float writeOut) {\n    vec3 warped = pos - vec3(0, 0, globalTimeWrapped * 3.0);\n\n    float direction = sin(iTime * 0.15);\n    float angle = 0.001 * direction;\n    mat2 rotation = computeRotationMatrix(angle);\n\n    float accum = 0.0, amplitude = 3.0;\n    for (int i = 0; i &lt; iterationCount; i++) {\n        accum += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * (amplitude *= 0.51);\n        warped.xy *= rotation;\n        warped *= 1.75;\n    }\n\n    if (writeOut &gt; 0.0) {\n        controlPoint = warped;\n        waveStrength = accum;\n    }\n\n    float height = pos.y + accum;\n    height *= 0.5;\n    height += 0.3 * sin(iTime + pos.x * 0.3);  // slight bobbing\n\n    return height;\n}\n\n// ---------- SDF Mapping ----------\nvec2 evaluateDistanceField(vec3 pos, float writeOut) {\n    return vec2(computeWave(pos, 7, writeOut), 5.0);\n}\n</code></pre>"},{"location":"shaders/scenes/water_surface/#2-spheretracing-function","title":"2. Sphere\u2011Tracing\u00a0Function","text":"<p><code>traceWater()</code> marches a ray through the scene using sphere tracing: at each step it queries the SDF for the nearest\u2011surface distance and \u201cjumps\u201d exactly that far, guaranteeing it never penetrates geometry. The loop terminates when the ray is closer than\u00a0\u03b5\u202f(\u202f1\u202f\u00d7\u202f10\u207b\u2074\u202f) to the water surface or when it exceeds a safety depth of\u202f43\u202funits. It returns a packed <code>vec2(hitDist,\u202fmatID)</code> where <code>matID\u00a0=\u00a00.0</code> marks a miss and any non\u2011zero value identifies water.</p> <pre><code>// ---------- Sphere\u00a0Tracing ----------\nvec2 traceWater(vec3 rayOrigin, vec3 rayDir) {\n    vec2 d, hit = vec2(0.1);\n    for (int i = 0; i &lt; 128; i++) {\n        d = evaluateDistanceField(rayOrigin + rayDir * hit.x, 1.0);\n        if (d.x &lt; 0.0001 || hit.x &gt; 43.0) break;\n        hit.x += d.x;\n        hit.y = d.y;\n    }\n    if (hit.x &gt; 43.0) hit.y = 0.0;\n    return hit;\n}\n</code></pre>"},{"location":"shaders/scenes/water_surface/#3-normal-estimation-fresnel-highlight","title":"3. Normal Estimation\u00a0&amp;\u00a0Fresnel Highlight","text":"<p>After the ray hits the water surface, we need a surface normal for lighting. Because the water is defined implicitly by an SDF (height field), we approximate the normal with a central\u2010difference gradient of the same <code>computeWave()</code> function. Once the normalized gradient N is known, we compute a view\u2010dependent Fresnel term\u202f<code>F\u00a0=\u00a0(1\u00a0\u2212\u00a0N\u00b7V)^5</code>, producing a realistic glancing\u2011angle sparkle that is clamped and scaled into a highlight factor.</p> <pre><code>// ---------- Gradient-based normal estimation ----------\nvec3 grad = normalize(vec3(\n    computeWave(surfacePos + vec3(0.01, 0.0, 0.0), 7, 0.0) - computeWave(surfacePos - vec3(0.01, 0.0, 0.0), 7, 0.0),\n    0.02,\n    computeWave(surfacePos + vec3(0.0, 0.0, 0.01), 7, 0.0) - computeWave(surfacePos - vec3(0.0, 0.0, 0.01), 7, 0.0)\n    ));\n\n// ---------- Fresnel-style highlight ----------\nfloat fresnel = pow(1.0 - dot(grad, -rayDir), 5.0);\nfloat highlight = clamp(fresnel * 1.5, 0.0, 1.0);\n</code></pre>"},{"location":"shaders/scenes/water_surface/#full-code","title":"Full Code","text":"\ud83d\udcc4 WaterSurface.glsl <pre><code>// ---------- Global Configuration ----------\n#define CAMERA_POSITION vec3(0.0, 2.5, 8.0)\n\n// ---------- Global State ----------\nvec2 offsetA, offsetB = vec2(0.00035, -0.00035), dummyVec = vec2(-1.7, 1.7);\nfloat waveTime, globalTimeWrapped, noiseBias = 0.0, waveStrength = 0.0, globalAccum = 0.0;\nvec3 controlPoint, rotatedPos, wavePoint, surfacePos, surfaceNormal, texSamplePos;\n\n// ---------- Utilities ----------\nmat2 computeRotationMatrix(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nconst mat2 rotationMatrixSlow = mat2(cos(0.023), sin(0.023), -cos(0.023), sin(0.023));\n\nfloat hashNoise(vec3 p) {\n    vec3 f = floor(p), magic = vec3(7, 157, 113);\n    p -= f;\n    vec4 h = vec4(0, magic.yz, magic.y + magic.z) + dot(f, magic);\n    p *= p * (3.0 - 2.0 * p);\n    h = mix(fract(sin(h) * 43785.5), fract(sin(h + magic.x) * 43785.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// ---------- Wave Generation ----------\n\nfloat computeWave(vec3 pos, int iterationCount, float writeOut) {\n    vec3 warped = pos - vec3(0, 0, globalTimeWrapped * 3.0);\n\n    float direction = sin(iTime * 0.15);\n    float angle = 0.001 * direction;\n    mat2 rotation = computeRotationMatrix(angle);\n\n    float accum = 0.0, amplitude = 3.0;\n    for (int i = 0; i &lt; iterationCount; i++) {\n        accum += abs(sin(hashNoise(warped * 0.15) - 0.5) * 3.14) * (amplitude *= 0.51);\n        warped.xy *= rotation;\n        warped *= 1.75;\n    }\n\n    if (writeOut &gt; 0.0) {\n        controlPoint = warped;\n        waveStrength = accum;\n    }\n\n    float height = pos.y + accum;\n    height *= 0.5;\n    height += 0.3 * sin(iTime + pos.x * 0.3);  // slight bobbing\n\n    return height;\n}\n\nvec2 evaluateDistanceField(vec3 pos, float writeOut) {\n    return vec2(computeWave(pos, 7, writeOut), 5.0);\n}\n\nvec2 traceWater(vec3 rayOrigin, vec3 rayDir) {\n    vec2 d, hit = vec2(0.1);\n    for (int i = 0; i &lt; 128; i++) {\n        d = evaluateDistanceField(rayOrigin + rayDir * hit.x, 1.0);\n        if (d.x &lt; 0.0001 || hit.x &gt; 43.0) break;\n        hit.x += d.x;\n        hit.y = d.y;\n    }\n    if (hit.x &gt; 43.0) hit.y = 0.0;\n    return hit;\n}\n\nmat3 computeCameraBasis(vec3 forward, vec3 up) {\n    vec3 right = normalize(cross(forward, up));\n    vec3 camUp = cross(right, forward);\n    return mat3(right, camUp, forward);\n}\n\nvec4 sampleNoiseTexture(vec2 uv, sampler2D tex) {\n    float f = 0.0;\n    f += texture(tex, uv * 0.125).r * 0.5;\n    f += texture(tex, uv * 0.25).r * 0.25;\n    f += texture(tex, uv * 0.5).r * 0.125;\n    f += texture(tex, uv * 1.0).r * 0.125;\n    f = pow(f, 1.2);\n    return vec4(f * 0.45 + 0.05);\n}\n\n// ---------- Main Image ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1.0);\n    globalTimeWrapped = mod(iTime, 62.83);\n\n    // Orbit camera: yaw/pitch from mouse\n    vec2 m = (iMouse.xy == vec2(0.0)) ? vec2(0.0) : iMouse.xy / iResolution.xy;\n    float yaw = 6.2831 * (m.x - 0.5);\n    float pitch = 1.5 * 3.1416 * (m.y - 0.5);\n    float cosPitch = cos(pitch);\n\n    vec3 viewDir = normalize(vec3(\n        sin(yaw) * cosPitch,\n        sin(pitch),\n        cos(yaw) * cosPitch\n    ));\n\n    vec3 rayOrigin = CAMERA_POSITION;\n    mat3 cameraBasis = computeCameraBasis(viewDir, vec3(0, 1, 0));\n    vec3 rayDir = cameraBasis * normalize(vec3(uv, 1.0));\n\n    // Default background color\n    vec3 baseColor = vec3(0.05, 0.07, 0.1);\n    vec3 color = baseColor;\n\n    // Raymarching\n    vec2 hit = traceWater(rayOrigin, rayDir);\n    if (hit.y &gt; 0.0) {\n        surfacePos = rayOrigin + rayDir * hit.x;\n\n        // Gradient-based normal estimation\n        vec3 grad = normalize(vec3(\n            computeWave(surfacePos + vec3(0.01, 0.0, 0.0), 7, 0.0) -\n            computeWave(surfacePos - vec3(0.01, 0.0, 0.0), 7, 0.0),\n            0.02,\n            computeWave(surfacePos + vec3(0.0, 0.0, 0.01), 7, 0.0) -\n            computeWave(surfacePos - vec3(0.0, 0.0, 0.01), 7, 0.0)\n        ));\n\n        // Fresnel-style highlight\n        float fresnel = pow(1.0 - dot(grad, -rayDir), 5.0);\n        float highlight = clamp(fresnel * 1.5, 0.0, 1.0);\n\n        // Texture detail sampling\n        float texNoiseVal = sampleNoiseTexture(controlPoint.xz * 0.0005, iChannel0).r +\n                            sampleNoiseTexture(controlPoint.xz * 0.005, iChannel0).r * 0.5;\n\n        // Water shading: deep vs bright\n        vec3 deepColor = vec3(0.05, 0.1, 0.2);\n        vec3 brightColor = vec3(0.1, 0.3, 0.9);\n        float shading = clamp(waveStrength * 0.1 + texNoiseVal * 0.8, 0.0, 1.0);\n        vec3 waterColor = mix(deepColor, brightColor, shading);\n\n        // Add highlight\n        waterColor += vec3(1.0) * highlight * 0.4;\n\n        // Depth-based fog\n        float fog = exp(-0.00005 * hit.x * hit.x * hit.x);\n        color = mix(baseColor, waterColor, fog);\n    }\n\n    // Gamma correction\n    fragColor = vec4(pow(color + globalAccum * 0.2 * vec3(0.7, 0.2, 0.1), vec3(0.55)), 1.0);\n}\n</code></pre> <p>\ud83d\udd17 View Full Shader Code on GitHub</p>"},{"location":"shaders/scenes/water_surface/#engine-integrations","title":"Engine Integrations","text":"Unity"}]}