[gd_resource type="VisualShader" load_steps=14 format=3 uid="uid://db6fdpou4xm54"]

[ext_resource type="Script" uid="uid://cymxgyb5ddloh" path="res://addons/visual_shader_nodes/raymarching/sphereSDF.gd" id="1_ef264"]
[ext_resource type="Script" uid="uid://ddiwegtaghvmp" path="res://addons/visual_shader_nodes/raymarching/raymarchfinalized.gd" id="2_ggbnq"]

[sub_resource type="VisualShaderNodeCustom" id="VisualShaderNodeCustom_atc37"]
initialized = true
script = ExtResource("1_ef264")

[sub_resource type="VisualShaderNodeCustom" id="VisualShaderNodeCustom_xsoht"]
initialized = true
script = ExtResource("1_ef264")

[sub_resource type="VisualShaderNodeFloatConstant" id="VisualShaderNodeFloatConstant_v2ofp"]
constant = 5.0

[sub_resource type="VisualShaderNodeVec3Constant" id="VisualShaderNodeVec3Constant_ef264"]
constant = Vector3(0, 0, 7)

[sub_resource type="VisualShaderNodeVec2Constant" id="VisualShaderNodeVec2Constant_sltt4"]
constant = Vector2(1024, 768)

[sub_resource type="VisualShaderNodeCustom" id="VisualShaderNodeCustom_ggbnq"]
initialized = true
script = ExtResource("2_ggbnq")

[sub_resource type="VisualShaderNodeFloatConstant" id="VisualShaderNodeFloatConstant_ef264"]

[sub_resource type="VisualShaderNodeFloatConstant" id="VisualShaderNodeFloatConstant_3m831"]
constant = 1.0

[sub_resource type="VisualShaderNodeVec3Constant" id="VisualShaderNodeVec3Constant_sltt4"]
constant = Vector3(-1, 0, 0)

[sub_resource type="VisualShaderNodeVec3Constant" id="VisualShaderNodeVec3Constant_atc37"]
constant = Vector3(5, 0, 0)

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_xsoht"]
input_name = "uv"

[resource]
code = "shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, diffuse_lambert, specular_schlick_ggx;



// SphereSDF

int addSphereNode(vec3 position, float radius, int inputIndex, bool enabled) {
	if (!enabled) {
		return inputIndex;
	}
	return inputIndex + 1;
}

// RaymarchSDF

#include \"res://addons/includes/dynamic_sdf_system.gdshaderinc\"

vec4 renderDynamicSDFScene(vec2 uv, vec2 resolution, int sdfCount, vec3 rayOrigin) {
    // Set up camera ray
    vec2 screenUV = uv * 2.0 - 1.0;
    screenUV.x *= resolution.x / resolution.y;
    
    vec3 rayDirection = normalize(vec3(screenUV, -1.0));

    // Built-in light setup
    vec3 lightPos = vec3(5.0, 5.0, 5.0);
    vec3 lightColor = vec3(1.0);

    // Perform dynamic raymarching
    vec3 hitPosition;
    int hitID;
    float hitDistance = dynamicRaymarch(rayOrigin, rayDirection, sdfCount, hitPosition, hitID);

    // Background color
    vec3 backgroundColor = vec3(0.1, 0.1, 0.2);

    // Check if we hit something
    if (hitDistance < 0.0 || hitID < 0) {
        return vec4(backgroundColor, 1.0);
    }
    
    // Calculate surface normal
    vec3 normal = getDynamicNormal(hitPosition, sdfCount);
    
    // View direction (from surface to camera)
    vec3 viewDir = normalize(rayOrigin - hitPosition);
    
    // Light direction
    vec3 lightDir = normalize(lightPos - hitPosition);
    
    // Distance attenuation
    float lightDistance = length(lightPos - hitPosition);
    float attenuation = 1.0 / (1.0 + 0.09 * lightDistance + 0.032 * lightDistance * lightDistance);
    
    // Get material properties based on object type
    vec3 albedo;
    float metallic;
    float roughness;
    float specular;
    
    // Use the actual object type from the dynamic system
    if (g_types[hitID] == 0) {        // Sphere
        albedo = vec3(0.2, 0.2, 1.0);     // Blue
        metallic = 0.0;
        roughness = 0.3;
        specular = 0.8;
    } else if (g_types[hitID] == 1) { // Round box
        albedo = vec3(0.2, 1.0, 0.2);     // Green
        metallic = 0.1;
        roughness = 0.6;
        specular = 0.4;
    } else if (g_types[hitID] == 2) { // Torus
        albedo = vec3(1.0, 0.2, 0.2);     // Red
        metallic = 0.8;
        roughness = 0.2;
        specular = 0.9;
    } else {
        // Fallback color based on hitID
        float colorPhase = float(hitID) * 0.5;
        albedo = vec3(
            0.5 + 0.5 * sin(colorPhase),
            0.5 + 0.5 * sin(colorPhase + 2.0),
            0.5 + 0.5 * sin(colorPhase + 4.0)
        );
        metallic = 0.2;
        roughness = 0.5;
        specular = 0.6;
    }
    
    // Lambertian diffuse
    float NdotL = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = NdotL * albedo * lightColor * attenuation;
    
    // Blinn-Phong specular
    vec3 halfDir = normalize(lightDir + viewDir);
    float NdotH = max(dot(normal, halfDir), 0.0);
    float shininess = mix(2.0, 256.0, 1.0 - roughness);
    float spec = pow(NdotH, shininess);
    vec3 specularColor = spec * specular * lightColor * attenuation;
    
    // Simple metallic workflow
    vec3 finalDiffuse = mix(diffuse, vec3(0.0), metallic);
    vec3 finalSpecular = mix(specularColor, diffuse * spec, metallic);
    
    // Rim lighting for extra pop
    float rimPower = 2.0;
    float rim = 1.0 - max(dot(normal, viewDir), 0.0);
    vec3 rimLight = pow(rim, rimPower) * lightColor * 0.3;
    
    // Ambient light
    vec3 ambient = albedo * 0.15;
    
    // Combine all lighting
    vec3 finalColor = ambient + finalDiffuse + finalSpecular + rimLight;
    
    // Optional: Add fog based on distance
    float fogFactor = exp(-hitDistance * 0.02);
    finalColor = mix(backgroundColor, finalColor, fogFactor);
    
    // Tone mapping for better colors
    finalColor = finalColor / (finalColor + vec3(1.0));
    
    return vec4(finalColor, 1.0);
}


void fragment() {
// Input:8
	vec2 n_out8p0 = UV;


// Vector2Constant:19
	vec2 n_out19p0 = vec2(1024.000000, 768.000000);


// FloatConstant:3
	float n_out3p0 = 0.000000;


// Vector3Constant:5
	vec3 n_out5p0 = vec3(-1.000000, 0.000000, 0.000000);


// FloatConstant:4
	float n_out4p0 = 1.000000;


	int n_out12p0;
// SphereSDF:12
	{
		n_out12p0 = addSphereNode(n_out5p0, n_out4p0, int(n_out3p0), true);
	}


// Vector3Constant:7
	vec3 n_out7p0 = vec3(5.000000, 0.000000, 0.000000);


// FloatConstant:15
	float n_out15p0 = 5.000000;


	int n_out10p0;
// SphereSDF:10
	{
		n_out10p0 = addSphereNode(n_out7p0, n_out15p0, n_out12p0, true);
	}


// Vector3Constant:16
	vec3 n_out16p0 = vec3(0.000000, 0.000000, 7.000000);


	vec4 n_out20p0;
// RaymarchSDF:20
	{
		n_out20p0 = renderDynamicSDFScene(n_out8p0, n_out19p0, n_out10p0, n_out16p0);
	}


// Output:0
	ALBEDO = vec3(n_out20p0.xyz);


}
"
nodes/vertex/0/position = Vector2(2120, -2720)
nodes/fragment/0/position = Vector2(1700, -360)
nodes/fragment/3/node = SubResource("VisualShaderNodeFloatConstant_ef264")
nodes/fragment/3/position = Vector2(-560, -180)
nodes/fragment/4/node = SubResource("VisualShaderNodeFloatConstant_3m831")
nodes/fragment/4/position = Vector2(-640, 340)
nodes/fragment/5/node = SubResource("VisualShaderNodeVec3Constant_sltt4")
nodes/fragment/5/position = Vector2(-680, 140)
nodes/fragment/7/node = SubResource("VisualShaderNodeVec3Constant_atc37")
nodes/fragment/7/position = Vector2(-620, 560)
nodes/fragment/8/node = SubResource("VisualShaderNodeInput_xsoht")
nodes/fragment/8/position = Vector2(-120, 1160)
nodes/fragment/10/node = SubResource("VisualShaderNodeCustom_atc37")
nodes/fragment/10/position = Vector2(640, -260)
nodes/fragment/12/node = SubResource("VisualShaderNodeCustom_xsoht")
nodes/fragment/12/position = Vector2(100, -420)
nodes/fragment/15/node = SubResource("VisualShaderNodeFloatConstant_v2ofp")
nodes/fragment/15/position = Vector2(0, 300)
nodes/fragment/16/node = SubResource("VisualShaderNodeVec3Constant_ef264")
nodes/fragment/16/position = Vector2(-560, 760)
nodes/fragment/19/node = SubResource("VisualShaderNodeVec2Constant_sltt4")
nodes/fragment/19/position = Vector2(1000, 680)
nodes/fragment/20/node = SubResource("VisualShaderNodeCustom_ggbnq")
nodes/fragment/20/position = Vector2(1200, 60)
nodes/fragment/connections = PackedInt32Array(3, 0, 12, 0, 12, 0, 10, 0, 5, 0, 12, 1, 4, 0, 12, 2, 7, 0, 10, 1, 15, 0, 10, 2, 10, 0, 20, 2, 20, 0, 0, 0, 8, 0, 20, 0, 16, 0, 20, 3, 19, 0, 20, 1)
nodes/light/0/position = Vector2(1460, -860)
